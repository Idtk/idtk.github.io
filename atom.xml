<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Idtk</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.idtkm.com/"/>
  <updated>2017-10-26T15:23:00.342Z</updated>
  <id>http://www.idtkm.com/</id>
  
  <author>
    <name>Idtk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Retrofit2 + OkHttp3 配置及Interceptor原理</title>
    <link href="http://www.idtkm.com/2017/10/26/Retrofit2%20&amp;%20OkHttp3%20Interceptor/"/>
    <id>http://www.idtkm.com/2017/10/26/Retrofit2 &amp; OkHttp3 Interceptor/</id>
    <published>2017-10-26T15:00:00.000Z</published>
    <updated>2017-10-26T15:23:00.342Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间在给公司的新app做一些基础模块的封装，把Http模块中的一些基础配置，比如设置链接超时、Http Log Interceptor、Access Token Interceptor、Status Code Interceptor，以及Json转换、RxJava适配等设置做一下分享，再简单说说OkHttp Interceptor原理。</p>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h3 id="OkHttp配置"><a href="#OkHttp配置" class="headerlink" title="OkHttp配置"></a>OkHttp配置</h3><p>OkHttp主要采用Builder模式进行配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">HttpLoggingInterceptor.Logger CUSTOM = <span class="keyword">new</span> HttpLoggingInterceptor.Logger() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        Platform.get().log(INFO, <span class="string">"OkHttp-idtk： "</span> + message, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">HttpLoggingInterceptor loggingInterceptor = <span class="keyword">new</span> HttpLoggingInterceptor(CUSTOM);</div><div class="line">loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);</div><div class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</div><div class="line">        .readTimeout(<span class="number">5</span>, TimeUnit.SECONDS)</div><div class="line">        .writeTimeout(<span class="number">5</span>, TimeUnit.SECONDS)</div><div class="line">        .connectTimeout(<span class="number">15</span>, TimeUnit.SECONDS)</div><div class="line">        .retryOnConnectionFailure(<span class="keyword">true</span>)</div><div class="line">        .addInterceptor(statusInterceptor)</div><div class="line">        .addInterceptor(loggingInterceptor)</div><div class="line">        .addNetworkInterceptor(tokenInterceptor)</div><div class="line">        .build();</div></pre></td></tr></table></figure>
<ul>
<li>retryOnConnectionFailure设置为true，表示请求失败后将会重连。</li>
<li>HttpLoggingInterceptor用于拦截网络请求和响应，并输出Log，我在输出log的标识方面稍微修改了一下，便于使用时的区别。等级分为NONE/BASIC/HEADERS/BODY，其中BODY打印出的最为详细。</li>
<li>addInterceptor与addNetworkInterceptor都是增加OkHttp的网络请求拦截器，但是其中是有一定区别的，前者是添加在与服务器连接之前和之后，后者是添加在与服务器建立连接和发起请求的之间。</li>
<li>tokenInterceptor 是用来设置的token的拦截器，用于网络请求token的统一添加，具体内容会在接下来说明。</li>
<li>statusInterceptor 用于响应返回状态码的处理，比如token过期、注册码无效等状态的处理。</li>
</ul>
<a id="more"></a>
<h4 id="token拦截器"><a href="#token拦截器" class="headerlink" title="token拦截器"></a>token拦截器</h4><p>让所有网络请求都添加上token</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Request request = chain.request();</div><div class="line">    String url = request.url().toString();</div><div class="line">    <span class="keyword">if</span> (NetConfig.needAddToken(request)) &#123;</div><div class="line">        Uri uri = Uri.parse(url);</div><div class="line">        Set&lt;String&gt; oldParam = uri.getQueryParameterNames();</div><div class="line">        <span class="keyword">if</span> (!oldParam.contains(<span class="string">"token"</span>))&#123;</div><div class="line">            String token = getToken();</div><div class="line">            <span class="keyword">if</span> (oldParam.size() &gt;<span class="number">0</span>)&#123;</div><div class="line">                url += <span class="string">"&amp;token="</span> + token;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                url += <span class="string">"?token="</span> +token;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        request = request.newBuilder().url(url).build();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> chain.proceed(request);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>对于登录请求等情况，是不需要添加token的，所以在needAddToken方法中进行了判断。</li>
<li>我这里后台的要求是把token放在url中，所以我进行了如上的写法，你也可以根据自己的需求进行修改。</li>
</ul>
<h4 id="状态码拦截"><a href="#状态码拦截" class="headerlink" title="状态码拦截"></a>状态码拦截</h4><p>对于后台定义的各种状态码进行处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Request request = chain.request();</div><div class="line">    Response response = chain.proceed(request);</div><div class="line">    BaseResult data = <span class="keyword">new</span> Gson().fromJson(response.body().string(), BaseResult.class);</div><div class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"返回数据结构不合法： "</span> + response.body().string());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> status = data.status;</div><div class="line">    <span class="keyword">switch</span> (status)&#123;</div><div class="line">        <span class="keyword">case</span> NetConfig.TOKEN:</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TokenException(data.msg);</div><div class="line">        <span class="keyword">case</span> NetConfig.REGISTER_CODE:</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RegisterException(data.msg);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseResult</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> status;</div><div class="line">    <span class="keyword">public</span> String msg;</div><div class="line">    <span class="keyword">public</span> JsonElement data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>BaseResult是根据与后台的协定设置的，这里首先对data是否为null进行了检测。</li>
<li>在获取状态码之后，对其进行token失效和注册码失效的检测，这里处理抛出异常，之后可以在使用时的基类进行统一处理。当然你也可以使用接口等别的方式进行处理。</li>
</ul>
<h3 id="Retrofit配置"><a href="#Retrofit配置" class="headerlink" title="Retrofit配置"></a>Retrofit配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">        .client(buildClient())</div><div class="line">        .addConverterFactory(GsonConverterFactory.create())</div><div class="line">        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</div><div class="line">        .baseUrl(baseUrl)</div><div class="line">        .build();</div></pre></td></tr></table></figure>
<ul>
<li>addConverterFactory  添加Gson转换器</li>
<li>addCallAdapterFactory  添加Rxjava2适配器</li>
</ul>
<h2 id="拦截器原理"><a href="#拦截器原理" class="headerlink" title="拦截器原理"></a>拦截器原理</h2><p>因为之前写过<a href="http://www.idtkm.com/2017/04/27/Retrofit/">文章</a>分析，所以这里便不再赘述，而对于OkHttp，现在来简单说说其拦截器原理。</p>
<p>OkHttp的使用我想大家都知道，在调用<code>client.newCall(request)</code>将会调用到<code>RealCall.newRealCall(this, request, false);</code>方法，之后将会调用到<code>RealCall.getResponseWithInterceptorChain()</code>函数，而在其中将进行拦截器链的构建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="comment">// Build a full stack of interceptors.</span></div><div class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="comment">// client中配置的interceptors</span></div><div class="line">  interceptors.addAll(client.interceptors());</div><div class="line">  <span class="comment">// 重定向与失败重试</span></div><div class="line">  interceptors.add(retryAndFollowUpInterceptor);</div><div class="line">  <span class="comment">// 用户的请求头处理，响应处理</span></div><div class="line">  <span class="comment">// (Cookie持久性策略)</span></div><div class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</div><div class="line">  <span class="comment">// 缓存请求、响应缓存的写入 (客户端设置的缓存策略)</span></div><div class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</div><div class="line">  <span class="comment">// 与服务器建立连接</span></div><div class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</div><div class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</div><div class="line">    <span class="comment">// client配置的networkInterceptors，用于观察请求和响应</span></div><div class="line">    interceptors.addAll(client.networkInterceptors());</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 发送请求，读取服务器的响应</span></div><div class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</div><div class="line">  <span class="comment">// 设置完整的OkHttp拦截链</span></div><div class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">      interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, originalRequest);</div><div class="line">  <span class="comment">// 调用链中的下一个拦截器，在这里是开始调用第一个拦截器</span></div><div class="line">  <span class="keyword">return</span> chain.proceed(originalRequest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出拦截器列表是从interceptors开始添加的，也就是之前说的HttpLoggingInterceptor、StatusInterceptor，之后添加重定向、cookie、缓存、连接建立的拦截器，然后添加上networkInterceptors，也就是我们之前说的TokenInterceptor，最后通过RealInterceptorChain调用proceed接口启动拦截器。</p>
<p>如果你查看上面各个拦截器的源码，包括我上面自定义的三个拦截器，你会发现其中几乎都使用了<code>chain.proceed</code>方法来生成response，当然CallServerInterceptor其中并没有这个方法，因为它是真正使用去进行请求的拦截器。根据这些我们就可以绘制出一个事件流在拦截其中的过程：</p>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/Retrofit2%20+%20OkHttp3%20Interceptor.png" alt="Interceptor" title="Interceptor"></p>
<p>我们可以在<code>CallServerInterceptor</code>之前对request的header、url等参数进行检测和配置，比如我们自定义的TokenInterceptor，在<code>CallServerInterceptor</code>之后我们可以对response的code、body等进行检测和配置，比如我们之前定义的StatusInterceptor,而HttpLoggingInterceptor则是对request和response都进行检测和配置。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当然Retrofit+OkHttp还有更多的属性配置，比如证书、Cookie等，但这些属性在网络请求中的实现都是在OkHttp Interceptor中进行的，感兴趣的同学建议阅读下源码。</p>
<p>如果在阅读过程中，有任何疑问与问题，欢迎与我联系。<br><strong>博客:www.idtkm.com</strong><br><strong>GitHub:<a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><strong>微博:<a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><strong>邮箱:IdtkMa@gmail.com</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间在给公司的新app做一些基础模块的封装，把Http模块中的一些基础配置，比如设置链接超时、Http Log Interceptor、Access Token Interceptor、Status Code Interceptor，以及Json转换、RxJava适配等设置做一下分享，再简单说说OkHttp Interceptor原理。&lt;/p&gt;
&lt;h2 id=&quot;基本配置&quot;&gt;&lt;a href=&quot;#基本配置&quot; class=&quot;headerlink&quot; title=&quot;基本配置&quot;&gt;&lt;/a&gt;基本配置&lt;/h2&gt;&lt;h3 id=&quot;OkHttp配置&quot;&gt;&lt;a href=&quot;#OkHttp配置&quot; class=&quot;headerlink&quot; title=&quot;OkHttp配置&quot;&gt;&lt;/a&gt;OkHttp配置&lt;/h3&gt;&lt;p&gt;OkHttp主要采用Builder模式进行配置&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;HttpLoggingInterceptor.Logger CUSTOM = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HttpLoggingInterceptor.Logger() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String message)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Platform.get().log(INFO, &lt;span class=&quot;string&quot;&gt;&quot;OkHttp-idtk： &quot;&lt;/span&gt; + message, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;HttpLoggingInterceptor loggingInterceptor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HttpLoggingInterceptor(CUSTOM);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OkHttpClient client = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; OkHttpClient.Builder()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .readTimeout(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, TimeUnit.SECONDS)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .writeTimeout(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, TimeUnit.SECONDS)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .connectTimeout(&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;, TimeUnit.SECONDS)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .retryOnConnectionFailure(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .addInterceptor(statusInterceptor)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .addInterceptor(loggingInterceptor)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .addNetworkInterceptor(tokenInterceptor)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .build();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;retryOnConnectionFailure设置为true，表示请求失败后将会重连。&lt;/li&gt;
&lt;li&gt;HttpLoggingInterceptor用于拦截网络请求和响应，并输出Log，我在输出log的标识方面稍微修改了一下，便于使用时的区别。等级分为NONE/BASIC/HEADERS/BODY，其中BODY打印出的最为详细。&lt;/li&gt;
&lt;li&gt;addInterceptor与addNetworkInterceptor都是增加OkHttp的网络请求拦截器，但是其中是有一定区别的，前者是添加在与服务器连接之前和之后，后者是添加在与服务器建立连接和发起请求的之间。&lt;/li&gt;
&lt;li&gt;tokenInterceptor 是用来设置的token的拦截器，用于网络请求token的统一添加，具体内容会在接下来说明。&lt;/li&gt;
&lt;li&gt;statusInterceptor 用于响应返回状态码的处理，比如token过期、注册码无效等状态的处理。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="OkHttp" scheme="http://www.idtkm.com/tags/OkHttp/"/>
    
      <category term="Retrofit" scheme="http://www.idtkm.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>令人惊喜的Kotlin特性</title>
    <link href="http://www.idtkm.com/2017/07/09/Surprise%20Kotlin/"/>
    <id>http://www.idtkm.com/2017/07/09/Surprise Kotlin/</id>
    <published>2017-07-09T06:00:00.000Z</published>
    <updated>2017-10-15T15:54:37.083Z</updated>
    
    <content type="html"><![CDATA[<p>本文并不准备去详细说明Kotlin的AS配置以及基本的语法，而是介绍一下在使用过程中让我惊喜的Kotlin特性，希望让更多的人喜欢上这个语言。</p>
<h2 id="和findViewById说再见"><a href="#和findViewById说再见" class="headerlink" title="和findViewById说再见"></a>和findViewById说再见</h2><p>第一个要说的应该是很多已经使用了kotlin的同学都体会到的特性。</p>
<p>假设当前Activity对于的布局为如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">        <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">        <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/activity_main"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/main_tv"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"Hello Java!"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们一般会使用如下两个方法之一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">findViewById(R.id.main_tv);</div><div class="line"><span class="comment">//or</span></div><div class="line"><span class="meta">@BindView</span>(R.id.main_tv)</div><div class="line">Button mMainTv;</div></pre></td></tr></table></figure>
<p>不过现在我们可以直接使用对应的id，并且import对应的文件：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">main_tv.text = <span class="string">"Hello Kotlin!"</span></div><div class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_main.*</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果是Adapter的item的xml文件，相应的可以如下这样使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">holder!!.itemView.time_item_tv.text = <span class="string">"<span class="subst">$&#123;date&#125;</span>"</span></div><div class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.item_time.view.*</div></pre></td></tr></table></figure>
<p>虽然这样直接把view的id命名放在类文件中有些与其余变量的驼峰式命名风格不太统一，但是其在代码量上的减少以及代码追踪跳转时的便捷，让我们有足够的理由来使用它。</p>
<h2 id="我们都是final的"><a href="#我们都是final的" class="headerlink" title="我们都是final的"></a>我们都是final的</h2><p>读过《Effective Java》的同学，应该都记得其中对final使用的说明，我们在创建非基类和对应方法时，都应该对其加上final关键字，但是在实际使用过程中很多人却很少可以做到这一点。</p>
<p>让人惊喜的是kotlin的类和方法默认情况下就是final的，像如下这样的情况是无法通过编译的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">function</span><span class="params">()</span></span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// ClassB 与 function都会报错</span></div><div class="line"><span class="comment">// This type is final, so it cannot be inherited from</span></div><div class="line"><span class="comment">// 'function' in 'ClassA' is final and cannot be overridden</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>:<span class="type">ClassA</span></span>()&#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">function</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.function()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果要让其可以继承，需要在相应的位置增加open关键字，就像下面这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span></span>&#123;</div><div class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">function</span><span class="params">()</span></span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="没有外部指针的内部类"><a href="#没有外部指针的内部类" class="headerlink" title="没有外部指针的内部类"></a>没有外部指针的内部类</h2><p>刚开始学习Android的时候，很多同学都或多或少的遇到过因为内部类而引起的内存泄漏的情况吧。比如Handler就是如此，其内部持有了Activity的引用，而可能在一定情况下会引起内存泄漏，当然解决办法也众所周知的，静态内部类+弱引用。</p>
<p>Kotlin在这点上对于初学者是非常友好的，其内部类在默认情况下并没有持有外部类的引用，类似于Java中的静态内部类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>()&#123;</div><div class="line">    <span class="keyword">var</span> outer = <span class="string">"outer"</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</div><div class="line">        <span class="comment">// 这里无法引用到outer，</span></div><div class="line">        <span class="comment">// 因为Inner并没有持有Outer的引用</span></div><div class="line">        <span class="comment">// var inner = outer</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果内部类需要使用外部类的属性或者方法，一种是传参，还有一中就是使用inner关键字。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>()&#123;</div><div class="line">    <span class="keyword">var</span> outer = <span class="string">"outer"</span></div><div class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</div><div class="line">        <span class="comment">// 这里可以使用外部类的outer属性</span></div><div class="line">        <span class="keyword">var</span> inner = outer</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h2><p>我在用了Java之后就一直心心念念之前用C++和Python时候的函数默认参数，而Kotlin满足了我这个期望。使用带有默认参数的函数时，默认参数被忽略会直接使用默认值，这样可以减少重载方法的定义。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">imageProxy</span><span class="params">(id:<span class="type">Int</span>,context:<span class="type">Context</span> = BaseApplication.getInstance()</span></span>)&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2><p>Kotlin中when的出现替代了switch，但其功能更加强大。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">case</span><span class="params">(obj:<span class="type">Any</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">when</span>(obj)&#123;</div><div class="line">        <span class="number">1</span>-&gt; print(<span class="string">"1"</span>)</div><div class="line">        <span class="keyword">in</span> <span class="number">2.</span><span class="number">.16</span> -&gt; print(<span class="string">"Child"</span>)</div><div class="line">        <span class="keyword">is</span> <span class="built_in">Long</span> -&gt; print(<span class="string">"Long"</span>)</div><div class="line">        sumLambda -&gt; print(<span class="string">"sumLambda"</span>)</div><div class="line">        <span class="keyword">else</span> -&gt; print(<span class="string">"No"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有木有感到很厉害！</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Kotlin在字符串之中可以使用变量，相对与在Java中的字符串拼接，更让人感觉到舒服。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"Idtk"</span></div><div class="line"><span class="keyword">var</span> hello = <span class="string">"你好,<span class="subst">$name</span> !"</span></div></pre></td></tr></table></figure>
<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>Kotlin可以这样很简单的写出一个匿名函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> sumLambda = &#123;x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y&#125;</div></pre></td></tr></table></figure>
<p>当然更有意义的是你还可以像这样定义一个变量：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> twoNum: (x:<span class="built_in">Int</span>,y:<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span></div></pre></td></tr></table></figure>
<p>看上去是不是有点像C++的函数指针。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>Kotlin是可以支持函数式编程的，比较明显的一个特征就是，一个函数可以作为另一个函数的输入和输出。</p>
<p>现在来把上面提到的twoNum当作一个函数参数来使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">numFun</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>,twoNum: (<span class="type">x</span>:<span class="type">Int</span>,y:<span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>):<span class="built_in">Int</span>&#123;</div><div class="line">    <span class="keyword">return</span> twoNum(a,b)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用起来也很简单，只需传入的函数满足twoNum的签名即可：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = numFun(<span class="number">1</span>,<span class="number">2</span>,sumLambda)</div></pre></td></tr></table></figure>
<p>上面说了输入，现在再来说说输出，Kotlin可以支持函数作为返回值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Function2是Kotlin中定义的一个接口</span></div><div class="line"><span class="comment">// public interface Function2&lt;in P1, in P2, out R&gt; : Function&lt;R&gt;</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: Function2&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>, <span class="built_in">Int</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> sumLambda</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当然Kotlin的特性远不止我上面说到的这些，还有拓展函数、null安全等等，而正是它的这些特性大大的提升了我们的开发效率和代码的安全性。现在，你看完上面这些有趣的特性之后，不想马上来试一下Kotlin嘛？</p>
<p>如果在阅读过程中，有任何疑问与问题，欢迎与我联系。<br><strong>博客:www.idtkm.com</strong><br><strong>GitHub:<a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><strong>微博:<a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><strong>邮箱:IdtkMa@gmail.com</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文并不准备去详细说明Kotlin的AS配置以及基本的语法，而是介绍一下在使用过程中让我惊喜的Kotlin特性，希望让更多的人喜欢上这个语言。&lt;/p&gt;
&lt;h2 id=&quot;和findViewById说再见&quot;&gt;&lt;a href=&quot;#和findViewById说再见&quot; class=&quot;headerlink&quot; title=&quot;和findViewById说再见&quot;&gt;&lt;/a&gt;和findViewById说再见&lt;/h2&gt;&lt;p&gt;第一个要说的应该是很多已经使用了kotlin的同学都体会到的特性。&lt;/p&gt;
&lt;p&gt;假设当前Activity对于的布局为如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;LinearLayout&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;xmlns:android&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;xmlns:tools&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://schemas.android.com/tools&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;@+id/activity_main&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:layout_width&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:layout_height&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:orientation&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;vertical&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;TextView&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;@+id/main_tv&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:layout_width&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:layout_height&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:text&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;Hello Java!&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;LinearLayout&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们一般会使用如下两个方法之一：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;findViewById(R.id.main_tv);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//or&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@BindView&lt;/span&gt;(R.id.main_tv)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Button mMainTv;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不过现在我们可以直接使用对应的id，并且import对应的文件：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;main_tv.text = &lt;span class=&quot;string&quot;&gt;&quot;Hello Kotlin!&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; kotlinx.android.synthetic.main.activity_main.*&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="Kotlin" scheme="http://www.idtkm.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit源码分析</title>
    <link href="http://www.idtkm.com/2017/04/27/Retrofit/"/>
    <id>http://www.idtkm.com/2017/04/27/Retrofit/</id>
    <published>2017-04-27T12:00:00.000Z</published>
    <updated>2017-10-15T16:00:27.180Z</updated>
    
    <content type="html"><![CDATA[<p>源码的分析将从基本的使用方法入手，分析retrofit的实现方案，以及其中涉及到的一些有趣的技巧。并且建议大家也去github下载一份源码，跟着本文理一遍基本的流程。</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="定义HTTP-API"><a href="#定义HTTP-API" class="headerlink" title="定义HTTP API"></a>定义HTTP API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</div><div class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</div><div class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="创建Retrofit并生成API的实现"><a href="#创建Retrofit并生成API的实现" class="headerlink" title="创建Retrofit并生成API的实现"></a>创建Retrofit并生成API的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</div><div class="line">    .build();</div><div class="line"></div><div class="line">GitHubService service = retrofit.create(GitHubService.class);</div></pre></td></tr></table></figure>
<h3 id="调用API方法，生成Call"><a href="#调用API方法，生成Call" class="headerlink" title="调用API方法，生成Call"></a>调用API方法，生成Call</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</div></pre></td></tr></table></figure>
<h2 id="Retrofit的创建"><a href="#Retrofit的创建" class="headerlink" title="Retrofit的创建"></a>Retrofit的创建</h2><p>retrofit实例的创建，使用了<span id="retrofit__build">builder</span>模式，从下面的源码中可以看出。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">	Builder(Platform platform) &#123;</div><div class="line">		<span class="keyword">this</span>.platform = platform;</div><div class="line">		converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// Platform.get()方法可以用于判断当前的环境</span></div><div class="line">		<span class="keyword">this</span>(Platform.get());</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> Builder <span class="title">baseUrl</span><span class="params">(String baseUrl)</span> </span>&#123;</div><div class="line">      checkNotNull(baseUrl, <span class="string">"baseUrl == null"</span>);</div><div class="line">      HttpUrl httpUrl = HttpUrl.parse(baseUrl);</div><div class="line">      <span class="keyword">if</span> (httpUrl == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal URL: "</span> + baseUrl);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> baseUrl(httpUrl);</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base URL required."</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</div><div class="line">      <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</div><div class="line">        callFactory = <span class="keyword">new</span> OkHttpClient();<span class="comment">// 新建Client，留到之后newCall什么的</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</div><div class="line">      <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</div><div class="line">        callbackExecutor = platform.defaultCallbackExecutor();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// Make a defensive copy of the adapters and add the default Call adapter.</span></div><div class="line">      List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.adapterFactories);</div><div class="line">      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</div><div class="line"></div><div class="line">      <span class="comment">// Make a defensive copy of the converters.</span></div><div class="line">      List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.converterFactories);</div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,</div><div class="line">          callbackExecutor, validateEagerly);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里除了builder模式以外，还有两个地方需要关注下，一个是<code>Platform.get()</code>方法。它通过<code>Class.forName</code>获取类名的方式，来判断当前的环境是否在Android中,这在之后获取默认的<code>CallAdapterFactory</code>时候将会用到,对这个方法感兴趣的可以跟过去查看下，这里就不贴了。另一个是在<code>build()</code>中创建了<code>OkHttpClient</code>。</p>
<h2 id="retrofit-create"><a href="#retrofit-create" class="headerlink" title="retrofit.create"></a>retrofit.create</h2><p>好玩的地方开始了，我们先来看看这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</div><div class="line">  Utils.validateServiceInterface(service);</div><div class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</div><div class="line">    eagerlyValidateMethods(service);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 动态代理，啦啦啦</span></div><div class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">        <span class="comment">// platform 可以分辨出你是在android，还是java8，又或者别的</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</div><div class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></div><div class="line">            <span class="keyword">throws</span> Throwable &#123;</div><div class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></div><div class="line">          <span class="comment">// 这里的invoke，Object方法都走这里，比如equals、toString、hashCode什么的</span></div><div class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// java8默认方法，1.8的新特性</span></div><div class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</div><div class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// 这里是核心代码了</span></div><div class="line">          ServiceMethod&lt;Object, Object&gt; serviceMethod =</div><div class="line">              (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</div><div class="line">          OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">          <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出创建API使用了动态代理，根据接口动态生成的代理类，将接口的都转发给了负责连接代理类和委托类的<code>InvocationHandler</code>实例，接口方法也都通过其<code>invoke</code>方法来处理。<br>在<code>invoke</code>方法中，首先会通过<code>Platform.get()</code>方法判断出当前代码的执行环境，之后会先把<code>Object</code>和Java8的默认方法进行一个处理，也是在进行后续处理之前进行去噪。其中的关键代码其实就是最后三句，这也是这篇文章将要分析的。</p>
<h3 id="创建ServiceMethod"><a href="#创建ServiceMethod" class="headerlink" title="创建ServiceMethod"></a>创建ServiceMethod</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</div><div class="line">  <span class="comment">// 从缓存里面取出，如果有的话，直接返回好了</span></div><div class="line">  ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</div><div class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</div><div class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</div><div class="line">    result = serviceMethodCache.get(method);</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// 为null的话，解析方法的注解和返回类型、参数的注解he参数类型，新建一个ServiceMethod</span></div><div class="line">      result = <span class="keyword">new</span> ServiceMethod.Builder&lt;&gt;(<span class="keyword">this</span>, method).build();<span class="comment">// -&gt;</span></div><div class="line">      <span class="comment">// 新建的ServiceMethod加到缓存列表里面</span></div><div class="line">      serviceMethodCache.put(method, result);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先会尝试根据方法从缓存中取出<code>ServiceMethod</code>实例，如果没有，在锁保护之后，还有再尝试一次，还是没有的情况下，才会去创建<code>ServiceMethod</code>。ServiceMethod的创建于Retrofit类似，都是<code>builder</code>模式。ServiceMethod创建的实际流程都放在了最后的<code>build()</code>方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">  callAdapter = createCallAdapter();<span class="comment">// -&gt;获取CallAdapter的实现，一般为ExecutorCallAdapterFactory.get实现</span></div><div class="line">  responseType = callAdapter.responseType();</div><div class="line">  <span class="keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</div><div class="line">    <span class="keyword">throw</span> methodError(<span class="string">"'"</span></div><div class="line">        + Utils.getRawType(responseType).getName()</div><div class="line">        + <span class="string">"' is not a valid response body type. Did you mean ResponseBody?"</span>);</div><div class="line">  &#125;</div><div class="line">  responseConverter = createResponseConverter();<span class="comment">// 响应的转换工厂，如GsonConverterFactory</span></div><div class="line">  <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</div><div class="line">    parseMethodAnnotation(annotation);<span class="comment">// 真正解析方法注解的地方来了</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (httpMethod == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> methodError(<span class="string">"HTTP method annotation is required (e.g., @GET, @POST, etc.)."</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (!hasBody) &#123;<span class="comment">// POST方法需要有body或者表单</span></div><div class="line">    <span class="keyword">if</span> (isMultipart) &#123;</div><div class="line">      <span class="keyword">throw</span> methodError(</div><div class="line">          <span class="string">"Multipart can only be specified on HTTP methods with request body (e.g., @POST)."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isFormEncoded) &#123;</div><div class="line">      <span class="keyword">throw</span> methodError(<span class="string">"FormUrlEncoded can only be specified on HTTP methods with "</span></div><div class="line">          + <span class="string">"request body (e.g., @POST)."</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 上面是请求方法，下面是请求参数</span></div><div class="line">  <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</div><div class="line">  <span class="comment">// ParameterHandler的实现类有很多，包括了各种参数，@Field、@Query等</span></div><div class="line">  parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</div><div class="line">    Type parameterType = parameterTypes[p];<span class="comment">// 参数类型</span></div><div class="line">    <span class="comment">// 和之前一样的泛型、通配符检查</span></div><div class="line">    <span class="keyword">if</span> (Utils.hasUnresolvableType(parameterType)) &#123;</div><div class="line">      <span class="keyword">throw</span> parameterError(p, <span class="string">"Parameter type must not include a type variable or wildcard: %s"</span>,</div><div class="line">          parameterType);</div><div class="line">    &#125;</div><div class="line">    Annotation[] parameterAnnotations = parameterAnnotationsArray[p];<span class="comment">// 参数的注解集合</span></div><div class="line">    <span class="keyword">if</span> (parameterAnnotations == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> parameterError(p, <span class="string">"No Retrofit annotation found."</span>);</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 生成了对应的参数注解ParameterHandler实例</span></div><div class="line">    parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 对方法的一些检测</span></div><div class="line">  ...</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到在build方法中，对<code>CallAdapter</code>与<code>Converter</code>进行了创建，这里跟踪之后将会回到<code>retrofit</code>类中，在其中将会获取对应列表中的第一个！null对象，之后将会对API的方法和参数注解进行解析。</p>
<h4 id="注解的解析"><a href="#注解的解析" class="headerlink" title="注解的解析"></a>注解的解析</h4><p><code>CallAdapter</code>和<code>Converter</code>等到后面再分析，这里先看看<code>parseMethodAnnotation(annotation)</code>，功能和其名字一样，其对方法注解进行了解析。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 解析方法注解，呜啦啦</div><div class="line"> * 通过判断注解类型来解析</div><div class="line"> * <span class="doctag">@param</span> annotation</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseMethodAnnotation</span><span class="params">(Annotation annotation)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> DELETE) &#123;</div><div class="line">    parseHttpMethodAndPath(<span class="string">"DELETE"</span>, ((DELETE) annotation).value(), <span class="keyword">false</span>);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> GET) &#123;</div><div class="line">    parseHttpMethodAndPath(<span class="string">"GET"</span>, ((GET) annotation).value(), <span class="keyword">false</span>);</div><div class="line">  &#125; </div><div class="line">  <span class="comment">// 其他的一些方法注解的解析</span></div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseHttpMethodAndPath</span><span class="params">(String httpMethod, String value, <span class="keyword">boolean</span> hasBody)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.httpMethod != <span class="keyword">null</span>) &#123;<span class="comment">// 已经赋值过了</span></div><div class="line">    <span class="keyword">throw</span> methodError(<span class="string">"Only one HTTP method is allowed. Found: %s and %s."</span>,</div><div class="line">        <span class="keyword">this</span>.httpMethod, httpMethod);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>.httpMethod = httpMethod;</div><div class="line">  <span class="keyword">this</span>.hasBody = hasBody;</div><div class="line">  <span class="comment">// value为设置注解方法时候，设置的值，官方例子中的users/&#123;user&#125;/repos or user</span></div><div class="line">  <span class="keyword">if</span> (value.isEmpty()) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 查询条件的一些判断</span></div><div class="line">    ...</div><div class="line">  <span class="keyword">this</span>.relativeUrl = value;</div><div class="line">  <span class="keyword">this</span>.relativeUrlParamNames = parsePathParameters(value);</div><div class="line">&#125;</div><div class="line">`</div></pre></td></tr></table></figure></p>
<p>在解析注解时，先通过<code>instanceof</code>判断出注解的类型，之后调用<code>parseHttpMethodAndPath</code>方法解析注解参数值，并设置<code>httpMethod、relativeUrl、relativeUrlParamNames</code>等属性。<br></p>
<p>上面说了API中方法注解的解析，现在来看看方法参数注解的解析，这是通过调用<code>parseParameterAnnotation</code>方法生成ParameterHandler实例来实现的，代码比较多，这里挑选@Query来看看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Query) &#123;</div><div class="line">Query query = (Query) annotation;</div><div class="line">String name = query.value();</div><div class="line"><span class="keyword">boolean</span> encoded = query.encoded();</div><div class="line"></div><div class="line">Class&lt;?&gt; rawParameterType = Utils.getRawType(type);<span class="comment">// 返回基础的类</span></div><div class="line">gotQuery = <span class="keyword">true</span>;</div><div class="line"><span class="comment">// 可以迭代，Collection</span></div><div class="line"><span class="keyword">if</span> (Iterable.class.isAssignableFrom(rawParameterType)) &#123;</div><div class="line">  <span class="keyword">if</span> (!(type <span class="keyword">instanceof</span> ParameterizedType)) &#123;</div><div class="line">	<span class="keyword">throw</span> parameterError(p, rawParameterType.getSimpleName()</div><div class="line">		+ <span class="string">" must include generic type (e.g., "</span></div><div class="line">		+ rawParameterType.getSimpleName()</div><div class="line">		+ <span class="string">"&lt;String&gt;)"</span>);</div><div class="line">  &#125;</div><div class="line">  ParameterizedType parameterizedType = (ParameterizedType) type;</div><div class="line">  Type iterableType = Utils.getParameterUpperBound(<span class="number">0</span>, parameterizedType);<span class="comment">// 返回基本类型</span></div><div class="line">  Converter&lt;?, String&gt; converter =</div><div class="line">	  retrofit.stringConverter(iterableType, annotations);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ParameterHandler.Query&lt;&gt;(name, converter, encoded).iterable();</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rawParameterType.isArray()) &#123;<span class="comment">// Array</span></div><div class="line">  Class&lt;?&gt; arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());<span class="comment">// 如果是基本类型，自动装箱</span></div><div class="line">  Converter&lt;?, String&gt; converter =</div><div class="line">	  retrofit.stringConverter(arrayComponentType, annotations);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ParameterHandler.Query&lt;&gt;(name, converter, encoded).array();</div><div class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// Other</span></div><div class="line">  Converter&lt;?, String&gt; converter =</div><div class="line">	  retrofit.stringConverter(type, annotations);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ParameterHandler.Query&lt;&gt;(name, converter, encoded);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在@Query中，将分成Collection、array、other三种情况处理参数，之后根据这些参数，调用ParameterHandler中的Query静态类，创建出一个ParameterHandler实例。这样循环直到解析了所有的参数注解，组合成为全局变量<span id="parameterHandlers">parameterHandlers</span>，之后构建请求时会用到。</p>
<h3 id="OkHttpCall"><a href="#OkHttpCall" class="headerlink" title="OkHttpCall"></a>OkHttpCall</h3><p><code>ServiceMethod</code>创建完成之后，我们来看看下一行代码中的<code>OkHttpCall</code>类，里面的包含了请求的执行和响应处理，我们来看看异步请求的做法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, Object[] args) &#123;</div><div class="line">  <span class="keyword">this</span>.serviceMethod = serviceMethod;</div><div class="line">  <span class="keyword">this</span>.args = args;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</div><div class="line">checkNotNull(callback, <span class="string">"callback == null"</span>);</div><div class="line"></div><div class="line">okhttp3.Call call;</div><div class="line">Throwable failure;</div><div class="line"></div><div class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</div><div class="line">  executed = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">  call = rawCall;</div><div class="line">  failure = creationFailure;</div><div class="line">  <span class="keyword">if</span> (call == <span class="keyword">null</span> &amp;&amp; failure == <span class="keyword">null</span>) &#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">	  call = rawCall = createRawCall();<span class="comment">// 创建OkHttp3.Call</span></div><div class="line">	&#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">	  failure = creationFailure = t;</div><div class="line">	&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (failure != <span class="keyword">null</span>) &#123;</div><div class="line">  callback.onFailure(<span class="keyword">this</span>, failure);</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (canceled) &#123;</div><div class="line">  call.cancel();</div><div class="line">&#125;</div><div class="line"></div><div class="line">call.enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span></span></div><div class="line">	  <span class="keyword">throws</span> IOException &#123;</div><div class="line">	Response&lt;T&gt; response;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">	  response = parseResponse(rawResponse);<span class="comment">// -&gt;</span></div><div class="line">	&#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">	  callFailure(e);</div><div class="line">	  <span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	callSuccess(response);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">	  callback.onFailure(OkHttpCall.<span class="keyword">this</span>, e);</div><div class="line">	&#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">	  t.printStackTrace();</div><div class="line">	&#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailure</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">	  callback.onFailure(OkHttpCall.<span class="keyword">this</span>, e);</div><div class="line">	&#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">	  t.printStackTrace();</div><div class="line">	&#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callSuccess</span><span class="params">(Response&lt;T&gt; response)</span> </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">	  callback.onResponse(OkHttpCall.<span class="keyword">this</span>, response);</div><div class="line">	&#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">	  t.printStackTrace();</div><div class="line">	&#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span> okhttp3.<span class="function">Call <span class="title">createRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  Request request = serviceMethod.toRequest(args);<span class="comment">// 根据ParameterHandler组装Request.Builder，生成Request</span></div><div class="line">  okhttp3.Call call = serviceMethod.callFactory.newCall(request);<span class="comment">// Retrofit中创建的new OkHttpClient().newCall(request)</span></div><div class="line">  ...</div><div class="line">  <span class="keyword">return</span> call;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先在构造函数中传入了之前新建的<code>serviceMethod</code>和动态代理<code>invoke</code>方法传递来的<code>args</code>参数。我们来看看其异步方法<code>enqueue</code>，将会调用<code>createRawCall()</code>方法，跟进来可以看到，做了两件事情，第一件事情，调用<code>serviceMethod.toRequest</code>方法，创造出一个<code>Request</code>对象，这个<code>Request</code>对象就是根据之前提到的方法参数注解的集合<a href="#parameterHandlers"><code>parameterHandlers</code></a>创建的。第二件事是创建一个<code>okhttp3.Call</code>对象，我们都知道Okhttp中创建这个对象的方法就是newCall，这和上面的代码如出一辙，那么<code>callFactory</code>参数是不是就是<code>OkHttpClient</code>呢？bingo！确实如此，稍微跟踪一下就可以发现，它的创建出现在<a href="#retrofit__build"><code>Retrofit.Builder.build()</code></a>方法中，而参数就使用刚刚创建的<code>request</code>对象，构成<code>okhttp3.Call</code>，并返回。<br></p>
<h3 id="CallAdapter"><a href="#CallAdapter" class="headerlink" title="CallAdapter"></a>CallAdapter</h3><p>现在来看看<code>enqueue</code>传入的参数<code>callback</code>,这个参数可能和很多人心中想的并不一样，它并不是用户在使用时传入的那个<code>Callback</code>对象。那么他是从哪里来的呢？不知道你还记不记得我之前在<a href="#retrofit__build"><code>Retrofit.Builder.build()</code></a>方法中提到过一句代码<code>Platform.get()</code>。在不使用<code>addCallAdapterFactory</code>的情况下。将会使用<code>Platform</code>的一种内部类，在Android环境下将会使用到<code>Android</code>类（这其实是个策略模式）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</div><div class="line">  &#125;</div><div class="line">  <span class="meta">@Override</span> CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(Executor callbackExecutor)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">	<span class="comment">// Looper.getMainLooper()就是为嘛响应会在主线程的原因</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">      handler.post(r);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码先稍微放一下，我们继续看<code>retrofit.Bulider.build</code>,其中有几句比较关键的代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">callFactory = <span class="keyword">new</span> OkHttpClient();</div><div class="line">callbackExecutor = platform.defaultCallbackExecutor();</div><div class="line">adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</div></pre></td></tr></table></figure></p>
<p>结合<code>Android</code>类中的代码可以看出，其最后生成了<code>ExecutorCallAdapterFactory</code>类。虽然看到了<code>CallAdapter.Factory</code>，但是到底是哪里执行了<code>enqueue</code>方法呢？现在我们来看看<code>retrofit.create</code>的最后一句代码<code>serviceMethod.callAdapter.adapt(okHttpCall)</code>。<br><br></p>
<p>这里的<code>callAdapter</code>在不使用<code>addCallAdapterFactory</code>的Android环境中，就是上面我们说到<code>new ExecutorCallAdapterFactory</code>中get方法返回的对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class="line">  <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">final</span> Type responseType = Utils.getCallResponseType(returnType);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> responseType;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;<span class="comment">// Retrofit动态代理serviceMethod.callAdapter.adapt(okHttpCall);调用到这里</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>responseType</code>方法返回的对象之后会在<code>Converter</code>中用到，不过接下来先继续看看其调用<code>adapter</code>方法生成的<code>ExecutorCallbackCall</code>对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</div><div class="line">  <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</div><div class="line">  <span class="keyword">this</span>.delegate = delegate;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</div><div class="line">  checkNotNull(callback, <span class="string">"callback == null"</span>);</div><div class="line">  delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</div><div class="line">      callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">          <span class="keyword">if</span> (delegate.isCanceled()) &#123;</div><div class="line">            <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.</span></div><div class="line">            callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</div><div class="line">      callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">          callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, t);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的参数<code>callback</code>才是用户输入的回调对象，而其中的<code>delegate</code>就是之前的<code>okhttpCall</code>。所以<code>delegate.enqueue</code>就是调用了<code>OkhttpCall.enqueue</code>，而其中的<code>callbackExecutor</code>就是刚刚的主线程。<br><br></p>
<p>顺便再来看看常用的RxJava2CallAdapter，这里直接从<code>RxJava2CallAdapter.adapter</code>方法开始<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</div><div class="line">  Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync</div><div class="line">      ? <span class="keyword">new</span> CallEnqueueObservable&lt;&gt;(call)</div><div class="line">      : <span class="keyword">new</span> CallExecuteObservable&lt;&gt;(call);</div><div class="line">  Observable&lt;?&gt; observable;</div><div class="line">  <span class="keyword">if</span> (isResult) &#123;</div><div class="line">    observable = <span class="keyword">new</span> ResultObservable&lt;&gt;(responseObservable);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBody) &#123;</div><div class="line">    observable = <span class="keyword">new</span> BodyObservable&lt;&gt;(responseObservable);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    observable = responseObservable;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (scheduler != <span class="keyword">null</span>) &#123;</div><div class="line">    observable = observable.subscribeOn(scheduler);</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">  <span class="keyword">return</span> observable;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>adapter最终创建了Observable，主我们这里分析其中开头的两步来：</p>
<ul>
<li>分异步和同步请求创建responseObservable</li>
<li>根据返回的类型创建observable</li>
</ul>
<p>这里以异步为例，看看<code>CallEnqueueObservable</code>类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallEnqueueObservable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">Response</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Call&lt;T&gt; originalCall;</div><div class="line"></div><div class="line">  CallEnqueueObservable(Call&lt;T&gt; originalCall) &#123;</div><div class="line">    <span class="keyword">this</span>.originalCall = originalCall;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> Response&lt;T&gt;&gt; observer)</span> </span>&#123;</div><div class="line">    <span class="comment">// Since Call is a one-shot type, clone it for each new observer.</span></div><div class="line">    Call&lt;T&gt; call = originalCall.clone();</div><div class="line">    CallCallback&lt;T&gt; callback = <span class="keyword">new</span> CallCallback&lt;&gt;(call, observer);</div><div class="line">    observer.onSubscribe(callback);</div><div class="line">    call.enqueue(callback);<span class="comment">// 这里执行了enqueue</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallCallback</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Disposable</span>, <span class="title">Callback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Call&lt;?&gt; call;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> Response&lt;T&gt;&gt; observer;</div><div class="line">    <span class="keyword">boolean</span> terminated = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    CallCallback(Call&lt;?&gt; call, Observer&lt;? <span class="keyword">super</span> Response&lt;T&gt;&gt; observer) &#123;</div><div class="line">      <span class="keyword">this</span>.call = call;</div><div class="line">      <span class="keyword">this</span>.observer = observer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, Response&lt;T&gt; response)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        observer.onNext(response);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!call.isCanceled()) &#123;</div><div class="line">          terminated = <span class="keyword">true</span>;</div><div class="line">          observer.onComplete();</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, Throwable t)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        observer.onError(t);</div><div class="line">      &#125; <span class="keyword">catch</span> (Throwable inner) &#123;</div><div class="line">        Exceptions.throwIfFatal(inner);</div><div class="line">        RxJavaPlugins.onError(<span class="keyword">new</span> CompositeException(t, inner));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>subscribeActual</code>方法内，主要做了三件事情：</p>
<ul>
<li>clone了原有的call，因为OkHttp.Call只能使用一次</li>
<li>设置了onSubscribe，可用于解除订阅</li>
<li>执行了enqueue请求</li>
</ul>
<p><br></p>
<p>再看看第二步，这里以<code>BodyObservable</code>为例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BodyObservable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Observable&lt;Response&lt;T&gt;&gt; upstream;</div><div class="line"></div><div class="line">  BodyObservable(Observable&lt;Response&lt;T&gt;&gt; upstream) &#123;</div><div class="line">    <span class="keyword">this</span>.upstream = upstream;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</div><div class="line">    upstream.subscribe(<span class="keyword">new</span> BodyObserver&lt;T&gt;(observer));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BodyObserver</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">Response</span>&lt;<span class="title">R</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> R&gt; observer;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> terminated;</div><div class="line"></div><div class="line">    BodyObserver(Observer&lt;? <span class="keyword">super</span> R&gt; observer) &#123;</div><div class="line">      <span class="keyword">this</span>.observer = observer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable disposable)</span> </span>&#123;</div><div class="line">      observer.onSubscribe(disposable);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Response&lt;R&gt; response)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (response.isSuccessful()) &#123;</div><div class="line">        observer.onNext(response.body());</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">		...</div><div class="line">          observer.onError(t);</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (!terminated) &#123;</div><div class="line">        observer.onComplete();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (!terminated) &#123;</div><div class="line">        observer.onError(throwable);</div><div class="line">      &#125; </div><div class="line">	  ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码中的<code>subscribeActual</code>方法在<code>subscribe</code>之后执行，自然<code>responseObservable</code>就订阅了<code>BodyObserver</code>，所以上面<code>CallEnqueueObservable</code>中的<code>CallCallback.onResponse</code>内，调用<code>observer.onNext</code>也就是<code>BodyObserver.onNext</code>,最后刚开始的观察着就收到了<code>response.body()</code>。<br></p>
<h3 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h3><p>现在回到OkhttpCall.enqueue方法中，在其中还有一句重要的代码没有看，那就是<code>response = parseResponse(rawResponse);</code>,我们来看看这其中做了什么。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException</div><div class="line">  ResponseBody rawBody = rawResponse.body();</div><div class="line">  // Remove the body's source (the only stateful object) so we can pass th</div><div class="line">  rawResponse = rawResponse.newBuilder()</div><div class="line">      .body(new NoContentResponseBody(rawBody.contentType(), rawBody.conte</div><div class="line">      .build();</div><div class="line">  ...</div><div class="line">  ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);</div><div class="line">  try &#123;</div><div class="line">    T body = serviceMethod.toResponse(catchingBody);// 解析body，比如Gson解析</div><div class="line">    return Response.success(body, rawResponse);</div><div class="line">  &#125; catch (RuntimeException e) &#123;</div><div class="line">    // If the underlying source threw an exception, propagate that rather </div><div class="line">    // a runtime exception.</div><div class="line">    catchingBody.throwIfCaught();</div><div class="line">    throw e;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">### ServiceMethod</div><div class="line">R toResponse(ResponseBody body) throws IOException &#123;</div><div class="line">  return responseConverter.convert(body);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出parseResponse最终调用了<code>Converter.convert</code>方法。这里以常用的GsonConverterFactory为例。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># GsonConverterFactory</div><div class="line">@Override</div><div class="line">public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,</div><div class="line">    Retrofit retrofit) &#123;</div><div class="line">  TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</div><div class="line">  return new GsonResponseBodyConverter&lt;&gt;(gson, adapter);</div><div class="line">&#125;</div><div class="line"></div><div class="line"># GsonResponseBodyConverter</div><div class="line">final class GsonResponseBodyConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; &#123;</div><div class="line">  private final Gson gson;</div><div class="line">  private final TypeAdapter&lt;T&gt; adapter;</div><div class="line">  GsonResponseBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123;</div><div class="line">    this.gson = gson;</div><div class="line">    this.adapter = adapter;</div><div class="line">  &#125;</div><div class="line">  @Override public T convert(ResponseBody value) throws IOException &#123;</div><div class="line">    JsonReader jsonReader = gson.newJsonReader(value.charStream());</div><div class="line">    try &#123;</div><div class="line">      return adapter.read(jsonReader);</div><div class="line">    &#125; finally &#123;</div><div class="line">      value.close();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>responseBodyConverter</code>方法中用到的type参数就是之前我在CallAdapter中提到的<code>responseType</code>方法的返回值。生成adapter方法，用于<code>convert</code>方法使用。OkHttpCall在这之后的代码就比较简单了，通过回调将转换后得响应数据发送出去即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分析了Retrofit的执行流程，其实包含了Retrofit、ServiceMethod、OkHttpCall、CallAdapter、Converter等方面。Retrofit的代码相对是比较少，也比较容易理解的，不过却是很好的架构实例。<br></p>
<p><a href="https://github.com/Idtk/CodeDaily/tree/master/retrofit" target="_blank" rel="external">如果想看retrofit中其他一些代码的注释，请点击这里，如果其中发现不合适的描述，欢迎指出</a><br></p>
<p>如果在阅读过程中，有任何疑问与问题，欢迎与我联系。<br><br><strong>博客:www.idtkm.com</strong><br><br><strong>GitHub:<a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><br><strong>微博:<a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><br><strong>邮箱:IdtkMa@gmail.com</strong><br><br><br></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="external">Retrofit分析-漂亮的解耦套路</a><br><br><a href="http://static.blog.piasy.com/2016/06/25/Understand-Retrofit/" target="_blank" rel="external">拆轮子系列：拆 Retrofit</a><br><br><a href="https://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;源码的分析将从基本的使用方法入手，分析retrofit的实现方案，以及其中涉及到的一些有趣的技巧。并且建议大家也去github下载一份源码，跟着本文理一遍基本的流程。&lt;/p&gt;
&lt;h2 id=&quot;简单使用&quot;&gt;&lt;a href=&quot;#简单使用&quot; class=&quot;headerlink&quot; title=&quot;简单使用&quot;&gt;&lt;/a&gt;简单使用&lt;/h2&gt;&lt;h3 id=&quot;定义HTTP-API&quot;&gt;&lt;a href=&quot;#定义HTTP-API&quot; class=&quot;headerlink&quot; title=&quot;定义HTTP API&quot;&gt;&lt;/a&gt;定义HTTP API&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GitHubService&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@GET&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;users/&amp;#123;user&amp;#125;/repos&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Call&amp;lt;List&amp;lt;Repo&amp;gt;&amp;gt; listRepos(&lt;span class=&quot;meta&quot;&gt;@Path&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;user&quot;&lt;/span&gt;) String user);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;创建Retrofit并生成API的实现&quot;&gt;&lt;a href=&quot;#创建Retrofit并生成API的实现&quot; class=&quot;headerlink&quot; title=&quot;创建Retrofit并生成API的实现&quot;&gt;&lt;/a&gt;创建Retrofit并生成API的实现&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Retrofit retrofit = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Retrofit.Builder()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .baseUrl(&lt;span class=&quot;string&quot;&gt;&quot;https://api.github.com/&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .build();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GitHubService service = retrofit.create(GitHubService.class);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;调用API方法，生成Call&quot;&gt;&lt;a href=&quot;#调用API方法，生成Call&quot; class=&quot;headerlink&quot; title=&quot;调用API方法，生成Call&quot;&gt;&lt;/a&gt;调用API方法，生成Call&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Call&amp;lt;List&amp;lt;Repo&amp;gt;&amp;gt; repos = service.listRepos(&lt;span class=&quot;string&quot;&gt;&quot;octocat&quot;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Retrofit的创建&quot;&gt;&lt;a href=&quot;#Retrofit的创建&quot; class=&quot;headerlink&quot; title=&quot;Retrofit的创建&quot;&gt;&lt;/a&gt;Retrofit的创建&lt;/h2&gt;&lt;p&gt;retrofit实例的创建，使用了&lt;span id=&quot;retrofit__build&quot;&gt;builder&lt;/span&gt;模式，从下面的源码中可以看出。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="Source Analysis" scheme="http://www.idtkm.com/tags/Source-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView缓存分析</title>
    <link href="http://www.idtkm.com/2017/04/20/RecyclerView.Recycler/"/>
    <id>http://www.idtkm.com/2017/04/20/RecyclerView.Recycler/</id>
    <published>2017-04-19T16:00:00.000Z</published>
    <updated>2017-10-15T16:00:33.542Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;本文将对RecyclerView的缓存机制进行分析。源码基于recyclerview-v7-25</p>
<h1 id="缓存介绍"><a href="#缓存介绍" class="headerlink" title="缓存介绍"></a>缓存介绍</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Recycler</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mAttachedScrap = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        ArrayList&lt;ViewHolder&gt; mChangedScrap = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mCachedViews = <span class="keyword">new</span> ArrayList&lt;ViewHolder&gt;();</div><div class="line">		<span class="comment">// mAttachedScrap的不可变视图</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ViewHolder&gt;</div><div class="line">                mUnmodifiableAttachedScrap = Collections.unmodifiableList(mAttachedScrap);</div><div class="line">		<span class="comment">// 预缓存数，设置后会相应更新mViewCacheMax的值</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> mRequestedCacheMax = DEFAULT_CACHE_SIZE;</div><div class="line">		<span class="comment">// 最大缓存数</span></div><div class="line">        <span class="keyword">int</span> mViewCacheMax = DEFAULT_CACHE_SIZE;</div><div class="line"></div><div class="line">        RecycledViewPool mRecyclerPool;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> ViewCacheExtension mViewCacheExtension;</div><div class="line"></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CACHE_SIZE = <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RecyclerView拥有三级缓存(算上mAdapter.createViewHolder的话其实就有四级了)，我们先看下各个缓存变量的用处。之后会分析RecyclerView是如何使用这些缓存的。</p>
<a id="more"></a>
<table style="border-collapse:collapse border-width:thin border-style:solid border-color:black"><tr><th>变量</th><th>作用</th></tr><tr><td>mAttachedScrap</td><td>未与RecyclerView分离的ViewHolder列表(即一级缓存)</td></tr><tr><td>mChangedScrap</td><td>RecyclerView中需要改变的ViewHolder列表(即一级缓存)</td></tr><tr><td>mCachedViews</td><td>RecyclerView的ViewHolder缓存列表(即一级缓存)</td></tr><tr><td>mViewCacheExtension</td><td>用户设置的RecyclerView的ViewHolder缓存列表扩展(即二级缓存)</td></tr><tr><td>mRecyclerPool</td><td>RecyclerView的ViewHolder缓存池(即三级缓存)</td></tr></table>

<h1 id="获取缓存"><a href="#获取缓存" class="headerlink" title="获取缓存"></a>获取缓存</h1><p>对于多级缓存的使用我们来看下<code>tryGetViewHolderForPositionByDeadline</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line"><span class="function">ViewHolder <span class="title">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="keyword">int</span> position,</span></span></div><div class="line">                                                              <span class="keyword">boolean</span> dryRun, <span class="keyword">long</span> deadlineNs) &#123;</div><div class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= mState.getItemCount()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Invalid item position "</span> + position</div><div class="line">                + <span class="string">"("</span> + position + <span class="string">"). Item count:"</span> + mState.getItemCount());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">boolean</span> fromScrapOrHiddenOrCache = <span class="keyword">false</span>;</div><div class="line">    ViewHolder holder = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 0) If there is a changed scrap, try to find from there</span></div><div class="line">    <span class="keyword">if</span> (mState.isPreLayout()) &#123;</div><div class="line">        <span class="comment">// 从mChangedScrap中获取ViewHolder</span></div><div class="line">        holder = getChangedScrapViewForPosition(position);</div><div class="line">        fromScrapOrHiddenOrCache = holder != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 1) Find by position from scrap/hidden list/cache</span></div><div class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 从mAttachedScrap 与 mCachedViews中获取ViewHolder</span></div><div class="line">        holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</div><div class="line">        <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (!validateViewHolderForOffsetPosition(holder)) &#123;</div><div class="line">                <span class="comment">// recycle holder (and unscrap if relevant) since it can't be used</span></div><div class="line">                <span class="keyword">if</span> (!dryRun) &#123;</div><div class="line">                    <span class="comment">// we would like to recycle this but need to make sure it is not used by</span></div><div class="line">                    <span class="comment">// animation logic etc.</span></div><div class="line">                    <span class="comment">// FLAG_INVALID 回收标记</span></div><div class="line">                    holder.addFlags(ViewHolder.FLAG_INVALID);</div><div class="line">                    <span class="keyword">if</span> (holder.isScrap()) &#123;</div><div class="line">                        removeDetachedView(holder.itemView, <span class="keyword">false</span>);</div><div class="line">                        holder.unScrap();</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (holder.wasReturnedFromScrap()) &#123;</div><div class="line">                        holder.clearReturnedFromScrapFlag();</div><div class="line">                    &#125;</div><div class="line">                    recycleViewHolderInternal(holder);</div><div class="line">                &#125;</div><div class="line">                holder = <span class="keyword">null</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                fromScrapOrHiddenOrCache = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);</div><div class="line">        <span class="keyword">if</span> (offsetPosition &lt; <span class="number">0</span> || offsetPosition &gt;= mAdapter.getItemCount()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Inconsistency detected. Invalid item "</span></div><div class="line">                    + <span class="string">"position "</span> + position + <span class="string">"(offset:"</span> + offsetPosition + <span class="string">")."</span></div><div class="line">                    + <span class="string">"state:"</span> + mState.getItemCount());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> type = mAdapter.getItemViewType(offsetPosition);</div><div class="line">        <span class="comment">// 2) Find from scrap/cache via stable ids, if exists</span></div><div class="line">        <span class="keyword">if</span> (mAdapter.hasStableIds()) &#123;</div><div class="line">            <span class="comment">// 通过id查找ViewHolder</span></div><div class="line">            holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</div><div class="line">                    type, dryRun);</div><div class="line">            <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// update position</span></div><div class="line">                holder.mPosition = offsetPosition;</div><div class="line">                fromScrapOrHiddenOrCache = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span> &amp;&amp; mViewCacheExtension != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// We are NOT sending the offsetPosition because LayoutManager does not</span></div><div class="line">            <span class="comment">// know it.</span></div><div class="line">            <span class="comment">// 如果使用者定义了mViewCacheExtension，则从中开始查找ViewHolder</span></div><div class="line">            <span class="keyword">final</span> View view = mViewCacheExtension</div><div class="line">                    .getViewForPositionAndType(<span class="keyword">this</span>, position, type);</div><div class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">                holder = getChildViewHolder(view);</div><div class="line">                <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"getViewForPositionAndType returned"</span></div><div class="line">                            + <span class="string">" a view which does not have a ViewHolder"</span>);</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (holder.shouldIgnore()) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"getViewForPositionAndType returned"</span></div><div class="line">                            + <span class="string">" a view that is ignored. You must call stopIgnoring before"</span></div><div class="line">                            + <span class="string">" returning this view."</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123; <span class="comment">// fallback to pool</span></div><div class="line">            <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">                Log.d(TAG, <span class="string">"tryGetViewHolderForPositionByDeadline("</span></div><div class="line">                        + position + <span class="string">") fetching from shared pool"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 从mRecycledViewPool中查找</span></div><div class="line">            holder = getRecycledViewPool().getRecycledView(type);</div><div class="line">            <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</div><div class="line">                holder.resetInternal();</div><div class="line">                <span class="keyword">if</span> (FORCE_INVALIDATE_DISPLAY_LIST) &#123;</div><div class="line">                    invalidateDisplayListInt(holder);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">long</span> start = getNanoTime();</div><div class="line">            <span class="keyword">if</span> (deadlineNs != FOREVER_NS</div><div class="line">                    &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123;</div><div class="line">                <span class="comment">// abort - we have a deadline we can't meet</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 上面那么多缓存都没找到的话，就创建一个</span></div><div class="line">            holder = mAdapter.createViewHolder(<span class="keyword">this</span>, type);</div><div class="line">            <span class="keyword">if</span> (ALLOW_THREAD_GAP_WORK) &#123;</div><div class="line">                <span class="comment">// only bother finding nested RV if prefetching</span></div><div class="line">                RecyclerView innerView = findNestedRecyclerView(holder.itemView);</div><div class="line">                <span class="keyword">if</span> (innerView != <span class="keyword">null</span>) &#123;</div><div class="line">                    holder.mNestedRecyclerView = <span class="keyword">new</span> WeakReference&lt;&gt;(innerView);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">long</span> end = getNanoTime();</div><div class="line">            mRecyclerPool.factorInCreateTime(type, end - start);</div><div class="line">            <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">                Log.d(TAG, <span class="string">"tryGetViewHolderForPositionByDeadline created new ViewHolder"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// This is very ugly but the only place we can grab this information</span></div><div class="line">    <span class="comment">// before the View is rebound and returned to the LayoutManager for post layout ops.</span></div><div class="line">    <span class="comment">// We don't need this in pre-layout since the VH is not updated by the LM.</span></div><div class="line">    <span class="keyword">if</span> (fromScrapOrHiddenOrCache &amp;&amp; !mState.isPreLayout() &amp;&amp; holder</div><div class="line">            .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST)) &#123;</div><div class="line">        holder.setFlags(<span class="number">0</span>, ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</div><div class="line">        <span class="keyword">if</span> (mState.mRunSimpleAnimations) &#123;</div><div class="line">            <span class="keyword">int</span> changeFlags = ItemAnimator</div><div class="line">                    .buildAdapterChangeFlagsForAnimations(holder);</div><div class="line">            changeFlags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;</div><div class="line">            <span class="keyword">final</span> ItemAnimator.ItemHolderInfo info = mItemAnimator.recordPreLayoutInformation(mState,</div><div class="line">                    holder, changeFlags, holder.getUnmodifiedPayloads());</div><div class="line">            recordAnimationInfoIfBouncedHiddenView(holder, info);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">boolean</span> bound = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</div><div class="line">        <span class="comment">// do not update unless we absolutely have to.</span></div><div class="line">        holder.mPreLayoutPosition = position;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</div><div class="line">        <span class="keyword">if</span> (DEBUG &amp;&amp; holder.isRemoved()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Removed holder should be bound and it should"</span></div><div class="line">                    + <span class="string">" come here only in pre-layout. Holder: "</span> + holder);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);</div><div class="line">        <span class="comment">// 调用mAdapter.bindViewHolder绑定ViewHolder</span></div><div class="line">        bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams();</div><div class="line">    <span class="keyword">final</span> LayoutParams rvLayoutParams;</div><div class="line">    <span class="keyword">if</span> (lp == <span class="keyword">null</span>) &#123;</div><div class="line">        rvLayoutParams = (LayoutParams) generateDefaultLayoutParams();</div><div class="line">        holder.itemView.setLayoutParams(rvLayoutParams);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!checkLayoutParams(lp)) &#123;</div><div class="line">        rvLayoutParams = (LayoutParams) generateLayoutParams(lp);</div><div class="line">        holder.itemView.setLayoutParams(rvLayoutParams);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        rvLayoutParams = (LayoutParams) lp;</div><div class="line">    &#125;</div><div class="line">    rvLayoutParams.mViewHolder = holder;</div><div class="line">    rvLayoutParams.mPendingInvalidate = fromScrapOrHiddenOrCache &amp;&amp; bound;</div><div class="line">    <span class="keyword">return</span> holder;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了方便理解代码逻辑，画了个流程图如下所示：<br></p>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/recycler/recycler%E8%8E%B7%E5%8F%96.png" title="缓存获取" width="300"><br></p>
<h1 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h1><p>现在来看看RecycledViewPool的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RecycledViewPool</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_SCRAP = <span class="number">5</span>;</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ScrapData</span> </span>&#123;</div><div class="line">    ArrayList&lt;ViewHolder&gt; mScrapHeap = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">int</span> mMaxScrap = DEFAULT_MAX_SCRAP;</div><div class="line">    <span class="keyword">long</span> mCreateRunningAverageNs = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> mBindRunningAverageNs = <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	SparseArray&lt;ScrapData&gt; mScrap = <span class="keyword">new</span> SparseArray&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 从缓存池获取一个ViewHolder，并从缓存池中删除</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> ViewHolder <span class="title">getRecycledView</span><span class="params">(<span class="keyword">int</span> viewType)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> ScrapData scrapData = mScrap.get(viewType);</div><div class="line">        <span class="keyword">if</span> (scrapData != <span class="keyword">null</span> &amp;&amp; !scrapData.mScrapHeap.isEmpty()) &#123;</div><div class="line">            <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; scrapHeap = scrapData.mScrapHeap;</div><div class="line">            <span class="keyword">return</span> scrapHeap.remove(scrapHeap.size() - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * viewType对应的中ScrapData添加ViewHolder</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putRecycledView</span><span class="params">(ViewHolder scrap)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> viewType = scrap.getItemViewType();</div><div class="line">        <span class="keyword">final</span> ArrayList scrapHeap = getScrapDataForType(viewType).mScrapHeap;</div><div class="line">        <span class="keyword">if</span> (mScrap.get(viewType).mMaxScrap &lt;= scrapHeap.size()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (DEBUG &amp;&amp; scrapHeap.contains(scrap)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"this scrap item already exists"</span>);</div><div class="line">        &#125;</div><div class="line">        scrap.resetInternal();</div><div class="line">        scrapHeap.add(scrap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 根据viewType获取ScrapData</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> ScrapData <span class="title">getScrapDataForType</span><span class="params">(<span class="keyword">int</span> viewType)</span> </span>&#123;</div><div class="line">        ScrapData scrapData = mScrap.get(viewType);</div><div class="line">        <span class="keyword">if</span> (scrapData == <span class="keyword">null</span>) &#123;</div><div class="line">            scrapData = <span class="keyword">new</span> ScrapData();</div><div class="line">            mScrap.put(viewType, scrapData);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> scrapData;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RecycledViewPool是由SparseArray实现，其中包含了多个viewType对应的ArrayList集合。获取时通过viewType得到对应的ArrayList集合，之后返回一个ViewHolder，并在集合中删除这个ViewHolder。添加操作也是类似，只不过在发现没有viewType对应的ArrayList集合时，将进行创建，并且在比较大小不超过默认大小5时，添加进入ArrayList。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文分析了RecyclerView的缓存实现，其通过多级缓存的方式实现了ViewHolder的重用，减少了ViewHolder创建，提升了效率。如果在阅读过程中，有任何疑问与问题，欢迎与我联系。<br></p>
<p><strong>博客:www.idtkm.com</strong><br><br><strong>GitHub:<a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><br><strong>微博:<a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><br><strong>邮箱:IdtkMa@gmail.com</strong><br><br><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本文将对RecyclerView的缓存机制进行分析。源码基于recyclerview-v7-25&lt;/p&gt;
&lt;h1 id=&quot;缓存介绍&quot;&gt;&lt;a href=&quot;#缓存介绍&quot; class=&quot;headerlink&quot; title=&quot;缓存介绍&quot;&gt;&lt;/a&gt;缓存介绍&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Recycler&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; ArrayList&amp;lt;ViewHolder&amp;gt; mAttachedScrap = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ArrayList&amp;lt;ViewHolder&amp;gt; mChangedScrap = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; ArrayList&amp;lt;ViewHolder&amp;gt; mCachedViews = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;ViewHolder&amp;gt;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// mAttachedScrap的不可变视图&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; List&amp;lt;ViewHolder&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                mUnmodifiableAttachedScrap = Collections.unmodifiableList(mAttachedScrap);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// 预缓存数，设置后会相应更新mViewCacheMax的值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mRequestedCacheMax = DEFAULT_CACHE_SIZE;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// 最大缓存数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mViewCacheMax = DEFAULT_CACHE_SIZE;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        RecycledViewPool mRecyclerPool;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; ViewCacheExtension mViewCacheExtension;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; DEFAULT_CACHE_SIZE = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;RecyclerView拥有三级缓存(算上mAdapter.createViewHolder的话其实就有四级了)，我们先看下各个缓存变量的用处。之后会分析RecyclerView是如何使用这些缓存的。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="RecyclerView" scheme="http://www.idtkm.com/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>自定义九宫格控件（附源码地址）</title>
    <link href="http://www.idtkm.com/2017/03/19/NinePhotoView/"/>
    <id>http://www.idtkm.com/2017/03/19/NinePhotoView/</id>
    <published>2017-03-19T12:48:00.000Z</published>
    <updated>2017-10-15T16:00:45.865Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;在阅读本文之前，需要你对View的绘制有一定的了解，如果不了解的可以 看下我之前的文章——<a href="https://github.com/Idtk/Blog" target="_blank" rel="external">自定义View系列目录</a><br></p>
<p>最近公司在做个类似朋友圈的功能，需要一个九宫格控件，因为算是个常用控件，所以自己撸了一个。<br></p>
<h2 id="职责分解"><a href="#职责分解" class="headerlink" title="职责分解"></a>职责分解</h2><p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/NinePhotoView/IKNinePhotoView.png" title="NinePhotoView" width="300"><br></p>
<p>上图是一个九宫格控件承载图片的显示情况，九宫格控件因为其需要承载其内部的View，所以应该是一个ViewGroup。每个子View基本上是相同的，但显示的内容不同，正好最近在看RecyclerView，因此也就想到了可以使用Adapter来个性化每个子View，正好通过Adapter模式来适配了子View与ViewGroup。最后为了防止在创建、显示子View时的冗余操作，应该给子View增加一些属性，选用ViewHolder正好可以完成这个要求，这样也更方便以后的扩展。<br></p>
<p><strong>ViewGroup、Adapter、ViewHolder三者的具体职责: </strong><br></p>
<table style="border-collapse:collapse border-width:thin border-style:solid border-color:black"><tr><th rowspan="6" style="text-align:center">功能</th></tr><tr><th>ViewGroup</th><th>Adapter</th><th>ViewHolder</th></tr><tr><td>Measure子View</td><td>创建子View布局</td><td>子View的获取</td></tr><tr><td>Layout子View</td><td>子View的内容display</td><td>display子View标志</td></tr><tr><td>add子View</td><td>子view数量</td><td></td></tr><tr><td>回收缓存</td><td>数据变化通知</td><td></td></tr></table>

<p><br></p>
<a id="more"></a>
<h2 id="ChildView的测量"><a href="#ChildView的测量" class="headerlink" title="ChildView的测量"></a>ChildView的测量</h2><p>ChildView测量所需要的数据主要来自于ParentView的测量数据，这里就是我们之前说的ViewGroup的<code>onMeasure</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 在这之前已经对childView的数量小于等于0或大于9的情况进行了处理</div><div class="line"> * 这里讲显示情况分成三种进行测量：</div><div class="line"> * 1、ChildView数量为1</div><div class="line"> * 2、ChildView数量为2或4</div><div class="line"> * 3、ChildView数量的剩余类型</div><div class="line"> */</div><div class="line"><span class="keyword">if</span> (adapter.getItemCount() &gt; <span class="number">1</span>) &#123;</div><div class="line">    childSize = (width - border * <span class="number">2</span>) / <span class="number">3</span>;</div><div class="line">    height = (<span class="keyword">int</span>) (childSize * (<span class="keyword">int</span>) Math.ceil(adapter.getItemCount() / <span class="number">3.0</span>) + border * (<span class="keyword">int</span>) Math.ceil(adapter.getItemCount() / <span class="number">3.0</span></div><div class="line">    <span class="keyword">if</span> (adapter.getItemCount() == <span class="number">4</span> || adapter.getItemCount() == <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">int</span> currentWidth = childSize*<span class="number">2</span> + border;</div><div class="line">        setMeasuredDimension(currentWidth + getPaddingLeft() + getPaddingRight(), height + getPaddingTop() + getPaddingBottom());</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> currentWidth = childSize*<span class="number">3</span> + border*<span class="number">2</span>;</div><div class="line">        setMeasuredDimension(currentWidth + getPaddingLeft() + getPaddingRight(), height + getPaddingTop() + getPaddingBottom());</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    childSize = width/<span class="number">3</span>;</div><div class="line">    height = width/<span class="number">3</span>;</div><div class="line">    setMeasuredDimension(width + getPaddingLeft() + getPaddingRight(), height + getPaddingTop() + getPaddingBottom());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="ChildView的添加"><a href="#ChildView的添加" class="headerlink" title="ChildView的添加"></a>ChildView的添加</h2><p>在测量ChildView之后，将使用<code>addView</code>方法将其添加到ViewGroup中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 在增加ChildView之前，需要先行清除已经添加的所有ChildView</div><div class="line"> */</div><div class="line">removeAllViews();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adapter.getItemCount(); i++) &#123;</div><div class="line">    addView(generateViewHolder(i).getItemView(),generateDefaultLayoutParams());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ChildView的回收"><a href="#ChildView的回收" class="headerlink" title="ChildView的回收"></a>ChildView的回收</h3><p>generateViewHolder是用于获取ChildView的方法，其中有一个简单的缓存列表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 当需要添加的ChildView的position小于缓存列表大小时，直接从缓存列表中获取ChildView</div><div class="line"> * 否则，则调用adapter.createView方法，创建一个新的ViewHolder，同时将其添加到缓存列表中</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> IKNinePhotoViewHolder <span class="title">generateViewHolder</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (position &lt; mRecyclerList.size()) &#123;</div><div class="line">        <span class="keyword">return</span> mRecyclerList.get(position);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (adapter != <span class="keyword">null</span>)&#123;</div><div class="line">            IKNinePhotoViewHolder holder = adapter.createView(IKNinePhotoView.<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">if</span> (holder == <span class="keyword">null</span>)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            mRecyclerList.add(holder);</div><div class="line">            <span class="keyword">return</span> holder;</div><div class="line">        &#125; <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ChildView的布局"><a href="#ChildView的布局" class="headerlink" title="ChildView的布局"></a>ChildView的布局</h2><p>在完成ChildView的测量和添加之后，需要对ChildView的位置进行确定。而这些数值来自ParentView的<code>onLayout</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 先对ChildView数量为4的特殊情况，进行处理，将其的列数确定为2。</div><div class="line"> */</div><div class="line"><span class="keyword">int</span> count = adapter.getItemCount();</div><div class="line"><span class="keyword">int</span> colNum = <span class="number">3</span>;</div><div class="line"><span class="keyword">if</span> (count == <span class="number">4</span>)&#123;</div><div class="line">    colNum = <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 便利每个ChildView，对其进行布局</div><div class="line"> */</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">    View childView = getChildAt(i);</div><div class="line">    <span class="keyword">if</span> (childView == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (adapter != <span class="keyword">null</span> &amp;&amp; mRecyclerList.get(i) != <span class="keyword">null</span> &amp;&amp;!mRecyclerList.get(i).getFlag()) &#123;</div><div class="line">        adapter.displayView(generateViewHolder(i), i);</div><div class="line">		<span class="comment">// 设置这个标志，表示此ViewHolder中包含的ChildView已经完成了布局，防止多余的操作</span></div><div class="line">        mRecyclerList.get(i).setFlag(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 之前设置的列数</span></div><div class="line">    <span class="keyword">int</span> rows = i / colNum;</div><div class="line">    <span class="keyword">int</span> cols = i % colNum;</div><div class="line">    <span class="keyword">int</span> childLeft = getPaddingLeft() + (childSize + border) * (cols);</div><div class="line">    <span class="keyword">int</span> childTop = getPaddingTop() + (childSize + border) * (rows);</div><div class="line">    <span class="keyword">int</span> childRight = childLeft + childSize;</div><div class="line">    <span class="keyword">int</span> childBottom = childTop + childSize;</div><div class="line">    childView.layout(childLeft, childTop, childRight, childBottom);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="ChildView数据的更新"><a href="#ChildView数据的更新" class="headerlink" title="ChildView数据的更新"></a>ChildView数据的更新</h2><p>到这里已经基本上完成了九宫格控件的编写，最后需要再添加一个数据更新的功能，以完备其功能。这里使用观察者模式的来实现这个功能，Adapter继承Observable类、ViewGroup实现Observer接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在Adapter中</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyChanged</span><span class="params">()</span></span>&#123;</div><div class="line">    setChanged();</div><div class="line">    notifyObservers();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在ViewGroup中</span></div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> IKNinePhotoViewAdapter)&#123;</div><div class="line">        <span class="keyword">this</span>.adapter = (IKNinePhotoViewAdapter) o;</div><div class="line">        adapter.addObserver(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">for</span>(IKNinePhotoViewHolder holder: mRecyclerList)&#123;</div><div class="line">            holder.setFlag(<span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line">        requestLayout();</div><div class="line">        invalidate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细说明了九宫格控件的实现方法，并对其功能进行了分解。分解成多个组件之后，不仅符合程序的单一性原则，更加易于程序的功能扩展，比如添加监听事件，使用不同的图片库去显示图片，同时九宫格的ChildView也不仅限于ImageView，而可以扩展到全部的View。如果在阅读过程中，有任何疑问与问题，欢迎与我联系。<br></p>
<p><strong>博客:www.idtkm.com</strong><br><br><strong>GitHub:<a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><br><strong>微博:<a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><br><strong>邮箱:IdtkMa@gmail.com</strong><br><br><br></p>
<p><a href="https://github.com/Idtk/IKNinePhotoView" target="_blank" rel="external">九宫格控件源码请点击</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在阅读本文之前，需要你对View的绘制有一定的了解，如果不了解的可以 看下我之前的文章——&lt;a href=&quot;https://github.com/Idtk/Blog&quot;&gt;自定义View系列目录&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;最近公司在做个类似朋友圈的功能，需要一个九宫格控件，因为算是个常用控件，所以自己撸了一个。&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;职责分解&quot;&gt;&lt;a href=&quot;#职责分解&quot; class=&quot;headerlink&quot; title=&quot;职责分解&quot;&gt;&lt;/a&gt;职责分解&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ompb0h8qq.bkt.clouddn.com/NinePhotoView/IKNinePhotoView.png&quot; title=&quot;NinePhotoView&quot; width=&quot;300&quot;/&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;上图是一个九宫格控件承载图片的显示情况，九宫格控件因为其需要承载其内部的View，所以应该是一个ViewGroup。每个子View基本上是相同的，但显示的内容不同，正好最近在看RecyclerView，因此也就想到了可以使用Adapter来个性化每个子View，正好通过Adapter模式来适配了子View与ViewGroup。最后为了防止在创建、显示子View时的冗余操作，应该给子View增加一些属性，选用ViewHolder正好可以完成这个要求，这样也更方便以后的扩展。&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ViewGroup、Adapter、ViewHolder三者的具体职责: &lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
&lt;table style=&quot;border-collapse:collapse border-width:thin border-style:solid border-color:black&quot;&gt;&lt;tr&gt;&lt;th rowspan=6 style=&quot;text-align:center&quot;&gt;功能&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;ViewGroup&lt;/th&gt;&lt;th&gt;Adapter&lt;/th&gt;&lt;th&gt;ViewHolder&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Measure子View&lt;/td&gt;&lt;td&gt;创建子View布局&lt;/td&gt;&lt;td&gt;子View的获取&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Layout子View&lt;/td&gt;&lt;td&gt;子View的内容display&lt;/td&gt;&lt;td&gt;display子View标志&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;add子View&lt;/td&gt;&lt;td&gt;子view数量&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;回收缓存&lt;/td&gt;&lt;td&gt;数据变化通知&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="CustomView" scheme="http://www.idtkm.com/tags/CustomView/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView绘制流程的简单分析</title>
    <link href="http://www.idtkm.com/2017/03/06/RecyclerView.LayoutManager/"/>
    <id>http://www.idtkm.com/2017/03/06/RecyclerView.LayoutManager/</id>
    <published>2017-03-05T16:00:00.000Z</published>
    <updated>2017-10-15T16:00:39.553Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;本文将简单分析下RecyclerView的绘制流程。既然是一个View，就从<code>onMeasure</code>开始。</p>
<h2 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (mLayout.mAutoMeasure) &#123;</div><div class="line">		<span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthSpec);</div><div class="line">		<span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightSpec);</div><div class="line">		<span class="keyword">final</span> <span class="keyword">boolean</span> skipMeasure = widthMode == MeasureSpec.EXACTLY</div><div class="line">				&amp;&amp; heightMode == MeasureSpec.EXACTLY;</div><div class="line"></div><div class="line">		mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</div><div class="line">			dispatchLayoutStep1();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		mLayout.setMeasureSpecs(widthSpec, heightSpec);</div><div class="line"></div><div class="line">		dispatchLayoutStep2();</div><div class="line"></div><div class="line">		mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>在<code>onMeasure</code>中，<code>mLayout</code>就是一个LayoutManager对象，RecyclerView将onMeasure的计算交给了LayoutManager，在<code>LayoutManager#onMeasure</code>中又调用了<code>RecyclerView#defaultOnMeasure</code>方法，在其中调用了<code>LayoutManager#chooseSize</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">chooseSize</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> desired, <span class="keyword">int</span> min)</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> mode = View.MeasureSpec.getMode(spec);</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> size = View.MeasureSpec.getSize(spec);</div><div class="line">	<span class="keyword">switch</span> (mode) &#123;</div><div class="line">		<span class="keyword">case</span> View.MeasureSpec.EXACTLY:</div><div class="line">			<span class="keyword">return</span> size;</div><div class="line">		<span class="keyword">case</span> View.MeasureSpec.AT_MOST:</div><div class="line">			<span class="keyword">return</span> Math.min(size, Math.max(desired, min));</div><div class="line">		<span class="keyword">case</span> View.MeasureSpec.UNSPECIFIED:</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="keyword">return</span> Math.max(desired, min);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以很明显的看出此方法，根据MessureSpec类型计算了View的宽高尺寸，之后将会调用<code>dispatchLayoutStep2</code>方法对item以及子view进行测量。<code>onLayout</code>中也将调用<code>dispatchLayoutStep2</code>方法，我们将在其中一起说明。</p>
<h2 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h2><p>这里看下<code>onLayout</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">	dispatchLayout();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</div><div class="line">		dispatchLayoutStep1();</div><div class="line">		mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</div><div class="line">		dispatchLayoutStep2();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	dispatchLayoutStep3();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>dispatchLayoutStep2()</code>方法中又调用<code>LayoutManager#onLayoutChildren</code>方法进行布局。这里以LinearLayoutManager为例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</div><div class="line">	<span class="comment">// layout algorithm:</span></div><div class="line">	<span class="comment">// 1) by checking children and other variables, find an anchor coordinate and an anchor</span></div><div class="line">	<span class="comment">//  item position.</span></div><div class="line">	<span class="comment">// 2) fill towards start, stacking from bottom</span></div><div class="line">	<span class="comment">// 3) fill towards end, stacking from top</span></div><div class="line">	<span class="comment">// 4) scroll to fulfill requirements like stack from bottom.</span></div><div class="line">	<span class="comment">// create layout state</span></div><div class="line"></div><div class="line">	<span class="keyword">int</span> startOffset;</div><div class="line">	<span class="keyword">int</span> endOffset;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> firstLayoutDirection;</div><div class="line"></div><div class="line">	onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);</div><div class="line">	detachAndScrapAttachedViews(recycler);</div><div class="line">	mLayoutState.mInfinite = resolveIsInfinite();</div><div class="line">	mLayoutState.mIsPreLayout = state.isPreLayout();</div><div class="line">	<span class="keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123;</div><div class="line"></div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// 向下布局</span></div><div class="line">		updateLayoutStateToFillEnd(mAnchorInfo);</div><div class="line">		mLayoutState.mExtra = extraForEnd;</div><div class="line">		<span class="comment">// 填充Item</span></div><div class="line">		fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</div><div class="line">		endOffset = mLayoutState.mOffset;</div><div class="line">		<span class="keyword">final</span> <span class="keyword">int</span> lastElement = mLayoutState.mCurrentPosition;</div><div class="line">		<span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) &#123;</div><div class="line">			extraForStart += mLayoutState.mAvailable;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 向上布局</span></div><div class="line">		updateLayoutStateToFillStart(mAnchorInfo);</div><div class="line">		mLayoutState.mExtra = extraForStart;</div><div class="line">		mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;</div><div class="line">		fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</div><div class="line">		startOffset = mLayoutState.mOffset;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>布局的流程在开头的注释中已经清楚的说明了，这里不再赘述。这里的关注点在<code>LinearLayoutManager#fill</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState,</span></span></div><div class="line">		RecyclerView.State state, <span class="keyword">boolean</span> stopOnFocusable) &#123;</div><div class="line">	<span class="comment">// 存储当前可见空间</span></div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> start = layoutState.mAvailable;</div><div class="line">	<span class="comment">// 计算可用布局的宽高</span></div><div class="line">	<span class="keyword">int</span> remainingSpace = layoutState.mAvailable + layoutState.mExtra;</div><div class="line">	LayoutChunkResult layoutChunkResult = mLayoutChunkResult;</div><div class="line">	<span class="comment">// 迭代填充item</span></div><div class="line">	<span class="keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;</div><div class="line">		layoutChunkResult.resetInternal();</div><div class="line">		<span class="comment">// 布局item</span></div><div class="line">		layoutChunk(recycler, state, layoutState, layoutChunkResult);</div><div class="line">		<span class="keyword">if</span> (layoutChunkResult.mFinished) &#123;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 计算布局的偏移位置</span></div><div class="line">		layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList != <span class="keyword">null</span></div><div class="line">				|| !state.isPreLayout()) &#123;</div><div class="line">			layoutState.mAvailable -= layoutChunkResult.mConsumed;</div><div class="line">			<span class="comment">// 计算剩余的空间</span></div><div class="line">			remainingSpace -= layoutChunkResult.mConsumed;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> start - layoutState.mAvailable;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>fill</code>方法中将会循环调用<code>layoutChunk</code>方法进行布局。每次布局完成之后将计算剩余的可用空间，之后判断是否还需要继续布局Item。我们这里来看下布局的<code>LinearLayoutManager#layoutChunk</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span></span></div><div class="line">		LayoutState layoutState, LayoutChunkResult result) &#123;</div><div class="line">	<span class="comment">// 获取item view</span></div><div class="line">	View view = layoutState.next(recycler);</div><div class="line">	<span class="comment">// 获取布局参数</span></div><div class="line">	LayoutParams params = (LayoutParams) view.getLayoutParams();</div><div class="line">	<span class="keyword">if</span> (layoutState.mScrapList == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection</div><div class="line">				== LayoutState.LAYOUT_START)) &#123;</div><div class="line">			<span class="comment">// 增加item view</span></div><div class="line">			addView(view);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			addView(view, <span class="number">0</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 测量item</span></div><div class="line">	measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">	<span class="comment">// 计算item使用的空间</span></div><div class="line">	result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view);</div><div class="line">	<span class="keyword">int</span> left, top, right, bottom;</div><div class="line">	<span class="comment">// 按照水平或者数值方向布局，计算item坐标</span></div><div class="line">	<span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</div><div class="line">		<span class="keyword">if</span> (isLayoutRTL()) &#123;</div><div class="line">			right = getWidth() - getPaddingRight();</div><div class="line">			left = right - mOrientationHelper.getDecoratedMeasurementInOther(view);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			left = getPaddingLeft();</div><div class="line">			right = left + mOrientationHelper.getDecoratedMeasurementInOther(view);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</div><div class="line">			bottom = layoutState.mOffset;</div><div class="line">			top = layoutState.mOffset - result.mConsumed;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			top = layoutState.mOffset;</div><div class="line">			bottom = layoutState.mOffset + result.mConsumed;</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">  	<span class="comment">// item布局</span></div><div class="line">	layoutDecoratedWithMargins(view, left, top, right, bottom);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child, <span class="keyword">int</span> widthUsed, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class="line">	<span class="comment">// 测量分割线</span></div><div class="line">	<span class="keyword">final</span> Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);</div><div class="line">	widthUsed += insets.left + insets.right;</div><div class="line">	heightUsed += insets.top + insets.bottom;</div><div class="line"></div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(),</div><div class="line">			getPaddingLeft() + getPaddingRight() +</div><div class="line">					lp.leftMargin + lp.rightMargin + widthUsed, lp.width,</div><div class="line">			canScrollHorizontally());</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(),</div><div class="line">			getPaddingTop() + getPaddingBottom() +</div><div class="line">					lp.topMargin + lp.bottomMargin + heightUsed, lp.height,</div><div class="line">			canScrollVertically());</div><div class="line">	<span class="keyword">if</span> (shouldMeasureChild(child, widthSpec, heightSpec, lp)) &#123;</div><div class="line">      	<span class="comment">// 子View测量</span></div><div class="line">		child.measure(widthSpec, heightSpec);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layoutDecoratedWithMargins</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right,</span></span></div><div class="line">		<span class="keyword">int</span> bottom) &#123;</div><div class="line">	<span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class="line">	<span class="keyword">final</span> Rect insets = lp.mDecorInsets;</div><div class="line">   <span class="comment">// 子View布局</span></div><div class="line">	child.layout(left + insets.left + lp.leftMargin, top + insets.top + lp.topMargin,</div><div class="line">			right - insets.right - lp.rightMargin,</div><div class="line">			bottom - insets.bottom - lp.bottomMargin);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看出，最后分别调用了item的<code>measure</code>函数与<code>layout</code>函数对view进行了测量和布局。下面我们来看下<code>onDraw</code>方法。</p>
<h2 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c)</span> </span>&#123;</div><div class="line">	<span class="keyword">super</span>.onDraw(c);</div><div class="line"></div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> count = mItemDecorations.size();</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">		mItemDecorations.get(i).onDraw(c, <span class="keyword">this</span>, mState);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>onDraw</code>的代码比较简单，除了调用<code>super.onDraw</code>外，还对分割线进行了绘制。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;本文通过View的基本方法对RecyclerView的绘制进行了简单的分析。RecyclerView通过LayoutManager类将测量、布局、绘制等从自身中分离了出来，减少了代码的耦合，使其更加灵活、更易扩展。如果在阅读过程中，有任何疑问与问题，欢迎与我联系。</p>
<p>&nbsp;&nbsp;<strong>博客: www.idtkm.com</strong><br><br>&nbsp;&nbsp;<strong>GitHub: <a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><br>&nbsp;&nbsp;<strong>微博: <a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><br>&nbsp;&nbsp;<strong>邮箱: IdtkMa@gmail.com</strong><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本文将简单分析下RecyclerView的绘制流程。既然是一个View，就从&lt;code&gt;onMeasure&lt;/code&gt;开始。&lt;/p&gt;
&lt;h2 id=&quot;onMeasure&quot;&gt;&lt;a href=&quot;#onMeasure&quot; class=&quot;headerlink&quot; title=&quot;onMeasure&quot;&gt;&lt;/a&gt;onMeasure&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onMeasure&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; widthSpec, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; heightSpec)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mLayout.mAutoMeasure) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; widthMode = MeasureSpec.getMode(widthSpec);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; heightMode = MeasureSpec.getMode(heightSpec);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; skipMeasure = widthMode == MeasureSpec.EXACTLY&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				&amp;amp;&amp;amp; heightMode == MeasureSpec.EXACTLY;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mState.mLayoutStep == State.STEP_START) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			dispatchLayoutStep1();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		mLayout.setMeasureSpecs(widthSpec, heightSpec);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		dispatchLayoutStep2();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="RecyclerView" scheme="http://www.idtkm.com/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>属性动画连续输出值分析</title>
    <link href="http://www.idtkm.com/2016/11/10/F1%E3%80%81Property%20Animation/"/>
    <id>http://www.idtkm.com/2016/11/10/F1、Property Animation/</id>
    <published>2016-11-09T16:00:00.000Z</published>
    <updated>2017-10-15T16:00:53.461Z</updated>
    
    <content type="html"><![CDATA[<p>大家在开发过程中，经常会使用到属性动画，这里以ValueAnimator为例，它可以通过addUpdateListener来监听输出的数值，就像这样 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ValueAnimator animator;</div><div class="line"><span class="keyword">private</span> <span class="keyword">float</span> animatedValue;</div><div class="line"><span class="keyword">private</span> TimeInterpolator timeInterpolator = <span class="keyword">new</span> DecelerateInterpolator();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAnimator</span><span class="params">(<span class="keyword">long</span> duration)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (animator != <span class="keyword">null</span> &amp;&amp; animator.isRunning()) &#123;</div><div class="line">        animator.cancel();</div><div class="line">        animator.start();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        animator = ValueAnimator.ofFloat(<span class="number">0</span>, <span class="number">1000</span>).setDuration(duration);</div><div class="line">        animator.setInterpolator(timeInterpolator);</div><div class="line">        animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</div><div class="line">                animatedValue = (<span class="keyword">float</span>) animation.getAnimatedValue();</div><div class="line">                now = SystemClock.elapsedRealtime();</div><div class="line">                diff = now - preNow;</div><div class="line">                preNow = now;</div><div class="line">                Log.d(<span class="string">"animator"</span>, <span class="string">"animatedValue: "</span> + animatedValue + <span class="string">" now: "</span> + now + <span class="string">" diff: "</span> + diff);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        animator.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其输出值animatedValue是一个随时间变化的连续数值，就像这样 :</p>
<a id="more"></a>
<p><br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/Animator/Log.png" alt="Log" title="Log"><br><br></p>
<p><strong><em>注：本文基于源码sdk level 24</em></strong></p>
<h2 id="那么它是如何产生这样一组连续变化的数值呢？"><a href="#那么它是如何产生这样一组连续变化的数值呢？" class="headerlink" title="那么它是如何产生这样一组连续变化的数值呢？"></a>那么它是如何产生这样一组连续变化的数值呢？</h2><p>从<code>animator.start()</code>方法开始</p>
<h5 id="ValueAnimator-start"><a href="#ValueAnimator-start" class="headerlink" title="ValueAnimator.start"></a><code>ValueAnimator.start</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    start(<span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> playBackwards)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (Looper.myLooper() == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Animators may only be run on Looper threads"</span>);</div><div class="line">    &#125;</div><div class="line">    mReversing = playBackwards;</div><div class="line">    <span class="keyword">if</span> (playBackwards &amp;&amp; mSeekFraction != -<span class="number">1</span> &amp;&amp; mSeekFraction != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mRepeatCount == INFINITE) &#123;</div><div class="line">            <span class="keyword">float</span> fraction = (<span class="keyword">float</span>) (mSeekFraction - Math.floor(mSeekFraction));</div><div class="line">            mSeekFraction = <span class="number">1</span> - fraction;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mSeekFraction = <span class="number">1</span> + mRepeatCount - mSeekFraction;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    mStarted = <span class="keyword">true</span>;</div><div class="line">    mPaused = <span class="keyword">false</span>;</div><div class="line">    mRunning = <span class="keyword">false</span>;</div><div class="line">    mLastFrameTime = <span class="number">0</span>;</div><div class="line">    AnimationHandler animationHandler = AnimationHandler.getInstance();</div><div class="line">	<span class="comment">// 注册Vsync并执行</span></div><div class="line">    animationHandler.addAnimationFrameCallback(<span class="keyword">this</span>, (<span class="keyword">long</span>) (mStartDelay * sDurationScale));</div><div class="line">    <span class="keyword">if</span> (mStartDelay == <span class="number">0</span> || mSeekFraction &gt;= <span class="number">0</span>) &#123;</div><div class="line">		<span class="comment">// 开始动画</span></div><div class="line">        startAnimation();</div><div class="line">        <span class="keyword">if</span> (mSeekFraction == -<span class="number">1</span>) &#123;</div><div class="line">            setCurrentPlayTime(<span class="number">0</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            setCurrentFraction(mSeekFraction);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>start</code>方法先对Looper进行了检查，之后是一个回放计算以及一些设置。然后获取了<code>AnimationHandler</code>的单例，<code>AnimationHandler</code>并不是一个Handler，而是包含了一个Calback。这里比较重要的代码有两段<code>animationHandler.addAnimationFrameCallback(this, (long) (mStartDelay * sDurationScale));</code>和<code>startAnimation();</code>，他们分别进行了Vsync的注册以及动画的启动。</p>
<h3 id="加入回调"><a href="#加入回调" class="headerlink" title="加入回调"></a>加入回调</h3><h5 id="AnimationHandler-addAnimationFrameCallback"><a href="#AnimationHandler-addAnimationFrameCallback" class="headerlink" title="AnimationHandler.addAnimationFrameCallback"></a><code>AnimationHandler.addAnimationFrameCallback</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAnimationFrameCallback</span><span class="params">(<span class="keyword">final</span> AnimationFrameCallback callback, <span class="keyword">long</span> delay)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mAnimationCallbacks.size() == <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">// mFrameCallback就是之前说的Callback</span></div><div class="line">      <span class="comment">// getProvider获得的是一个实现了AnimationFrameCallbackProvider</span></div><div class="line">      <span class="comment">// 接口的内部类MyFrameCallbackProvider</span></div><div class="line">        getProvider().postFrameCallback(mFrameCallback);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!mAnimationCallbacks.contains(callback)) &#123;</div><div class="line">      <span class="comment">// 把动画加入回调列表</span></div><div class="line">        mAnimationCallbacks.add(callback);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (delay &gt; <span class="number">0</span>) &#123;</div><div class="line">        mDelayedCallbackStartTime.put(callback, (SystemClock.uptimeMillis() + delay));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="MyFrameCallbackProvider-postFrameCallback"><a href="#MyFrameCallbackProvider-postFrameCallback" class="headerlink" title="MyFrameCallbackProvider.postFrameCallback"></a><code>MyFrameCallbackProvider.postFrameCallback</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postFrameCallback</span><span class="params">(Choreographer.FrameCallback callback)</span> </span>&#123;</div><div class="line">  <span class="comment">// mChoreographer也是个单例</span></div><div class="line">  <span class="comment">// 将mFrameCallback继续传递至Choreographer</span></div><div class="line">    mChoreographer.postFrameCallback(callback);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Choreographer-postFrameCallback"><a href="#Choreographer-postFrameCallback" class="headerlink" title="Choreographer.postFrameCallback"></a><code>Choreographer.postFrameCallback</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postFrameCallback</span><span class="params">(FrameCallback callback)</span> </span>&#123;</div><div class="line">    postFrameCallbackDelayed(callback, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Choreographer-postFrameCallbackDelayed"><a href="#Choreographer-postFrameCallbackDelayed" class="headerlink" title="Choreographer.postFrameCallbackDelayed"></a><code>Choreographer.postFrameCallbackDelayed</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postFrameCallbackDelayed</span><span class="params">(FrameCallback callback, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (callback == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"callback must not be null"</span>);</div><div class="line">    &#125;</div><div class="line">    postCallbackDelayedInternal(CALLBACK_ANIMATION,</div><div class="line">            callback, FRAME_CALLBACK_TOKEN, delayMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Choreographer-postCallbackDelayedInternal"><a href="#Choreographer-postCallbackDelayedInternal" class="headerlink" title="Choreographer.postCallbackDelayedInternal"></a><code>Choreographer.postCallbackDelayedInternal</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></div><div class="line">        Object action, Object token, <span class="keyword">long</span> delayMillis) &#123;</div><div class="line">    <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</div><div class="line">        Log.d(TAG, <span class="string">"PostCallback: type="</span> + callbackType</div><div class="line">                + <span class="string">", action="</span> + action + <span class="string">", token="</span> + token</div><div class="line">                + <span class="string">", delayMillis="</span> + delayMillis);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</div><div class="line">      <span class="comment">// 将要执行的回调用保存到mCallbackQueues中</span></div><div class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</div><div class="line">      <span class="comment">// delayMillis=0,所以执行scheduleFrameLocked</span></div><div class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</div><div class="line">            scheduleFrameLocked(now);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</div><div class="line">            msg.arg1 = callbackType;</div><div class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">            mHandler.sendMessageAtTime(msg, dueTime);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Vsync的注册"><a href="#Vsync的注册" class="headerlink" title="Vsync的注册"></a>Vsync的注册</h3><h5 id="Choreographer-scheduleFrameLocked"><a href="#Choreographer-scheduleFrameLocked" class="headerlink" title="Choreographer.scheduleFrameLocked"></a>Choreographer.scheduleFrameLocked</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!mFrameScheduled) &#123;</div><div class="line">        mFrameScheduled = <span class="keyword">true</span>;</div><div class="line">      <span class="comment">// 检查是否使用了Vsync机制</span></div><div class="line">        <span class="keyword">if</span> (USE_VSYNC) &#123;</div><div class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</div><div class="line">                Log.d(TAG, <span class="string">"Scheduling next frame on vsync."</span>);</div><div class="line">            &#125;</div><div class="line">          <span class="comment">// 检查是否运行在Looper线程</span></div><div class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</div><div class="line">                scheduleVsyncLocked();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</div><div class="line">                msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> nextFrameTime = Math.max(</div><div class="line">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</div><div class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</div><div class="line">                Log.d(TAG, <span class="string">"Scheduling next frame in "</span> + (nextFrameTime - now) + <span class="string">" ms."</span>);</div><div class="line">            &#125;</div><div class="line">            Message msg = mHandler.obtainMessage(MSG_DO_FRAME);</div><div class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">            mHandler.sendMessageAtTime(msg, nextFrameTime);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Choreographer-scheduleVsyncLocked"><a href="#Choreographer-scheduleVsyncLocked" class="headerlink" title="Choreographer.scheduleVsyncLocked"></a><code>Choreographer.scheduleVsyncLocked</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mDisplayEventReceiver = USE_VSYNC ? <span class="keyword">new</span> FrameDisplayEventReceiver(looper) : <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;</div><div class="line">    mDisplayEventReceiver.scheduleVsync();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在查看<code>DisplayEventReceiver.scheduleVsync</code>方法之前，我们先看看FrameDisplayEventReceiver的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title">DisplayEventReceiver</span></span></div><div class="line">        <span class="keyword">implements</span> <span class="title">Runnable</span> &#123;</div><div class="line">	...</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrameDisplayEventReceiver</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(looper);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">DisplayEventReceiver</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"looper must not be null"</span>);</div><div class="line">    &#125;</div><div class="line">    mMessageQueue = looper.getQueue();</div><div class="line">  <span class="comment">// 注册vsync</span></div><div class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> WeakReference&lt;DisplayEventReceiver&gt;(<span class="keyword">this</span>), mMessageQueue);</div><div class="line">    mCloseGuard.open(<span class="string">"dispose"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>FrameDisplayEventReceiver</code>继承了<code>DisplayEventReceiver</code>，成为了Vsync事件的接收者，同时也实现了起<code>onVsync</code>方法，这个方法我将在后面进行介绍。而最重要的<code>nativeInit</code>方法实现了当前动画与Vsync的关联，注册成为Vsync的接收者。现在我们接着看<code>scheduleVsync</code>方法。</p>
<h3 id="执行Vsync"><a href="#执行Vsync" class="headerlink" title="执行Vsync"></a>执行Vsync</h3><h5 id="DisplayEventReceiver-scheduleVsync"><a href="#DisplayEventReceiver-scheduleVsync" class="headerlink" title="DisplayEventReceiver.scheduleVsync"></a><code>DisplayEventReceiver.scheduleVsync</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleVsync</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</div><div class="line">        Log.w(TAG, <span class="string">"Attempted to schedule a vertical sync pulse but the display event "</span></div><div class="line">                + <span class="string">"receiver has already been disposed."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 接收Vsync信号</span></div><div class="line">        nativeScheduleVsync(mReceiverPtr);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过底层代码nativeScheduleVsync将会调用Vsync接收者的<code>onVsync</code>方法，而我们之前说的<code>FrameDisplayEventReceiver</code>就是这个接收者。</p>
<h5 id="FrameDisplayEventReceiver-onVsync"><a href="#FrameDisplayEventReceiver-onVsync" class="headerlink" title="FrameDisplayEventReceiver.onVsync"></a><code>FrameDisplayEventReceiver.onVsync</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123;</div><div class="line">        Log.d(TAG, <span class="string">"Received vsync from secondary display, but we don't support "</span></div><div class="line">                + <span class="string">"this case yet.  Choreographer needs a way to explicitly request "</span></div><div class="line">                + <span class="string">"vsync for a specific display to ensure it doesn't lose track "</span></div><div class="line">                + <span class="string">"of its scheduled vsync."</span>);</div><div class="line">        scheduleVsync();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> now = System.nanoTime();</div><div class="line">    <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</div><div class="line">        Log.w(TAG, <span class="string">"Frame time is "</span> + ((timestampNanos - now) * <span class="number">0.000001f</span>)</div><div class="line">                + <span class="string">" ms in the future!  Check that graphics HAL is generating vsync "</span></div><div class="line">                + <span class="string">"timestamps using the correct timebase."</span>);</div><div class="line">        timestampNanos = now;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mHavePendingVsync) &#123;</div><div class="line">        Log.w(TAG, <span class="string">"Already have a pending vsync event.  There should only be "</span></div><div class="line">                + <span class="string">"one at a time."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mHavePendingVsync = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">  <span class="comment">// 同步时间</span></div><div class="line">    mTimestampNanos = timestampNanos;</div><div class="line">  <span class="comment">// 同步帧</span></div><div class="line">    mFrame = frame;</div><div class="line">    Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</div><div class="line">    msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过mhandler，将执行doFrame方法</p>
<h5 id="FrameDisplayEventReceiver-doFrame"><a href="#FrameDisplayEventReceiver-doFrame" class="headerlink" title="FrameDisplayEventReceiver.doFrame"></a><code>FrameDisplayEventReceiver.doFrame</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startNanos;</div><div class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">        <span class="keyword">if</span> (!mFrameScheduled) &#123;</div><div class="line">            <span class="keyword">return</span>; <span class="comment">// no work to do</span></div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">      <span class="comment">// 消息传递之前的时间</span></div><div class="line">        <span class="keyword">long</span> intendedFrameTimeNanos = frameTimeNanos;</div><div class="line">      <span class="comment">// 起始时间</span></div><div class="line">        startNanos = System.nanoTime();</div><div class="line">      <span class="comment">// 计算消息传递花费时间</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> jitterNanos = startNanos - frameTimeNanos;</div><div class="line">        <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</div><div class="line">          <span class="comment">// 计算消息传递错过的帧数</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> skippedFrames = jitterNanos / mFrameIntervalNanos;</div><div class="line">            ...</div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> lastFrameOffset = jitterNanos % mFrameIntervalNanos;</div><div class="line">            ...</div><div class="line">            frameTimeNanos = startNanos - lastFrameOffset;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (frameTimeNanos &lt; mLastFrameTimeNanos) &#123;</div><div class="line">            ...</div><div class="line">            scheduleVsyncLocked();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</div><div class="line">        mFrameScheduled = <span class="keyword">false</span>;</div><div class="line">        mLastFrameTimeNanos = frameTimeNanos;</div><div class="line">    &#125;</div><div class="line">  <span class="comment">// 执行回调，也就是这之前的mFrameCallback</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"Choreographer#doFrame"</span>);</div><div class="line">        mFrameInfo.markInputHandlingStart();</div><div class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</div><div class="line">        mFrameInfo.markAnimationsStart();</div><div class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</div><div class="line">        mFrameInfo.markPerformTraversalsStart();</div><div class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</div><div class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里对动画的运行时间进行了跳帧，这也就是我们在Log中看到的动画启动时，间隔时间较长的原因。</p>
<h3 id="执行回调"><a href="#执行回调" class="headerlink" title="执行回调"></a>执行回调</h3><h5 id="FrameDisplayEventReceiver-doCallbacks"><a href="#FrameDisplayEventReceiver-doCallbacks" class="headerlink" title="FrameDisplayEventReceiver.doCallbacks"></a><code>FrameDisplayEventReceiver.doCallbacks</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doCallbacks</span><span class="params">(<span class="keyword">int</span> callbackType, <span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">    CallbackRecord callbacks;</div><div class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = System.nanoTime();</div><div class="line">      <span class="comment">// 获取到达执行时间的Callback</span></div><div class="line">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(</div><div class="line">                now / TimeUtils.NANOS_PER_MS);</div><div class="line">        <span class="keyword">if</span> (callbacks == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        mCallbacksRunning = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (callbackType == Choreographer.CALLBACK_COMMIT) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> jitterNanos = now - frameTimeNanos;</div><div class="line">            Trace.traceCounter(Trace.TRACE_TAG_VIEW, <span class="string">"jitterNanos"</span>, (<span class="keyword">int</span>) jitterNanos);</div><div class="line">            <span class="keyword">if</span> (jitterNanos &gt;= <span class="number">2</span> * mFrameIntervalNanos) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">long</span> lastFrameOffset = jitterNanos % mFrameIntervalNanos</div><div class="line">                        + mFrameIntervalNanos;</div><div class="line">                frameTimeNanos = now - lastFrameOffset;</div><div class="line">                mLastFrameTimeNanos = frameTimeNanos;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]);</div><div class="line">      <span class="comment">// 逐个执行到达时间的Callback</span></div><div class="line">        <span class="keyword">for</span> (CallbackRecord c = callbacks; c != <span class="keyword">null</span>; c = c.next) &#123;</div><div class="line">            c.run(frameTimeNanos);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">            mCallbacksRunning = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                <span class="keyword">final</span> CallbackRecord next = callbacks.next;</div><div class="line">                recycleCallbackLocked(callbacks);</div><div class="line">                callbacks = next;</div><div class="line">            &#125; <span class="keyword">while</span> (callbacks != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>c.run</code>将执行实现了<code>FrameCallback</code>接口的<code>doFrame</code>方法，也就是我们之前说的回调</p>
<h5 id="mFrameCallback"><a href="#mFrameCallback" class="headerlink" title="mFrameCallback"></a><code>mFrameCallback</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Choreographer.FrameCallback mFrameCallback = <span class="keyword">new</span> Choreographer.FrameCallback() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">        doAnimationFrame(getProvider().getFrameTime());</div><div class="line">        <span class="keyword">if</span> (mAnimationCallbacks.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">          <span class="comment">// 这里是循环的地方</span></div><div class="line">            getProvider().postFrameCallback(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="AnimationHandler-doAnimationFrame"><a href="#AnimationHandler-doAnimationFrame" class="headerlink" title="AnimationHandler.doAnimationFrame"></a><code>AnimationHandler.doAnimationFrame</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> size = mAnimationCallbacks.size();</div><div class="line">    <span class="keyword">long</span> currentTime = SystemClock.uptimeMillis();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">final</span> AnimationFrameCallback callback = mAnimationCallbacks.get(i);</div><div class="line">        <span class="keyword">if</span> (callback == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (isCallbackDue(callback, currentTime)) &#123;</div><div class="line">          <span class="comment">// 这里的callback就是实现了AnimationFrameCallback</span></div><div class="line">          <span class="comment">// 接口的ValueAnimator</span></div><div class="line">            callback.doAnimationFrame(frameTime);</div><div class="line">            <span class="keyword">if</span> (mCommitCallbacks.contains(callback)) &#123;</div><div class="line">                getProvider().postCommitCallback(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        commitAnimationFrame(callback, getProvider().getFrameTime());</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cleanUpList();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="ValueAnimator-doAnimationFrame"><a href="#ValueAnimator-doAnimationFrame" class="headerlink" title="ValueAnimator.doAnimationFrame"></a><code>ValueAnimator.doAnimationFrame</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</div><div class="line">    AnimationHandler handler = AnimationHandler.getInstance();</div><div class="line">    <span class="keyword">if</span> (mLastFrameTime == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// First frame</span></div><div class="line">        handler.addOneShotCommitCallback(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (mStartDelay &gt; <span class="number">0</span>) &#123;</div><div class="line">            startAnimation();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (mSeekFraction &lt; <span class="number">0</span>) &#123;</div><div class="line">            mStartTime = frameTime;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">long</span> seekTime = (<span class="keyword">long</span>) (getScaledDuration() * mSeekFraction);</div><div class="line">            mStartTime = frameTime - seekTime;</div><div class="line">            mSeekFraction = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        mStartTimeCommitted = <span class="keyword">false</span>; <span class="comment">// allow start time to be compensated for jank</span></div><div class="line">    &#125;</div><div class="line">    mLastFrameTime = frameTime;</div><div class="line">    <span class="keyword">if</span> (mPaused) &#123;</div><div class="line">        mPauseTime = frameTime;</div><div class="line">        handler.removeCallback(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResumed) &#123;</div><div class="line">        mResumed = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (mPauseTime &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// Offset by the duration that the animation was paused</span></div><div class="line">            mStartTime += (frameTime - mPauseTime);</div><div class="line">            mStartTimeCommitted = <span class="keyword">false</span>; <span class="comment">// allow start time to be compensated for jank</span></div><div class="line">        &#125;</div><div class="line">        handler.addOneShotCommitCallback(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> currentTime = Math.max(frameTime, mStartTime);</div><div class="line">    <span class="keyword">boolean</span> finished = animateBasedOnTime(currentTime);</div><div class="line">    <span class="keyword">if</span> (finished) &#123;</div><div class="line">        endAnimation();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="ValueAnimator-animateBasedOnTime"><a href="#ValueAnimator-animateBasedOnTime" class="headerlink" title="ValueAnimator.animateBasedOnTime"></a><code>ValueAnimator.animateBasedOnTime</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">animateBasedOnTime</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</div><div class="line">  <span class="comment">// mRunning要到执行startAnimation才会为true</span></div><div class="line">    <span class="keyword">if</span> (mRunning) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> scaledDuration = getScaledDuration();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">float</span> fraction = scaledDuration &gt; <span class="number">0</span> ?</div><div class="line">                (<span class="keyword">float</span>)(currentTime - mStartTime) / scaledDuration : <span class="number">1f</span>;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">float</span> lastFraction = mOverallFraction;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> newIteration = (<span class="keyword">int</span>) fraction &gt; (<span class="keyword">int</span>) lastFraction;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> lastIterationFinished = (fraction &gt;= mRepeatCount + <span class="number">1</span>) &amp;&amp;</div><div class="line">                (mRepeatCount != INFINITE);</div><div class="line">        <span class="keyword">if</span> (scaledDuration == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 0 duration animator, ignore the repeat count and skip to the end</span></div><div class="line">            done = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newIteration &amp;&amp; !lastIterationFinished) &#123;</div><div class="line">            <span class="comment">// Time to repeat</span></div><div class="line">            <span class="keyword">if</span> (mListeners != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">int</span> numListeners = mListeners.size();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">                    mListeners.get(i).onAnimationRepeat(<span class="keyword">this</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastIterationFinished) &#123;</div><div class="line">            done = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        mOverallFraction = clampFraction(fraction);</div><div class="line">      <span class="comment">// 获取当前执行的分数</span></div><div class="line">        <span class="keyword">float</span> currentIterationFraction = getCurrentIterationFraction(mOverallFraction);</div><div class="line">      <span class="comment">// 设置动画值</span></div><div class="line">        animateValue(currentIterationFraction);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> done;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以我们这里先来看一下startAnimation函数</p>
<h5 id="ValueAnimator-startAnimation"><a href="#ValueAnimator-startAnimation" class="headerlink" title="ValueAnimator.startAnimation"></a><code>ValueAnimator.startAnimation</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startAnimation</span><span class="params">()</span> </span>&#123;</div><div class="line">  ...</div><div class="line">    mAnimationEndRequested = <span class="keyword">false</span>;</div><div class="line">  <span class="comment">// 初始化</span></div><div class="line">    initAnimation();</div><div class="line">  <span class="comment">// 设置mRunning为true，animateBasedOnTime函数中的代码得以执行</span></div><div class="line">    mRunning = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (mSeekFraction &gt;= <span class="number">0</span>) &#123;</div><div class="line">        mOverallFraction = mSeekFraction;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mOverallFraction = <span class="number">0f</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mListeners != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// 通知动画启动</span></div><div class="line">        notifyStartListeners();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们这里继续接着之前的animateBasedOnTime函数，这里假设动画执行的分数还不为1。</p>
<h5 id="ValueAnimator-animateValue"><a href="#ValueAnimator-animateValue" class="headerlink" title="ValueAnimator.animateValue"></a><code>ValueAnimator.animateValue</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</div><div class="line">    fraction = mInterpolator.getInterpolation(fraction);</div><div class="line">    mCurrentFraction = fraction;</div><div class="line">    <span class="keyword">int</span> numValues = mValues.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</div><div class="line">      <span class="comment">// 根据分数计算当前数值</span></div><div class="line">        mValues[i].calculateValue(fraction);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mUpdateListeners != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> numListeners = mUpdateListeners.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">          <span class="comment">// onAnimationUpdate就是我们监听输出值时的接口</span></div><div class="line">            mUpdateListeners.get(i).onAnimationUpdate(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="循环产生连续的值"><a href="#循环产生连续的值" class="headerlink" title="循环产生连续的值"></a>循环产生连续的值</h3><p>我们现在再来回头看看mFrameCallback</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Choreographer.FrameCallback mFrameCallback = <span class="keyword">new</span> Choreographer.FrameCallback() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">      <span class="comment">// 这是我们之前的</span></div><div class="line">        doAnimationFrame(getProvider().getFrameTime());</div><div class="line">        <span class="keyword">if</span> (mAnimationCallbacks.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            getProvider().postFrameCallback(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当Vsync执行其<code>onVsync</code>方法后，经过跳转执行到了<code>doFrame</code>方法，而在<code>animationHandler.addAnimationFrameCallback</code>方法中我们将动画本身加入了<code>mAnimationCallbacks</code>列表中，所以这里经过判断之后，将会继续执行<code>getProvider().postFrameCallback(this)</code>，之后的流程就像之前一样了。</p>
<p>我们现在找到了循环的地方，那么什么时候循环将会停止呢？</p>
<h2 id="那么什么时候输出值将会结束呢？"><a href="#那么什么时候输出值将会结束呢？" class="headerlink" title="那么什么时候输出值将会结束呢？"></a>那么什么时候输出值将会结束呢？</h2><p>对于这个问题，我们回头看一下animateBasedOnTime函数</p>
<h5 id="ValueAnimator-animateBasedOnTime-1"><a href="#ValueAnimator-animateBasedOnTime-1" class="headerlink" title="ValueAnimator.animateBasedOnTime"></a><code>ValueAnimator.animateBasedOnTime</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">animateBasedOnTime</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</div><div class="line">  <span class="comment">// mRunning要到执行startAnimation才会为true</span></div><div class="line">    <span class="keyword">if</span> (mRunning) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> scaledDuration = getScaledDuration();</div><div class="line">      <span class="comment">// 当执行时间 &gt;= (设置的时间*执行次数)时，fraction &gt;= (执行次数+1)</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">float</span> fraction = scaledDuration &gt; <span class="number">0</span> ?</div><div class="line">                (<span class="keyword">float</span>)(currentTime - mStartTime) / scaledDuration : <span class="number">1f</span>;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">float</span> lastFraction = mOverallFraction;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> newIteration = (<span class="keyword">int</span>) fraction &gt; (<span class="keyword">int</span>) lastFraction;</div><div class="line">      <span class="comment">// 这里假设重复次数为0，执行时间刚好等于设置的时间</span></div><div class="line">      <span class="comment">// lastIterationFinished =(1 &gt;= 0+1) &amp;&amp; (0 != -1)</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> lastIterationFinished = (fraction &gt;= mRepeatCount + <span class="number">1</span>) &amp;&amp;</div><div class="line">                (mRepeatCount != INFINITE);</div><div class="line">        <span class="keyword">if</span> (scaledDuration == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 0 duration animator, ignore the repeat count and skip to the end</span></div><div class="line">            done = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newIteration &amp;&amp; !lastIterationFinished) &#123;</div><div class="line">            <span class="comment">// Time to repeat</span></div><div class="line">            <span class="keyword">if</span> (mListeners != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">int</span> numListeners = mListeners.size();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">                    mListeners.get(i).onAnimationRepeat(<span class="keyword">this</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastIterationFinished) &#123;</div><div class="line">          <span class="comment">// lastIterationFinished为true，这里将会执行</span></div><div class="line">            done = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        mOverallFraction = clampFraction(fraction);</div><div class="line">      <span class="comment">// 获取当前执行的分数</span></div><div class="line">        <span class="keyword">float</span> currentIterationFraction = getCurrentIterationFraction(mOverallFraction);</div><div class="line">      <span class="comment">// 设置动画值</span></div><div class="line">        animateValue(currentIterationFraction);</div><div class="line">    &#125;</div><div class="line">  <span class="comment">// 所以返回结果为true</span></div><div class="line">    <span class="keyword">return</span> done;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当动画执行大于等于设定时间时，animateBasedOnTime返回true。</p>
<p>在<code>ValueAnimator.doAnimationFrame</code>中，如果animateBasedOnTime返回true，则将执行<code>endAnimation()</code>函数。</p>
<h5 id="ValueAnimator-endAnimation"><a href="#ValueAnimator-endAnimation" class="headerlink" title="ValueAnimator.endAnimation"></a><code>ValueAnimator.endAnimation</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">endAnimation</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mAnimationEndRequested) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    AnimationHandler handler = AnimationHandler.getInstance();</div><div class="line">  <span class="comment">// 将会设置当前动画的回调为null</span></div><div class="line">    handler.removeCallback(<span class="keyword">this</span>);</div><div class="line">    mAnimationEndRequested = <span class="keyword">true</span>;</div><div class="line">    mPaused = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> ((mStarted || mRunning) &amp;&amp; mListeners != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!mRunning) &#123;</div><div class="line">            <span class="comment">// If it's not yet running, then start listeners weren't called. Call them now.</span></div><div class="line">            notifyStartListeners();</div><div class="line">         &#125;</div><div class="line">        ArrayList&lt;AnimatorListener&gt; tmpListeners =</div><div class="line">                (ArrayList&lt;AnimatorListener&gt;) mListeners.clone();</div><div class="line">        <span class="keyword">int</span> numListeners = tmpListeners.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">            tmpListeners.get(i).onAnimationEnd(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    mRunning = <span class="keyword">false</span>;</div><div class="line">    mStarted = <span class="keyword">false</span>;</div><div class="line">    mStartListenersCalled = <span class="keyword">false</span>;</div><div class="line">    mReversing = <span class="keyword">false</span>;</div><div class="line">    mLastFrameTime = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) &#123;</div><div class="line">        Trace.asyncTraceEnd(Trace.TRACE_TAG_VIEW, getNameForTrace(),</div><div class="line">                System.identityHashCode(<span class="keyword">this</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="AnimationHandler-removeCallback"><a href="#AnimationHandler-removeCallback" class="headerlink" title="AnimationHandler.removeCallback"></a><code>AnimationHandler.removeCallback</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeCallback</span><span class="params">(AnimationFrameCallback callback)</span> </span>&#123;</div><div class="line">    mCommitCallbacks.remove(callback);</div><div class="line">    mDelayedCallbackStartTime.remove(callback);</div><div class="line">    <span class="keyword">int</span> id = mAnimationCallbacks.indexOf(callback);</div><div class="line">    <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</div><div class="line">        mAnimationCallbacks.set(id, <span class="keyword">null</span>);</div><div class="line">        mListDirty = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>设置为null之后有什么用了，我们这里回到Vsync的调用，<code>onVsync→doFrame→doCallbacks→doFrame→doAnimationFrame</code>，在<code>AnimationHandler.doAnimationFrame</code>的方法最后将执行cleanUpList方法。</p>
<h5 id="AnimationHandler-cleanUpList"><a href="#AnimationHandler-cleanUpList" class="headerlink" title="AnimationHandler.cleanUpList"></a><code>AnimationHandler.cleanUpList</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanUpList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mListDirty) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mAnimationCallbacks.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">if</span> (mAnimationCallbacks.get(i) == <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="comment">// 如果回调为null，则将移除回调</span></div><div class="line">                mAnimationCallbacks.remove(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        mListDirty = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>设置为null的回调被移除后，动画也就自然而然的停止了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后整理下流程 :</p>
<p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/Animator/Animator.png" alt="Log" title="Log"><br><br></p>
<p>如果在阅读过程中，有任何疑问与问题，欢迎与我联系。<br><br><strong>博客:www.idtkm.com</strong><br><br><strong>GitHub:<a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><br><strong>微博:<a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><br><strong>邮箱:IdtkMa@gmail.com</strong><br><br><br></p>
<h2 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks"></a>Thanks</h2><p><a href="http://www.jianshu.com/users/ec95b5891948/latest_articles" target="_blank" rel="external">D_clock爱吃葱花</a></p>
<p><a href="http://blog.desmondyao.com/" target="_blank" rel="external">姚家艺</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家在开发过程中，经常会使用到属性动画，这里以ValueAnimator为例，它可以通过addUpdateListener来监听输出的数值，就像这样 :&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; ValueAnimator animator;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; animatedValue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; TimeInterpolator timeInterpolator = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DecelerateInterpolator();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;initAnimator&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; duration)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (animator != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; animator.isRunning()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        animator.cancel();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        animator.start();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        animator = ValueAnimator.ofFloat(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;).setDuration(duration);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        animator.setInterpolator(timeInterpolator);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        animator.addUpdateListener(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ValueAnimator.AnimatorUpdateListener() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onAnimationUpdate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ValueAnimator animation)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                animatedValue = (&lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt;) animation.getAnimatedValue();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                now = SystemClock.elapsedRealtime();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                diff = now - preNow;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                preNow = now;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                Log.d(&lt;span class=&quot;string&quot;&gt;&quot;animator&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;animatedValue: &quot;&lt;/span&gt; + animatedValue + &lt;span class=&quot;string&quot;&gt;&quot; now: &quot;&lt;/span&gt; + now + &lt;span class=&quot;string&quot;&gt;&quot; diff: &quot;&lt;/span&gt; + diff);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        animator.start();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其输出值animatedValue是一个随时间变化的连续数值，就像这样 :&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="Animator" scheme="http://www.idtkm.com/tags/Animator/"/>
    
  </entry>
  
  <entry>
    <title>Matrix原理</title>
    <link href="http://www.idtkm.com/2016/10/09/14%E3%80%81Matrix/"/>
    <id>http://www.idtkm.com/2016/10/09/14、Matrix/</id>
    <published>2016-10-08T16:00:00.000Z</published>
    <updated>2017-10-15T16:01:01.572Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Idtk/Blog" target="_blank" rel="external">自定义View系列目录</a></p>
<h2 id="一、Matrix结构"><a href="#一、Matrix结构" class="headerlink" title="一、Matrix结构"></a>一、Matrix结构</h2><p>在Android开发中，矩阵是一个非常强大且有趣的工具，在之前的一篇文章中对ColorMatrix的原理进行了详细的分析，用其实现了一些简单的颜色过滤功能，这一次我们来探寻一下同样强大的Matrix，它具有更改图像图形的有趣功能。我们先来看看Matrix的结构。</p>
<a id="more"></a>
<p><img src="http://latex.codecogs.com/png.latex?$$%20\left%20[%20\begin{matrix}%20MSCALE\\_X%20&amp;%20MSKEW\\_X%20&amp;%20MTRANS\\_X%20\\\\\\%20MSKEW\\_Y%20&amp;%20MSCALE\\_Y%20&amp;%20MTRANS\\_Y%20\\\\\\%20MPERSP\\_0%20&amp;%20MPERSP\\_1%20&amp;%20MPERSP\\_2%20\end{1}%20\right%20]%20$$" alt=""></p>
<p>我们可以看到Matrix是一个3X3的矩阵。</p>
<ul>
<li>MSCALE_X、MSCALE_Y、MPERSP_2 分别表示X、Y、w(透视)的缩放</li>
<li>MSKEW_X、MSKEW_Y 分别表示X、Y的错切</li>
<li>MTRANS_X、MTRANS_Y 分别表示X、Y的平移</li>
<li>MPERSP_0、MPERSP_1 分别表示X、Y方向上的透视</li>
</ul>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>在Android的很多地方其实都使用到了Matrix的方法，比如图片、Canvas、动画等，我们这里以图片为例，像在<a href="https://github.com/Idtk/Blog/blob/master/Blog/2%E3%80%81CanvasAndValueAnimator.md" target="_blank" rel="external">Canvas与ValueAnimator</a>章节中一样，在<code>onDraw</code>函数中我们先绘制一个坐标系，然后来绘制一个矩形。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 平移画布</span></div><div class="line">canvas.translate(mWidth/<span class="number">2</span>,mHeight/<span class="number">2</span>);</div><div class="line">mPaint.setStrokeWidth(<span class="number">1</span>);<span class="comment">// 恢复画笔默认宽度</span></div><div class="line"><span class="comment">// 绘制X轴</span></div><div class="line">canvas.drawLine(-mWidth/<span class="number">2</span>*<span class="number">0.8f</span>,<span class="number">0</span>,mWidth/<span class="number">2</span>*<span class="number">0.8f</span>,<span class="number">0</span>,mPaint);</div><div class="line"><span class="comment">// 绘制Y轴</span></div><div class="line">canvas.drawLine(<span class="number">0</span>,-mHeight/<span class="number">2</span>*<span class="number">0.8f</span>,<span class="number">0</span>,mHeight/<span class="number">2</span>*<span class="number">0.8f</span>,mPaint);</div><div class="line">mPaint.setStrokeWidth(<span class="number">3</span>);</div><div class="line"><span class="comment">// 绘制X轴箭头</span></div><div class="line">canvas.drawLines(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</div><div class="line">        mWidth/<span class="number">2</span>*<span class="number">0.8f</span>,<span class="number">0</span>,mWidth/<span class="number">2</span>*<span class="number">0.8f</span>*<span class="number">0.95f</span>,-mWidth/<span class="number">2</span>*<span class="number">0.8f</span>*<span class="number">0.05f</span>,</div><div class="line">        mWidth/<span class="number">2</span>*<span class="number">0.8f</span>,<span class="number">0</span>,mWidth/<span class="number">2</span>*<span class="number">0.8f</span>*<span class="number">0.95f</span>,mWidth/<span class="number">2</span>*<span class="number">0.8f</span>*<span class="number">0.05f</span></div><div class="line">&#125;,mPaint);</div><div class="line"><span class="comment">// 绘制Y轴箭头</span></div><div class="line">canvas.drawLines(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</div><div class="line">        <span class="number">0</span>,mHeight/<span class="number">2</span>*<span class="number">0.8f</span>,mWidth/<span class="number">2</span>*<span class="number">0.8f</span>*<span class="number">0.05f</span>,mHeight/<span class="number">2</span>*<span class="number">0.8f</span>-mWidth/<span class="number">2</span>*<span class="number">0.8f</span>*<span class="number">0.05f</span>,</div><div class="line">        <span class="number">0</span>,mHeight/<span class="number">2</span>*<span class="number">0.8f</span>,-mWidth/<span class="number">2</span>*<span class="number">0.8f</span>*<span class="number">0.05f</span>,mHeight/<span class="number">2</span>*<span class="number">0.8f</span>-mWidth/<span class="number">2</span>*<span class="number">0.8f</span>*<span class="number">0.05f</span>,</div><div class="line">&#125;,mPaint);</div><div class="line"><span class="comment">// 创建矩阵</span></div><div class="line">mMatrix = <span class="keyword">new</span> Matrix();</div><div class="line"><span class="comment">/**</span></div><div class="line"> *  测试的Matrix操作</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">// 绘制图片</span></div><div class="line">canvas.drawBitmap(mBitmap,mMatrix,<span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/14/Matix0.png" alt="Matix" title="Matix"><br><br></p>
<h2 id="二、Matrix原理"><a href="#二、Matrix原理" class="headerlink" title="二、Matrix原理"></a>二、Matrix原理</h2><h3 id="1、缩放变换"><a href="#1、缩放变换" class="headerlink" title="1、缩放变换"></a>1、缩放变换</h3><p>将点的X轴和y轴方向分别缩放<img src="http://latex.codecogs.com/png.latex?$$%20k_0%20$$" alt="">和<img src="http://latex.codecogs.com/png.latex?$$%20k_1%20$$" alt="">倍。x、y的计算结果为 : </p>
<p><img src="http://latex.codecogs.com/png.latex?$$%20x%20=%20k_0\cdot%20x_0%20$$" alt=""><br><br><img src="http://latex.codecogs.com/png.latex?$$%20y%20=%20k_1\cdot%20y_0%20$$" alt=""><br></p>
<p>用矩阵表示 : <br></p>
<p><img src="http://latex.codecogs.com/png.latex?$$\left%20[%20\begin{matrix}%20x\\\y\\\1\end{1}%20\right%20]%20%20=%20\left%20[%20\begin{matrix}%20k_0%20&amp;%200%20&amp;%200%20\\\%200&amp;%20k_1%20&amp;%200%20\\\%200%20&amp;%200%20&amp;%201\end{1}%20\right%20]%20\left%20[%20\begin{matrix}%20x_0\\\y_0\\\1\end{1}%20\right%20]%20$$" alt=""></p>
<p>效果如图所示 : <br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/14/缩放.png" alt="缩放矩阵" title="缩放矩阵"><br><br></p>
<h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><p>现在我们使用<code>Matrix</code>自带的<code>setScale</code>方法 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  测试的Matrix操作</div><div class="line"> */</div><div class="line">mMatrix.setScale(<span class="number">0.5f</span>,<span class="number">0.5f</span>);</div><div class="line"></div><div class="line">Log.d(<span class="string">"TAG"</span>,mMatrix.toString());</div><div class="line"></div><div class="line"><span class="comment">// Log</span></div><div class="line">D/TAG: Matrix&#123;[<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>][<span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">0.0</span>][<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>]&#125;</div></pre></td></tr></table></figure></p>
<p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/14/Matix1.png" alt="Matix" title="Matix"><br><br></p>
<h3 id="2、错切变换"><a href="#2、错切变换" class="headerlink" title="2、错切变换"></a>2、错切变换</h3><p>错切变换的效果就是让所有点的x坐标(或者y坐标)保持不变，而对于的y坐标(或者x坐标)则按照比例发生平移。<br></p>
<h4 id="水平错切"><a href="#水平错切" class="headerlink" title="水平错切"></a>水平错切</h4><p>保持y不变，但其x坐标则按比例发生平移。x、y的计算结果为 :</p>
<p><img src="http://latex.codecogs.com/png.latex?$$%20x%20=%20x_0%20+%20k\\cdot%20y_0%20$$" alt=""><br><br><img src="http://latex.codecogs.com/png.latex?$$%20y%20=%20y_0%20$$" alt=""><br></p>
<p>用矩阵表示 : <br></p>
<p><img src="http://latex.codecogs.com/png.latex?$$\left%20[%20\begin{matrix}%20x\\\y\\\1\end{1}%20\right%20]%20%20=%20\left%20[%20\begin{matrix}%201%20&amp;%20k%20&amp;%200%20\\\%200&amp;%201%20&amp;%200%20\\\%200%20&amp;%200%20&amp;%201\end{1}%20\right%20]%20\left%20[%20\begin{matrix}%20x_0\\\y_0\\\1\end{1}%20\right%20]%20$$" alt=""></p>
<p>效果如图所示 : <br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/14/水平错切.png" alt="水平错切" title="水平错切"><br><br></p>
<h4 id="垂直错切"><a href="#垂直错切" class="headerlink" title="垂直错切"></a>垂直错切</h4><p>保持x不变，但其y坐标则按比例发生平移。x、y的计算结果为 :</p>
<p><img src="http://latex.codecogs.com/png.latex?$$%20x%20=%20x_0%20$$" alt=""><br><br><img src="http://latex.codecogs.com/png.latex?$$%20y%20=%20y_0%20+%20k\cdot%20x_0%20$$" alt=""><br></p>
<p>用矩阵表示 : <br></p>
<p><img src="http://latex.codecogs.com/png.latex?$$\left%20[%20\begin{matrix}%20x\\\y\\\1\end{1}%20\right%20]%20%20=%20\left%20[%20\begin{matrix}%201%20&amp;%200%20&amp;%200%20\\\%20k&amp;%201%20&amp;%200%20\\\%200%20&amp;%200%20&amp;%201\end{1}%20\right%20]%20\left%20[%20\begin{matrix}%20x_0\\\y_0\\\1\end{1}%20\right%20]%20$$" alt=""></p>
<p>效果如图所示 : <br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/14/垂直错切.png" alt="垂直错切" title="垂直错切"><br><br></p>
<p>当然你也可以同时进行水平错切和垂直错切的变换。</p>
<h3 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h3><p>现在我们使用<code>Matrix</code>自带的<code>setSkew</code>方法 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  测试的Matrix操作</div><div class="line"> */</div><div class="line">mMatrix.setSkew(<span class="number">0f</span>,<span class="number">0.5f</span>);</div><div class="line">Log.d(<span class="string">"TAG"</span>,mMatrix.toString());</div><div class="line"></div><div class="line"><span class="comment">// Log</span></div><div class="line">D/TAG: Matrix&#123;[<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>][<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">0.0</span>][<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>]&#125;</div></pre></td></tr></table></figure></p>
<p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/14/Matix2.png" alt="Matix" title="Matix"><br><br></p>
<h3 id="3、平移变换"><a href="#3、平移变换" class="headerlink" title="3、平移变换"></a>3、平移变换</h3><p>假设有坐标为<img src="http://latex.codecogs.com/png.latex?$$%20x_0%20,%20y_0%20$$" alt="">，将其点进行平移，移动到点<img src="http://latex.codecogs.com/png.latex?$$%20x%20,%20y%20$$" alt="">，其x、y计算结果为 : <br></p>
<p><img src="http://latex.codecogs.com/png.latex?$$%20x%20=%20x_0%20+%20\Delta%20x%20$$" alt=""><br><br><img src="http://latex.codecogs.com/png.latex?$$%20y%20=%20y_0%20+%20\Delta%20y%20$$" alt=""><br></p>
<p>用矩阵表示 : <br></p>
<p><img src="http://latex.codecogs.com/png.latex?$$\left%20[%20\begin{matrix}%20x\\\y\\\1\end{1}%20\right%20]%20%20=%20\left%20[%20\begin{matrix}%201%20&amp;%200%20&amp;%20\Delta%20x%20\\\%200&amp;%201%20&amp;%20\Delta%20y%20\\\%200%20&amp;%200%20&amp;%201\end{1}%20\right%20]%20\left%20[%20\begin{matrix}%20x_0\\\y_0\\\1\end{1}%20\right%20]%20$$" alt=""></p>
<p>效果如图所示 : <br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/14/平移.png" alt="平移" title="平移"><br><br></p>
<h3 id="使用示例-3"><a href="#使用示例-3" class="headerlink" title="使用示例"></a>使用示例</h3><p>现在我们使用<code>Matrix</code>自带的<code>setTranslate</code>方法 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  测试的Matrix操作</div><div class="line"> */</div><div class="line">mMatrix.setTranslate(-<span class="number">200</span>,-<span class="number">200</span>);</div><div class="line">Log.d(<span class="string">"TAG"</span>,mMatrix.toString());</div><div class="line"></div><div class="line"><span class="comment">// Log</span></div><div class="line">D/TAG: Matrix&#123;[<span class="number">1.0</span>, <span class="number">0.0</span>, -<span class="number">200.0</span>][<span class="number">0.0</span>, <span class="number">1.0</span>, -<span class="number">200.0</span>][<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>]&#125;</div></pre></td></tr></table></figure></p>
<p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/14/Matix3.png" alt="Matix" title="Matix"><br><br></p>
<h3 id="4、旋转变换"><a href="#4、旋转变换" class="headerlink" title="4、旋转变换"></a>4、旋转变换</h3><p>假设有一点坐标为<img src="http://latex.codecogs.com/png.latex?$$%20x_0,y_0%20$$" alt="">，距离原点为r，与x轴方向的夹角为α，绕原点旋转θ后，变换为点<img src="http://latex.codecogs.com/png.latex?$$%20x,y%20$$" alt="">，其变换前后各点计算结果为 : <br></p>
<p><img src="http://latex.codecogs.com/png.latex?$$%20x_0%20=%20r\cdot\cos%20\alpha%20$$" alt=""><br><br><img src="http://latex.codecogs.com/png.latex?$$%20y_0%20=%20r\cdot\sin%20\alpha%20$$" alt=""><br><br><img src="http://latex.codecogs.com/png.latex?$$%20x%20=%20r%20\cdot\cos%20\left(%20\alpha%20+%20\theta\right%20" alt="">%20=%20r%20\cdot\cos\alpha\cos\theta%20-%20r%20\cdot\sin\alpha\sin\theta%20=%20x_0\cos\theta%20-%20y_0\sin\theta$$)<br><br><img src="http://latex.codecogs.com/png.latex?$$%20y%20=%20r%20\cdot%20\sin%20\left(%20\alpha%20+%20\theta\right%20" alt="">%20=%20r%20\cdot\sin\alpha\cos\theta%20+%20r%20\cdot\cos\alpha\sin\theta%20=%20y_0\cos\theta%20+%20x_0\sin\theta$$)<br></p>
<p>用矩阵表示为 : <br></p>
<p><img src="http://latex.codecogs.com/png.latex?$$\left%20[%20\begin{matrix}%20x\\\y\\\1\end{1}%20\right%20]%20%20=%20\left%20[%20\begin{matrix}%20\cos\theta%20&amp;%20-\sin\theta%20&amp;%200%20\\\%20\sin\theta&amp;%20\cos\theta%20&amp;%200%20\\\%200%20&amp;%200%20&amp;%201\end{1}%20\right%20]%20\left%20[%20\begin{matrix}%20x_0\\\y_0\\\1\end{1}%20\right%20]%20$$" alt=""></p>
<p>效果如图所示 : <br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/14/旋转.png" alt="旋转" title="旋转"><br><br></p>
<h3 id="使用示例-4"><a href="#使用示例-4" class="headerlink" title="使用示例"></a>使用示例</h3><p>现在我们使用<code>Matrix</code>自带的<code>setRotate</code>方法 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  测试的Matrix操作</div><div class="line"> */</div><div class="line">mMatrix.setRotate(<span class="number">180</span>);</div><div class="line">Log.d(<span class="string">"TAG"</span>,mMatrix.toString());</div><div class="line"></div><div class="line"><span class="comment">// Log</span></div><div class="line">D/TAG: Matrix&#123;[-<span class="number">1.0</span>, -<span class="number">0.0</span>, <span class="number">0.0</span>][<span class="number">0.0</span>, -<span class="number">1.0</span>, <span class="number">0.0</span>][<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>]&#125;</div></pre></td></tr></table></figure></p>
<p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/14/Matix4.png" alt="Matix" title="Matix"><br><br></p>
<h3 id="5、透视变换"><a href="#5、透视变换" class="headerlink" title="5、透视变换"></a>5、透视变换</h3><p>我们在之前的变换中，一直没有说到最后一行的三个参数<code>MPERSP_0、MPERSP_1、MPERSP_2</code>，这里我们来稍微聊聊这三个参数所表示的透视。我们一般在图像中的一个点将使用如下方式进行表示(x, y, w),而Android中的二维矩阵计算是基于齐次坐标的，齐次坐标要求w的值为1，所以这个点的表示方法就变化为(x/w, y/w, 1)。<br><br>透视变换的效果其实类似于投影机的方式，我们看下w=3时，坐标(15,21,3)的效果 : <br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/14/透视1.png" alt="透视" title="透视"><br><br></p>
<p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/14/透视3.png" alt="透视" title="透视"><br><br></p>
<p><br><br>现在看下(15,21,3)计算出的齐次坐标系坐标(5,7,1)的效果 : <br></p>
<p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/14/透视2.png" alt="透视" title="透视"><br><br></p>
<p>根据这个规则，也就解释了我们在使用过程中修改<code>MPERSP_2</code>参数时，图像会发生的类似缩放的效果，其实就是透视变换的效果。<br></p>
<h3 id="使用示例-5"><a href="#使用示例-5" class="headerlink" title="使用示例"></a>使用示例</h3><p>现在我们使用<code>Matrix</code>自带的<code>setValues</code>方法 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  测试的Matrix操作</div><div class="line"> */</div><div class="line">mMatrix.setValues(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.5f</span>&#125;);</div><div class="line">Log.d(<span class="string">"TAG"</span>,mMatrix.toString());</div><div class="line"></div><div class="line"><span class="comment">// Log</span></div><div class="line">D/TAG: Matrix&#123;[<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>][<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>][<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.5</span>]&#125;</div></pre></td></tr></table></figure></p>
<p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/14/Matix5.png" alt="Matix" title="Matix"><br><br></p>
<h2 id="三、Matrix前乘与后乘"><a href="#三、Matrix前乘与后乘" class="headerlink" title="三、Matrix前乘与后乘"></a>三、Matrix前乘与后乘</h2><p>Matrix前乘与后乘的情况跟我在之前的文章<a href="http://www.idtkm.com/customview/cutomview13/">ColorMatrix详解</a>中<strong>ColorMatrix相乘</strong>章节所描述的基本相同。<br></p>
<h3 id="前乘"><a href="#前乘" class="headerlink" title="前乘"></a>前乘</h3><p>前乘相当于，当前矩阵乘以输入的矩阵<img src="http://latex.codecogs.com/png.latex?$$%20M&#39;%20=%20M%20\cdot%20S%20$$" alt=""><br></p>
<p>示例如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mMatrix.reset();</div><div class="line">mMatrix.preScale(sx,sy);</div><div class="line">mMatrix.preTranslate(tx,ty);</div></pre></td></tr></table></figure>
<p>用矩阵表示为 : </p>
<p><img src="http://latex.codecogs.com/png.latex?$$\left%20[%20\begin{matrix}%20&amp;%20&amp;\\\%20&amp;%20Result%20&amp;%20Matrix%20&amp;\\\%20&amp;%20&amp;%20\end{1}%20\right%20]%20=%20\left%20[%20\begin{matrix}%20&amp;%20&amp;\\\%20&amp;%20Initial%20&amp;%20Matrix%20&amp;\\\%20&amp;%20&amp;%20\end{1}%20\right%20]%20%20\left%20[%20\begin{matrix}%20sx%20&amp;%200%20&amp;%200%20\\\%200&amp;%20sy%20&amp;%200%20\\\%200%20&amp;%200%20&amp;%201\end{1}%20\right%20]%20%20\left%20[%20\begin{matrix}%201%20&amp;%200%20&amp;%20tx%20\\\%200&amp;%201%20&amp;%20ty%20\\\%200%20&amp;%200%20&amp;%201\end{1}%20\right%20]%20$$" alt=""></p>
<h3 id="后乘"><a href="#后乘" class="headerlink" title="后乘"></a>后乘</h3><p>后乘相当于，输入的矩阵乘以当前矩阵<img src="http://latex.codecogs.com/png.latex?$$%20M&#39;%20=%20S%20\cdot%20M%20$$" alt=""><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mMatrix.reset();</div><div class="line">mMatrix.postScale(sx,sy);</div><div class="line">mMatrix.postTranslate(tx,ty);</div></pre></td></tr></table></figure>
<p><img src="http://latex.codecogs.com/png.latex?$$\left%20[%20\begin{matrix}%20&amp;%20&amp;\\\%20&amp;%20Result%20&amp;%20Matrix%20&amp;\\\%20&amp;%20&amp;%20\end{1}%20\right%20]%20=%20\left%20[%20\begin{matrix}%201%20&amp;%200%20&amp;%20tx%20\\\%200&amp;%201%20&amp;%20ty%20\\\%200%20&amp;%200%20&amp;%201\end{1}%20\right%20]%20%20\left%20[%20\begin{matrix}%20sx%20&amp;%200%20&amp;%200%20\\\%200&amp;%20sy%20&amp;%200%20\\\%200%20&amp;%200%20&amp;%201\end{1}%20\right%20]%20\left%20[%20\begin{matrix}%20&amp;%20&amp;\\\%20&amp;%20Initial%20&amp;%20Matrix%20&amp;\\\%20&amp;%20&amp;%20\end{1}%20\right%20]%20%20$$" alt=""></p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本文深入分析了Matrix的原理，并讲解了其常用方法和前后乘的方法。如果在阅读过程中，有任何疑问与问题，欢迎与我联系。<br><br><strong>博客:www.idtkm.com</strong><br><br><strong>GitHub:<a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><br><strong>微博:<a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><br><strong>邮箱:IdtkMa@gmail.com</strong><br><br><br></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.android.com/reference/android/graphics/Matrix.html" target="_blank" rel="external">Matrix</a><br><br><a href="http://www.cnblogs.com/qiengo/archive/2012/06/30/2570874.html#code" target="_blank" rel="external">Android Matrix</a><br><br><a href="http://blog.csdn.net/linmiansheng/article/details/18820599" target="_blank" rel="external">Android中关于矩阵（Matrix）前乘后乘的一些认识</a><br><br><a href="https://oncemore2020.github.io/blog/homogeneous/" target="_blank" rel="external">齐次坐标系入门级思考</a><br><br><a href="http://www.jianshu.com/p/7e701d7bfd79" target="_blank" rel="external">次坐标和投影</a><br><br><a href="https://zh.wikipedia.org/wiki/%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5" target="_blank" rel="external">变换矩阵</a><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Idtk/Blog&quot;&gt;自定义View系列目录&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、Matrix结构&quot;&gt;&lt;a href=&quot;#一、Matrix结构&quot; class=&quot;headerlink&quot; title=&quot;一、Matrix结构&quot;&gt;&lt;/a&gt;一、Matrix结构&lt;/h2&gt;&lt;p&gt;在Android开发中，矩阵是一个非常强大且有趣的工具，在之前的一篇文章中对ColorMatrix的原理进行了详细的分析，用其实现了一些简单的颜色过滤功能，这一次我们来探寻一下同样强大的Matrix，它具有更改图像图形的有趣功能。我们先来看看Matrix的结构。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="CustomView" scheme="http://www.idtkm.com/tags/CustomView/"/>
    
  </entry>
  
  <entry>
    <title>ColorMatrix详解</title>
    <link href="http://www.idtkm.com/2016/09/18/13%E3%80%81ColorMatrix/"/>
    <id>http://www.idtkm.com/2016/09/18/13、ColorMatrix/</id>
    <published>2016-09-17T16:00:00.000Z</published>
    <updated>2017-10-15T16:01:08.748Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Idtk/Blog" target="_blank" rel="external">自定义View系列目录</a></p>
<p><strong>涉及方法</strong><br></p>
<table>
<thead>
<tr>
<th>类别</th>
<th style="text-align:center">API</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>旋转</td>
<td style="text-align:center">setRotate</td>
<td>设置(非输入轴颜色的)色调</td>
</tr>
<tr>
<td>饱和度</td>
<td style="text-align:center">setSaturation</td>
<td>设置饱和度</td>
</tr>
<tr>
<td>缩放</td>
<td style="text-align:center">setScale</td>
<td>三原色的取值的比例</td>
</tr>
<tr>
<td>设置</td>
<td style="text-align:center">set、setConcat</td>
<td>设置颜色矩阵、两个颜色矩阵的乘积</td>
</tr>
<tr>
<td>重置</td>
<td style="text-align:center">reset</td>
<td>重置颜色矩阵为初始状态</td>
</tr>
<tr>
<td>矩阵运算</td>
<td style="text-align:center">preConcat、postConcat</td>
<td>颜色矩阵的前乘、后乘</td>
</tr>
</tbody>
</table>
<h2 id="一、颜色矩阵"><a href="#一、颜色矩阵" class="headerlink" title="一、颜色矩阵"></a>一、颜色矩阵</h2><p>颜色矩阵是一个用来表示三原色和透明度的4x5的矩阵，表示为一个数组的形式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[ a, b, c, d, e,</div><div class="line">    f, g, h, i, j,</div><div class="line">    k, l, m, n, o,</div><div class="line">    p, q, r, s, t ]</div></pre></td></tr></table></figure></p>
<p>一个颜色则使用<code>[R, G, B, A]</code>的方式进行表示，所以矩阵与颜色的计算方式则为<br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/颜色矩阵计算.png" alt="颜色矩阵计算" title="颜色矩阵计算"><br><br></p>
<p>从上述的公式可以看出,颜色矩阵的功能划分如下<br></p>
<ul>
<li><code>a, b, c, d, e</code> 表示三原色中的红色</li>
<li><code>f, g, h, i, j</code> 表示三原色中的绿色</li>
<li><code>k, l, m, n, o</code> 表示三原色中的蓝色</li>
<li><code>p, q, r, s, t</code> 表示颜色的透明度</li>
<li>第五列用于表示颜色的偏移量</li>
</ul>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><a id="more"></a>
<p>首先我们在不改变初始矩阵的情况下，来看一下图片的效果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ColorMatrix mColorMatrix;</div><div class="line"><span class="keyword">private</span> Paint mPaint;</div><div class="line"><span class="keyword">private</span> Bitmap oldBitmap;</div><div class="line"></div><div class="line">mColorMatrix = <span class="keyword">new</span> ColorMatrix();</div><div class="line">mPaint = <span class="keyword">new</span> Paint();</div><div class="line"><span class="comment">// 设置画笔的颜色过滤器</span></div><div class="line">mPaint.setColorFilter(<span class="keyword">new</span> ColorMatrixColorFilter(mColorMatrix));</div><div class="line">Log.d(<span class="string">"TAG"</span>, Arrays.toString(mColorMatrix.getArray()));</div><div class="line"><span class="comment">// 创建Bitmap</span></div><div class="line">oldBitmap = BitmapFactory.decodeResource(getResources(),R.drawable.header);</div><div class="line"></div><div class="line"><span class="comment">// 在画布上显示图片</span></div><div class="line">canvas.drawBitmap(oldBitmap,<span class="number">0</span>,<span class="number">0</span>,mPaint);</div><div class="line"></div><div class="line"><span class="comment">// Log</span></div><div class="line">TAG: [<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>]</div></pre></td></tr></table></figure></p>
<p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/初始矩阵.png" alt="初始矩阵" title="初始矩阵"><br><br></p>
<p>现在我们新建一个矩阵，使用set方法来使用这个矩阵，改变图片的颜色<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mColorMatrix.set(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</div><div class="line">        <span class="number">1</span>,<span class="number">0.5f</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></div><div class="line">        ,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></div><div class="line">        ,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span></div><div class="line">        ,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;);</div></pre></td></tr></table></figure></p>
<p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/0.5红矩阵.png" alt="红矩阵" title="红矩阵"><br><br></p>
<h2 id="二、常用方法"><a href="#二、常用方法" class="headerlink" title="二、常用方法"></a>二、常用方法</h2><h3 id="1、旋转"><a href="#1、旋转" class="headerlink" title="1、旋转"></a>1、旋转</h3><p>API如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 用于色调的旋转运算</div><div class="line">* axis=0 表示色调围绕红色进行旋转</div><div class="line">* axis=1 表示色调围绕绿色进行旋转</div><div class="line">* axis=2 表示色调围绕蓝色进行旋转</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRotate</span><span class="params">(<span class="keyword">int</span> axis, <span class="keyword">float</span> degrees)</span></span></div></pre></td></tr></table></figure>
<p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/三原色坐标系.png" alt="三原色坐标系" title="三原色坐标系"><br><br></p>
<h4 id="a、围绕红色轴旋转"><a href="#a、围绕红色轴旋转" class="headerlink" title="a、围绕红色轴旋转"></a>a、围绕红色轴旋转</h4><p>我们可以根据三原色来建立一个三维<strong>向量</strong>坐标系，当围绕红色旋转时，我们将红色虚化为一个点，绿色为横坐标，蓝色为纵坐标，旋转θ°。<br></p>
<p>坐标系示例<br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/红色坐标系.png" alt="红色坐标系" title="红色坐标系"><br><br></p>
<p>根据平行四边形法则R、G、B、A各值计算结果:</p>
<p><img src="http://latex.codecogs.com/png.latex?$$%20R%20=%20R&#39;%20$$" alt=""><br><br><img src="http://latex.codecogs.com/png.latex?$$%20G%20=%20G&#39;\cdot%20\cos\theta%20+%20B&#39;\cdot%20\sin\theta%20$$" alt=""><br><br><img src="http://latex.codecogs.com/png.latex?$$%20B%20=%20-G&#39;\cdot%20\sin\theta%20+%20B&#39;\cdot%20\cos\theta%20$$" alt=""><br><br><img src="http://latex.codecogs.com/png.latex?$$%20A%20=%20A&#39;%20$$" alt=""></p>
<p>矩阵表示:</p>
<p><img src="http://latex.codecogs.com/png.latex?$$\left%20[%20\begin{matrix}%20R\\\G\\\B\\\A\end{1}%20\right%20]%20%20=%20\left%20[%20\begin{matrix}%20%201%20&amp;%200%20&amp;%200%20&amp;%200%20&amp;%200%20\\\%200%20&amp;%20\cos\theta%20&amp;%20\sin\theta%20&amp;%200%20&amp;%200\\\%200%20&amp;%20-\sin\theta%20&amp;%20\cos\theta%20&amp;%200%20&amp;%200%20\\\%200%20&amp;%200%20&amp;%200%20&amp;%201%20&amp;%200\end{1}%20\right%20]%20\left%20[%20\begin{matrix}%20R&#39;\\\G&#39;\\\B&#39;\\\A&#39;\end{1}%20\right%20]%20$$" alt=""></p>
<h4 id="b、围绕绿色轴旋转"><a href="#b、围绕绿色轴旋转" class="headerlink" title="b、围绕绿色轴旋转"></a>b、围绕绿色轴旋转</h4><p>绿色虚化为一个点，蓝色为横坐标轴，红色为纵坐标轴，旋转θ°。<br><br>坐标系示例<br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/绿色坐标系.png" alt="绿色坐标系" title="绿色坐标系"><br><br></p>
<p>根据平行四边形法则R、G、B、A各值计算结果:</p>
<p><img src="http://latex.codecogs.com/png.latex?$$%20R%20=%20R&#39;\cdot%20\cos\theta-B&#39;\cdot%20\sin\theta%20$$" alt=""><br><br><img src="http://latex.codecogs.com/png.latex?$$%20G%20=%20G&#39;%20$$" alt=""><br><br><img src="http://latex.codecogs.com/png.latex?$$%20B%20=%20R&#39;\cdot%20\sin\theta%20+%20B&#39;\cdot%20\cos\theta%20$$" alt=""><br><br><img src="http://latex.codecogs.com/png.latex?$$%20A%20=%20A&#39;%20$$" alt=""></p>
<p>矩阵表示:</p>
<p><img src="http://latex.codecogs.com/png.latex?$$\left%20[%20\begin{matrix}%20R\\\G\\\B\\\A\end{1}%20\right%20]%20%20=%20\left%20[%20\begin{matrix}%20%20\cos\theta%20&amp;%200%20&amp;%20-\sin\theta%20&amp;%200%20&amp;%200%20\\\%200%20&amp;%201%20&amp;%200%20&amp;%200%20&amp;%200\\\%20\sin\theta%20&amp;%200%20&amp;%20\cos\theta%20&amp;%200%20&amp;%200%20\\\%200%20&amp;%200%20&amp;%200%20&amp;%201%20&amp;%200\end{1}%20\right%20]%20\left%20[%20\begin{matrix}%20R&#39;\\\G&#39;\\\B&#39;\\\A&#39;\end{1}%20\right%20]%20$$" alt=""></p>
<h4 id="c、围绕蓝色轴旋转"><a href="#c、围绕蓝色轴旋转" class="headerlink" title="c、围绕蓝色轴旋转"></a>c、围绕蓝色轴旋转</h4><p>蓝色虚化为一个点，红色为横坐标轴，绿色为纵坐标轴，旋转θ°。<br><br>坐标系示例</p>
<p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/蓝色坐标系.png" alt="蓝色坐标系" title="蓝色坐标系"><br><br></p>
<p>根据平行四边形法则R、G、B、A各值计算结果:</p>
<p><img src="http://latex.codecogs.com/png.latex?$$%20R%20=%20R&#39;\cdot%20\cos\theta+G&#39;\cdot%20\sin\theta%20$$" alt=""><br><br><img src="http://latex.codecogs.com/png.latex?$$%20G%20=%20-R&#39;\cdot%20\sin\theta+G&#39;\cdot%20\cos\theta%20$$" alt=""><br><br><img src="http://latex.codecogs.com/png.latex?$$%20B%20=%20B&#39;%20$$" alt=""><br><br><img src="http://latex.codecogs.com/png.latex?$$%20A%20=%20A&#39;%20$$" alt=""></p>
<p>矩阵表示:</p>
<p><img src="http://latex.codecogs.com/png.latex?$$\left%20[%20\begin{matrix}%20R\\\G\\\B\\\A\end{1}%20\right%20]%20%20=%20\left%20[%20\begin{matrix}%20%20\cos\theta%20&amp;%20\sin\theta%20&amp;%200%20&amp;%200%20&amp;%200%20\\\%20-\sin\theta%20&amp;%20\cos\theta%20&amp;%200%20&amp;%200%20&amp;%200\\\%200%20&amp;%200%20&amp;%201%20&amp;%200%20&amp;%200%20\\\%200%20&amp;%200%20&amp;%200%20&amp;%201%20&amp;%200\end{1}%20\right%20]%20\left%20[%20\begin{matrix}%20R&#39;\\\G&#39;\\\B&#39;\\\A&#39;\end{1}%20\right%20]%20$$" alt=""></p>
<h4 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h4><p>这里设置色调围绕红色轴旋转90°<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 旋转绿色、蓝色</span></div><div class="line">mColorMatrix.setRotate(<span class="number">0</span>,<span class="number">90</span>);</div><div class="line"></div><div class="line"><span class="comment">// Log</span></div><div class="line">D/TAG: [<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, -<span class="number">4.371139E-8</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, -<span class="number">1.0</span>, -<span class="number">4.371139E-8</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</div><div class="line">        <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>]</div></pre></td></tr></table></figure></p>
<p>从Log中我们可以看出，其结果也验证了我们的上述理论，图片效果如下:</p>
<p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/旋转矩阵.png" alt="旋转矩阵" title="旋转矩阵"><br><br></p>
<h3 id="2、缩放"><a href="#2、缩放" class="headerlink" title="2、缩放"></a>2、缩放</h3><p>API如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* rScale 表示红色的数值的缩放比例</div><div class="line">* gScale 表示绿色的数值的缩放比例</div><div class="line">* bScale 表示蓝色的数值的缩放比例</div><div class="line">* aScale 表示透明度的数值的缩放比例</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScale</span><span class="params">(<span class="keyword">float</span> rScale, <span class="keyword">float</span> gScale, <span class="keyword">float</span> bScale,<span class="keyword">float</span> aScale)</span></span></div></pre></td></tr></table></figure>
<p>ColorMatrix的缩放方法，其实就是根据矩阵的运算规则，对<code>R、G、B、A</code>的数值分别进行缩放操作，当然在操作之前，会对现有的ColorMatrix进行初始化操作。<br></p>
<p>R、G、B、A各值计算结果:</p>
<p><img src="http://latex.codecogs.com/png.latex?$$%20R%20=%20R&#39;\cdot%20rScale%20$$" alt=""><br><br><img src="http://latex.codecogs.com/png.latex?$$%20G%20=%20G&#39;\cdot%20gScale%20$$" alt=""><br><br><img src="http://latex.codecogs.com/png.latex?$$%20B%20=%20B&#39;\cdot%20bScale%20$$" alt=""><br><br><img src="http://latex.codecogs.com/png.latex?$$%20A%20=%20A&#39;\cdot%20aScale%20$$" alt=""></p>
<p>矩阵表示:</p>
<p><img src="http://latex.codecogs.com/png.latex?$$\left%20[%20\begin{matrix}%20R\\\G\\\B\\\A\end{1}%20\right%20]%20%20=%20\left%20[%20\begin{matrix}%20%20rScale%20&amp;%200%20&amp;%200%20&amp;%200%20&amp;%200%20\\\%200%20&amp;%20gScale%20&amp;%200%20&amp;%200%20&amp;%200\\\%200%20&amp;%200%20&amp;%20bScale%20&amp;%200%20&amp;%200%20\\\%200%20&amp;%200%20&amp;%200%20&amp;%20aScale%20&amp;%200\end{1}%20\right%20]%20\left%20[%20\begin{matrix}%20R&#39;\\\G&#39;\\\B&#39;\\\A&#39;\end{1}%20\right%20]%20$$" alt=""></p>
<h4 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h4><p>这里设置，所有的缩放比例为1.1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置缩放比例</span></div><div class="line">mColorMatrix.setScale(<span class="number">1.1f</span>,<span class="number">1.1f</span>,<span class="number">1.1f</span>,<span class="number">1.1f</span>);</div><div class="line"></div><div class="line"><span class="comment">// Log</span></div><div class="line">D/TAG: [<span class="number">1.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.1</span>, <span class="number">0.0</span>]</div></pre></td></tr></table></figure></p>
<p>从Log中我们可以看出，其结果也验证了对于缩放的理解，图片效果如下 :</p>
<p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/缩放矩阵.png" alt="缩放矩阵" title="缩放矩阵"><br><br></p>
<p>我们还可以制作一个颜色通道，比如红色 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 红色通道</span></div><div class="line">mColorMatrix.setScale(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">// Log</span></div><div class="line">D/TAG: [<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>]</div></pre></td></tr></table></figure></p>
<p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/红色通道.png" alt="红色通道" title="红色通道"><br><br></p>
<h3 id="3、饱和度"><a href="#3、饱和度" class="headerlink" title="3、饱和度"></a>3、饱和度</h3><p>API如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 设置矩阵颜色的饱和度</div><div class="line">*</div><div class="line">* sat 0表示灰度、1表示本身</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSaturation</span><span class="params">(<span class="keyword">float</span> sat)</span></span></div></pre></td></tr></table></figure>
<p><code>setSaturation</code>方法可以根据一定比例，整体的增加或者减少颜色的饱和度，当设置0时，表示灰度图片；当设置为1时，表示颜色不变化。<br></p>
<p>灰度图片的去色原理：只要把RGB的三色通道的数值设置为一样，即<code>R=G=B</code>,那么图像就变成了灰色，同时为了保证图像的亮度，需要使同一个通道中的<code>R+G+B</code>的结果接近1。</p>
<ul>
<li>在matlab中按照 0.2989 R，0.5870 G 和 0.1140 B 的比例构成像素灰度值</li>
<li>在OpenCV中按照 0.299 R， 0.587 G 和 0.114 B 的比例构成像素灰度值</li>
<li>在Android中按照0.213 R，0.715 G 和 0.072 B 的比例构成像素灰度值</li>
</ul>
<h3 id="使用示例-3"><a href="#使用示例-3" class="headerlink" title="使用示例"></a>使用示例</h3><p>这里设置饱和度为0，测试下灰度效果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 灰度</span></div><div class="line">mColorMatrix.setSaturation(<span class="number">0f</span>);</div><div class="line"></div><div class="line"><span class="comment">// Log</span></div><div class="line">D/TAG: [<span class="number">0.213</span>, <span class="number">0.715</span>, <span class="number">0.072</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.213</span>, <span class="number">0.715</span>, <span class="number">0.072</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.213</span>, <span class="number">0.715</span>, <span class="number">0.072</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</div><div class="line">        <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>]</div></pre></td></tr></table></figure></p>
<p><br><br>打印出的Log也验证了上述对于图片灰度的说明，当然源码中还有对于饱和度从0%——100%的计算，感兴趣的同学可以查看以下源码。灰度图片效果如下:</p>
<p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/饱和度矩阵.png" alt="饱和度矩阵" title="饱和度矩阵"><br><br></p>
<h2 id="三、ColorMatrix相乘"><a href="#三、ColorMatrix相乘" class="headerlink" title="三、ColorMatrix相乘"></a>三、ColorMatrix相乘</h2><h3 id="1、设置"><a href="#1、设置" class="headerlink" title="1、设置"></a>1、设置</h3><p>设置新的矩阵覆盖之前的内容，可以设置一个单独的矩阵，也可以设置两个矩阵的相乘。API如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ColorMatrix src)</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">float</span>[] src)</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConcat</span><span class="params">(ColorMatrix matA, ColorMatrix matB)</span></div></pre></td></tr></table></figure>
<p>这里主要说一下<code>setConcat</code>方法，此方法表示两个ColorMatrix相乘<br><br><img src="http://latex.codecogs.com/png.latex?$$%20M%20=%20M_A%20\cdot%20M_B%20$$" alt=""><br><br>矩阵表示为:<br></p>
<p><img src="http://latex.codecogs.com/png.latex?$$\left%20[%20\begin{matrix}%20%20&amp;%20&amp;%20\\\%20&amp;%20Result%20&amp;%20ColorMatrix%20&amp;%20\\\%20&amp;%20&amp;\end{1}%20\right%20]%20%20=%20\left%20[%20\begin{matrix}%20%20a_0%20&amp;%20a_1%20&amp;%20a_2%20&amp;%20a_3%20&amp;%20a_4%20\\\%20a_5%20&amp;%20a_6%20&amp;%20a_7%20&amp;%20a_8%20&amp;%20a_9%20\\\%20a_1_0%20&amp;%20a_1_1%20&amp;%20a_1_2%20&amp;%20a_1_3%20&amp;%20a_1_4%20\\\%20a_1_5%20&amp;%20a_1_6%20&amp;%20a_1_7%20&amp;%20a_1_8%20&amp;%20a_1_9\end{1}%20\right%20]%20\left%20[%20\begin{matrix}%20%20b_0%20&amp;%20b_1%20&amp;%20b_2%20&amp;%20b_3%20&amp;%20b_4%20\\\%20b_5%20&amp;%20b_6%20&amp;%20b_7%20&amp;%20b_8%20&amp;%20b_9%20\\\%20b_1_0%20&amp;%20b_1_1%20&amp;%20b_1_2%20&amp;%20b_1_3%20&amp;%20b_1_4%20\\\%20b_1_5%20&amp;%20b_1_6%20&amp;%20b_1_7%20&amp;%20b_1_8%20&amp;%20b_1_9\end{1}%20\right%20]%20$$" alt=""></p>
<h4 id="使用示例-4"><a href="#使用示例-4" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mColorMatrixA = <span class="keyword">new</span> ColorMatrix(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</div><div class="line">        <span class="number">1</span>,<span class="number">0.3f</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></div><div class="line">        ,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.3f</span>,<span class="number">0</span>,<span class="number">0.1f</span></div><div class="line">        ,<span class="number">0</span>,<span class="number">0.6f</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span></div><div class="line">        ,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span></div><div class="line">&#125;);</div><div class="line">mColorMatrixB = <span class="keyword">new</span> ColorMatrix(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</div><div class="line">        <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span></div><div class="line">        ,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.5f</span></div><div class="line">        ,<span class="number">0.1f</span>,<span class="number">0.9f</span>,<span class="number">0.8f</span>,<span class="number">0</span>,<span class="number">0</span></div><div class="line">        ,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.8f</span></div><div class="line">&#125;);</div><div class="line">mColorMatrix = <span class="keyword">new</span> ColorMatrix(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</div><div class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></div><div class="line">        ,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></div><div class="line">        ,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></div><div class="line">        ,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">mColorMatrix.setConcat(mColorMatrixA,mColorMatrixB);</div><div class="line"></div><div class="line">Log.d(<span class="string">"TAGA"</span>, Arrays.toString(mColorMatrixA.getArray()));</div><div class="line">Log.d(<span class="string">"TAGB"</span>, Arrays.toString(mColorMatrixB.getArray()));</div><div class="line">Log.d(<span class="string">"TAGAB"</span>, Arrays.toString(mColorMatrix.getArray()));</div><div class="line"></div><div class="line"><span class="comment">// Log</span></div><div class="line">D/TAGA: [<span class="number">1.0</span>, <span class="number">0.3</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.3</span>, <span class="number">0.0</span>, <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.6</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>]</div><div class="line">D/TAGB: [<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">0.1</span>, <span class="number">0.9</span>, <span class="number">0.8</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.8</span>]</div><div class="line">D/TAGAB: [<span class="number">1.0</span>, <span class="number">0.3</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.15</span>, <span class="number">0.030000001</span>, <span class="number">1.27</span>, <span class="number">0.24000001</span>, <span class="number">0.0</span>, <span class="number">0.6</span>, <span class="number">0.1</span>, <span class="number">1.5</span>, <span class="number">0.8</span>, <span class="number">0.0</span>, <span class="number">0.3</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.8</span>]</div></pre></td></tr></table></figure>
<h3 id="2、前乘"><a href="#2、前乘" class="headerlink" title="2、前乘"></a>2、前乘</h3><p>前乘相当于，当前矩阵乘以输入的矩阵<br><br><br><img src="http://latex.codecogs.com/png.latex?$$%20M&#39;%20=%20M%20\cdot%20S%20$$" alt=""><br><br>这里看一下源码，可以更容易的理解:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 逻辑上相当于调用setConcat(this, prematrix)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preConcat</span><span class="params">(ColorMatrix prematrix)</span> </span>&#123;</div><div class="line">    setConcat(<span class="keyword">this</span>, prematrix);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从源码上可以明显的看出前乘的规则，preConcat(prematrix)方法相当于调用setConcat(this, prematrix)方法</p>
<h4 id="使用示例-5"><a href="#使用示例-5" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mColorMatrix.reset();</div><div class="line">mColorMatrix.preConcat(mColorMatrixA);</div><div class="line">mColorMatrix.preConcat(mColorMatrixB);</div></pre></td></tr></table></figure>
<p>上例多次调用preConcat，则相当于<br></p>
<p><img src="http://latex.codecogs.com/png.latex?$$\left%20[%20\begin{matrix}%20%20&amp;%20&amp;%20\\\%20&amp;%20Result%20&amp;%20ColorMatrix%20&amp;%20\\\%20&amp;%20&amp;\end{1}%20\right%20]%20%20=%20\left%20[%20\begin{matrix}%20%20&amp;%20&amp;%20\\\%20&amp;%20Initial%20&amp;%20ColorMatrix%20&amp;%20\\\%20&amp;%20&amp;\end{1}%20\right%20]%20\left%20[%20\begin{matrix}%20%20a_0%20&amp;%20a_1%20&amp;%20a_2%20&amp;%20a_3%20&amp;%20a_4%20\\\%20a_5%20&amp;%20a_6%20&amp;%20a_7%20&amp;%20a_8%20&amp;%20a_9%20\\\%20a_1_0%20&amp;%20a_1_1%20&amp;%20a_1_2%20&amp;%20a_1_3%20&amp;%20a_1_4%20\\\%20a_1_5%20&amp;%20a_1_6%20&amp;%20a_1_7%20&amp;%20a_1_8%20&amp;%20a_1_9\end{1}%20\right%20]%20\left%20[%20\begin{matrix}%20%20b_0%20&amp;%20b_1%20&amp;%20b_2%20&amp;%20b_3%20&amp;%20b_4%20\\\%20b_5%20&amp;%20b_6%20&amp;%20b_7%20&amp;%20b_8%20&amp;%20b_9%20\\\%20b_1_0%20&amp;%20b_1_1%20&amp;%20b_1_2%20&amp;%20b_1_3%20&amp;%20b_1_4%20\\\%20b_1_5%20&amp;%20b_1_6%20&amp;%20b_1_7%20&amp;%20b_1_8%20&amp;%20b_1_9\end{1}%20\right%20]%20$$" alt=""></p>
<h3 id="3、后乘"><a href="#3、后乘" class="headerlink" title="3、后乘"></a>3、后乘</h3><p>后乘相当于，输入的矩阵乘以当前矩阵<br><br><br><img src="http://latex.codecogs.com/png.latex?$$%20M&#39;%20=%20S%20\cdot%20M%20$$" alt=""><br><br>这里看一下源码，可以更容易的理解:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 逻辑上相当于调用setConcat(postmatrix, this)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postConcat</span><span class="params">(ColorMatrix postmatrix)</span> </span>&#123;</div><div class="line">    setConcat(postmatrix, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从源码上可以明显的看出前乘的规则,postConcat(prematrix)方法相当于调用setConcat(postmatrix, this)</p>
<h1 id="使用示例-6"><a href="#使用示例-6" class="headerlink" title="使用示例"></a>使用示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mColorMatrix.reset();</div><div class="line">mColorMatrix.postConcat(mColorMatrixA);</div><div class="line">mColorMatrix.postConcat(mColorMatrixB);</div></pre></td></tr></table></figure>
<p>上例多次调用postConcat，因为矩阵满足交换律，则相当于<br></p>
<p><img src="http://latex.codecogs.com/png.latex?$$\left%20[%20\begin{matrix}%20%20&amp;%20&amp;%20\\\%20&amp;%20Result%20&amp;%20ColorMatrix%20&amp;%20\\\%20&amp;%20&amp;\end{1}%20\right%20]%20%20=%20\left%20[%20\begin{matrix}%20%20b_0%20&amp;%20b_1%20&amp;%20b_2%20&amp;%20b_3%20&amp;%20b_4%20\\\%20b_5%20&amp;%20b_6%20&amp;%20b_7%20&amp;%20b_8%20&amp;%20b_9%20\\\%20b_1_0%20&amp;%20b_1_1%20&amp;%20b_1_2%20&amp;%20b_1_3%20&amp;%20b_1_4%20\\\%20b_1_5%20&amp;%20b_1_6%20&amp;%20b_1_7%20&amp;%20b_1_8%20&amp;%20b_1_9\end{1}%20\right%20]%20\left%20[%20\begin{matrix}%20%20a_0%20&amp;%20a_1%20&amp;%20a_2%20&amp;%20a_3%20&amp;%20a_4%20\\\%20a_5%20&amp;%20a_6%20&amp;%20a_7%20&amp;%20a_8%20&amp;%20a_9%20\\\%20a_1_0%20&amp;%20a_1_1%20&amp;%20a_1_2%20&amp;%20a_1_3%20&amp;%20a_1_4%20\\\%20a_1_5%20&amp;%20a_1_6%20&amp;%20a_1_7%20&amp;%20a_1_8%20&amp;%20a_1_9\end{1}%20\right%20]%20\left%20[%20\begin{matrix}%20%20&amp;%20&amp;%20\\\%20&amp;%20Initial%20&amp;%20ColorMatrix%20&amp;%20\\\%20&amp;%20&amp;\end{1}%20\right%20]%20$$" alt=""></p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本文我们学习了ColorMatrix的原理，并分析了其<code>setRotate、setScale、setSaturation</code>方法以及矩阵的乘法(前乘、后乘)。如果在阅读过程中，有任何疑问与问题，欢迎与我联系。<br><br><strong>博客:www.idtkm.com</strong><br><br><strong>GitHub:<a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><br><strong>微博:<a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><br><strong>邮箱:IdtkMa@gmail.com</strong><br><br><br></p>
<h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><p><a href="https://developer.android.com/reference/android/graphics/ColorMatrix.html" target="_blank" rel="external">ColorMatrix</a><br><br><a href="http://blog.csdn.net/harvic880925/article/details/51187277" target="_blank" rel="external">Paint之ColorMatrix与滤镜效果</a><br><br><a href="http://blog.csdn.net/maplejaw_/article/details/51728818" target="_blank" rel="external">Android Matrix矩阵详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Idtk/Blog&quot;&gt;自定义View系列目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;涉及方法&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;API&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;旋转&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;setRotate&lt;/td&gt;
&lt;td&gt;设置(非输入轴颜色的)色调&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;饱和度&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;setSaturation&lt;/td&gt;
&lt;td&gt;设置饱和度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;缩放&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;setScale&lt;/td&gt;
&lt;td&gt;三原色的取值的比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;设置&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;set、setConcat&lt;/td&gt;
&lt;td&gt;设置颜色矩阵、两个颜色矩阵的乘积&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;重置&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;reset&lt;/td&gt;
&lt;td&gt;重置颜色矩阵为初始状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;矩阵运算&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;preConcat、postConcat&lt;/td&gt;
&lt;td&gt;颜色矩阵的前乘、后乘&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;一、颜色矩阵&quot;&gt;&lt;a href=&quot;#一、颜色矩阵&quot; class=&quot;headerlink&quot; title=&quot;一、颜色矩阵&quot;&gt;&lt;/a&gt;一、颜色矩阵&lt;/h2&gt;&lt;p&gt;颜色矩阵是一个用来表示三原色和透明度的4x5的矩阵，表示为一个数组的形式&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[ a, b, c, d, e,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    f, g, h, i, j,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    k, l, m, n, o,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    p, q, r, s, t ]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一个颜色则使用&lt;code&gt;[R, G, B, A]&lt;/code&gt;的方式进行表示，所以矩阵与颜色的计算方式则为&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ompb0h8qq.bkt.clouddn.com/old/颜色矩阵计算.png&quot; alt=&quot;颜色矩阵计算&quot; title=&quot;颜色矩阵计算&quot; /&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;从上述的公式可以看出,颜色矩阵的功能划分如下&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a, b, c, d, e&lt;/code&gt; 表示三原色中的红色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f, g, h, i, j&lt;/code&gt; 表示三原色中的绿色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;k, l, m, n, o&lt;/code&gt; 表示三原色中的蓝色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p, q, r, s, t&lt;/code&gt; 表示颜色的透明度&lt;/li&gt;
&lt;li&gt;第五列用于表示颜色的偏移量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;使用示例&quot;&gt;&lt;a href=&quot;#使用示例&quot; class=&quot;headerlink&quot; title=&quot;使用示例&quot;&gt;&lt;/a&gt;使用示例&lt;/h3&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="CustomView" scheme="http://www.idtkm.com/tags/CustomView/"/>
    
  </entry>
  
  <entry>
    <title>Android事件分发机制源码解析</title>
    <link href="http://www.idtkm.com/2016/08/21/12%E3%80%81TouchEventSource/"/>
    <id>http://www.idtkm.com/2016/08/21/12、TouchEventSource/</id>
    <published>2016-08-20T16:00:00.000Z</published>
    <updated>2017-10-15T16:01:15.204Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://www.idtkm.com/customview/customview11/">更简单的学习Android事件分发</a>中，使用日志、比喻、流程图相结合的方式，以更简单的方法去分析了Android的事件分发机制。本篇文章将采用分析源码的方式，更深入的解析Android的事件分发机制。</p>
<p><a href="https://github.com/Idtk/Blog" target="_blank" rel="external">自定义View系列目录</a></p>
<h2 id="一、从Activity开始"><a href="#一、从Activity开始" class="headerlink" title="一、从Activity开始"></a>一、从Activity开始</h2><p>Android的触摸事件，是由windowManagerService进行采集，之后传递到Activiy进行处理。我们这里从Activity#dispatchTouchEvent方法开始解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">        onUserInteraction();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> onTouchEvent(ev);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码中，<code>onUserInteraction()</code>是一个空的实现，我们直接来看下<br><code>getWindow().superDispatchTouchEvent(ev)</code>方法。window是一个抽象的方法，不过系统给它提供了一个实现类PhoneWindow，我们这里看下它的<code>superDispatchTouchEvent(ev)</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>上述代码调用了DecorView类的<code>superDispatchTouchEvent</code>方法，继续跟进</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码调用了父类的<code>dispatchTouchEvent</code>方法，DecorView的父类为FrameLayout，其直接继承了<code>ViewGroup#dispatchTouchEvent</code>方法。</p>
<h2 id="二、ViewGroup中的事件分发"><a href="#二、ViewGroup中的事件分发" class="headerlink" title="二、ViewGroup中的事件分发"></a>二、ViewGroup中的事件分发</h2><p>ViewGroup#dispatchTouchEvent方法比较长，这里只截取部分进行分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line"></div><div class="line">	...</div><div class="line">		<span class="comment">// 在ACTION_DOWN事件时，初始化Touch标记</span></div><div class="line">		<span class="comment">// Handle an initial down.</span></div><div class="line">		<span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">			<span class="comment">// Throw away all previous state when starting a new touch gesture.</span></div><div class="line">			<span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></div><div class="line">			<span class="comment">// due to an app switch, ANR, or some other state change.</span></div><div class="line">			cancelAndClearTouchTargets(ev);</div><div class="line">			resetTouchState();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Check for interception.</span></div><div class="line">		<span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</div><div class="line">		<span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">				|| mFirstTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="comment">// 是否拦截的标志位，假如设置requestDisallowInterceptTouchEvent(true)，</span></div><div class="line">			<span class="comment">// 则为true，不拦截事件</span></div><div class="line">			<span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</div><div class="line">			<span class="keyword">if</span> (!disallowIntercept) &#123;</div><div class="line">				<span class="comment">// 默认返回false</span></div><div class="line">				intercepted = onInterceptTouchEvent(ev);</div><div class="line">				ev.setAction(action); <span class="comment">// restore action in case it was changed</span></div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				intercepted = <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// There are no touch targets and this action is not an initial down</span></div><div class="line">			<span class="comment">// so this view group continues to intercept touches.</span></div><div class="line">			intercepted = <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		...</div><div class="line"></div><div class="line">		<span class="comment">// Check for cancelation.</span></div><div class="line">		<span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</div><div class="line">				|| actionMasked == MotionEvent.ACTION_CANCEL;</div><div class="line"></div><div class="line">		<span class="comment">// Update list of touch targets for pointer down, if needed.</span></div><div class="line">		<span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;</div><div class="line">		TouchTarget newTouchTarget = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</div><div class="line">		<span class="comment">// 不是ACTION_CANCEL事件，并且不拦截事件</span></div><div class="line">		<span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</div><div class="line"></div><div class="line">			<span class="comment">// If the event is targeting accessiiblity focus we give it to the</span></div><div class="line">			<span class="comment">// view that has accessibility focus and if it does not handle it</span></div><div class="line">			<span class="comment">// we clear the flag and dispatch the event to all children as usual.</span></div><div class="line">			<span class="comment">// We are looking up the accessibility focused host to avoid keeping</span></div><div class="line">			<span class="comment">// state since these events are very rare.</span></div><div class="line">			View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</div><div class="line">					? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">					|| (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</div><div class="line">					|| actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class="line">				<span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></div><div class="line">				<span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</div><div class="line">						: TouchTarget.ALL_POINTER_IDS;</div><div class="line"></div><div class="line">				<span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></div><div class="line">				<span class="comment">// have become out of sync.</span></div><div class="line">				removePointersFromTouchTargets(idBitsToAssign);</div><div class="line"></div><div class="line">				<span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</div><div class="line">				<span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</div><div class="line">					<span class="comment">// 获取触摸坐标</span></div><div class="line">					<span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</div><div class="line">					<span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</div><div class="line">					<span class="comment">// Find a child that can receive the event.</span></div><div class="line">					<span class="comment">// Scan children from front to back.</span></div><div class="line">					<span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();</div><div class="line">					<span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></div><div class="line">							&amp;&amp; isChildrenDrawingOrderEnabled();</div><div class="line">					<span class="keyword">final</span> View[] children = mChildren;</div><div class="line">					<span class="comment">// 遍历所有子View</span></div><div class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">						<span class="keyword">final</span> <span class="keyword">int</span> childIndex = customOrder</div><div class="line">								? getChildDrawingOrder(childrenCount, i) : i;</div><div class="line">						<span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>)</div><div class="line">								? children[childIndex] : preorderedList.get(childIndex);</div><div class="line"></div><div class="line">						...</div><div class="line"></div><div class="line">						resetCancelNextUpFlag(child);</div><div class="line">						<span class="comment">// 把事件(ACTION_DOWN、ACTION_POINTER_DOWN、ACTION_HOVER_MOVE)传递给子View处理</span></div><div class="line">						<span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</div><div class="line">							<span class="comment">// Child wants to receive touch within its bounds.</span></div><div class="line">							mLastTouchDownTime = ev.getDownTime();</div><div class="line">							<span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</div><div class="line">								<span class="comment">// childIndex points into presorted list, find original index</span></div><div class="line">								<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</div><div class="line">									<span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</div><div class="line">										mLastTouchDownIndex = j;</div><div class="line">										<span class="keyword">break</span>;</div><div class="line">									&#125;</div><div class="line">								&#125;</div><div class="line">							&#125; <span class="keyword">else</span> &#123;</div><div class="line">								mLastTouchDownIndex = childIndex;</div><div class="line">							&#125;</div><div class="line">							mLastTouchDownX = ev.getX();</div><div class="line">							mLastTouchDownY = ev.getY();</div><div class="line">							newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">							alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line">							<span class="keyword">break</span>;</div><div class="line">						&#125;</div><div class="line">						...</div><div class="line">					&#125;</div><div class="line">					...</div><div class="line">				&#125;</div><div class="line">				...</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 分发事件到目标View</span></div><div class="line">		<span class="comment">// Dispatch to touch targets.</span></div><div class="line">		<span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="comment">// 没有找到事件分发目标的情况，将会调用自己的onTouchEvent方法</span></div><div class="line">			<span class="comment">// No touch targets so treat this as an ordinary view.</span></div><div class="line">			handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</div><div class="line">					TouchTarget.ALL_POINTER_IDS);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">			<span class="comment">// Dispatch to touch targets, excluding the new touch target if we already</span></div><div class="line">			<span class="comment">// dispatched to it.  Cancel touch targets if necessary.</span></div><div class="line">			TouchTarget predecessor = <span class="keyword">null</span>;</div><div class="line">			TouchTarget target = mFirstTouchTarget;</div><div class="line">			<span class="comment">// 这里找到了事件分发的目标</span></div><div class="line">			<span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">final</span> TouchTarget next = target.next;</div><div class="line">				<span class="comment">// ACTION_DOWN已经完成事件分发，并消费了事件，直接返回true</span></div><div class="line">				<span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</div><div class="line">					handled = <span class="keyword">true</span>;</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					<span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</div><div class="line">							|| intercepted;</div><div class="line">					<span class="comment">// 其余事件则需要传递给目标View进行处理</span></div><div class="line">					<span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</div><div class="line">							target.child, target.pointerIdBits)) &#123;</div><div class="line">						handled = <span class="keyword">true</span>;</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">if</span> (cancelChild) &#123;</div><div class="line">						<span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</div><div class="line">							mFirstTouchTarget = next;</div><div class="line">						&#125; <span class="keyword">else</span> &#123;</div><div class="line">							predecessor.next = next;</div><div class="line">						&#125;</div><div class="line">						target.recycle();</div><div class="line">						target = next;</div><div class="line">						<span class="keyword">continue</span>;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				predecessor = target;</div><div class="line">				target = next;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 对ACTION_CANCEL事件进行处理</span></div><div class="line">		<span class="comment">// Update list of touch targets for pointer up or cancel, if needed.</span></div><div class="line">		<span class="keyword">if</span> (canceled</div><div class="line">				|| actionMasked == MotionEvent.ACTION_UP</div><div class="line">				|| actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class="line">			<span class="comment">// 重置Touch状态</span></div><div class="line">			resetTouchState();</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</div><div class="line">			<span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</div><div class="line">			<span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</div><div class="line">			removePointersFromTouchTargets(idBitsToRemove);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	...</div><div class="line">	<span class="keyword">return</span> handled;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 默认返回false</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们现在来看看传递事件的<code>dispatchTransformedTouchEvent</code>方法，同样我也只是截取了其中比较关键的部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></div><div class="line">		View child, <span class="keyword">int</span> desiredPointerIdBits) &#123;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> handled;</div><div class="line">	...</div><div class="line">	<span class="keyword">final</span> MotionEvent transformedEvent;</div><div class="line">	<span class="comment">// 对transformedEvent的一系列计算</span></div><div class="line">	...</div><div class="line">	<span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">// 如果没有子View，则执行super.dispatchTouchEvent方法，</span></div><div class="line">		<span class="comment">// 调用自己的onTouchEvent方法</span></div><div class="line">		handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</div><div class="line">		<span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</div><div class="line">		transformedEvent.offsetLocation(offsetX, offsetY);</div><div class="line">		<span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</div><div class="line">			transformedEvent.transform(child.getInverseMatrix());</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 如果有子View，则调用子View#dispatchTouchEvent方法</span></div><div class="line">		handled = child.dispatchTouchEvent(transformedEvent);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Done.</span></div><div class="line">	transformedEvent.recycle();</div><div class="line">	<span class="keyword">return</span> handled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="三、View中的事件处理"><a href="#三、View中的事件处理" class="headerlink" title="三、View中的事件处理"></a>三、View中的事件处理</h2><p>ViewGroup中不拦截事件，调用子View#dispatchTouchEvent方法进行处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">	...</div><div class="line">	<span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">		<span class="comment">// 如果设置了OnTouchListener，使用onTouch对事件进行处理，</span></div><div class="line">		<span class="comment">// 并返回true，则不需要再执行onTouchEvent方法</span></div><div class="line">		<span class="comment">//noinspection SimplifiableIfStatement</span></div><div class="line">		ListenerInfo li = mListenerInfo;</div><div class="line">		<span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></div><div class="line">				&amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">				&amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</div><div class="line">			result = <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class="line">			result = <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line"></div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里继续看看View#onTouchEvent方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</div><div class="line">	<span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</div><div class="line"></div><div class="line">	...</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">			(viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</div><div class="line">			(viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</div><div class="line">		<span class="keyword">switch</span> (action) &#123;</div><div class="line">			<span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">				...</div><div class="line">				<span class="comment">// 移除长按</span></div><div class="line">				removeLongPressCallback();</div><div class="line">				...</div><div class="line">					<span class="comment">// 检查单击</span></div><div class="line">					performClick();</div><div class="line">				...</div><div class="line">				<span class="keyword">break</span>;</div><div class="line"></div><div class="line">			<span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">				...</div><div class="line">				<span class="comment">// 检测是否为长按</span></div><div class="line">				checkForLongClick(<span class="number">0</span>);</div><div class="line">				...</div><div class="line">				<span class="keyword">break</span>;</div><div class="line"></div><div class="line">			....</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码，主要是检查View是否可以点击，如果可点击，则会返回true，同时也会执行可点击的事件。</p>
<h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>通过本文的源码解析，我们可以更深入的理解Android的事件分发。可以简单的推出一个流程 : Activity→PhoneWindow→DecorView→ViewGroup→View。如果在阅读过程中，有任何疑问与问题，欢迎与我联系。<br><br><strong>博客:www.idtkm.com</strong><br><br><strong>GitHub:<a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><br><strong>微博:<a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><br><strong>邮箱:IdtkMa@gmail.com</strong><br><br><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://www.idtkm.com/customview/customview11/&quot;&gt;更简单的学习Android事件分发&lt;/a&gt;中，使用日志、比喻、流程图相结合的方式，以更简单的方法去分析了Android的事件分发机制。本篇文章将采用分析源码的方式，更深入的解析Android的事件分发机制。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Idtk/Blog&quot;&gt;自定义View系列目录&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、从Activity开始&quot;&gt;&lt;a href=&quot;#一、从Activity开始&quot; class=&quot;headerlink&quot; title=&quot;一、从Activity开始&quot;&gt;&lt;/a&gt;一、从Activity开始&lt;/h2&gt;&lt;p&gt;Android的触摸事件，是由windowManagerService进行采集，之后传递到Activiy进行处理。我们这里从Activity#dispatchTouchEvent方法开始解析&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dispatchTouchEvent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MotionEvent ev)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ev.getAction() == MotionEvent.ACTION_DOWN) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        onUserInteraction();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (getWindow().superDispatchTouchEvent(ev)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; onTouchEvent(ev);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上述代码中，&lt;code&gt;onUserInteraction()&lt;/code&gt;是一个空的实现，我们直接来看下&lt;br&gt;&lt;code&gt;getWindow().superDispatchTouchEvent(ev)&lt;/code&gt;方法。window是一个抽象的方法，不过系统给它提供了一个实现类PhoneWindow，我们这里看下它的&lt;code&gt;superDispatchTouchEvent(ev)&lt;/code&gt;方法。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;superDispatchTouchEvent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MotionEvent event)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mDecor.superDispatchTouchEvent(event);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="CustomView" scheme="http://www.idtkm.com/tags/CustomView/"/>
    
  </entry>
  
  <entry>
    <title>更简单的学习Android事件分发</title>
    <link href="http://www.idtkm.com/2016/08/15/11%E3%80%81TouchEvent/"/>
    <id>http://www.idtkm.com/2016/08/15/11、TouchEvent/</id>
    <published>2016-08-14T16:00:00.000Z</published>
    <updated>2017-10-15T16:01:22.179Z</updated>
    
    <content type="html"><![CDATA[<p>事件分发是Android中非常重要的机制，是用户与界面交互的基础。这篇文章将通过示例打印出的Log，绘制出事件分发的流程图，让大家更容易的去理解Android的事件分发机制。<br></p>
<p><a href="https://github.com/Idtk/Blog" target="_blank" rel="external">自定义View系列目录</a></p>
<h2 id="一、必要的基础知识"><a href="#一、必要的基础知识" class="headerlink" title="一、必要的基础知识"></a>一、必要的基础知识</h2><h3 id="1、相关方法"><a href="#1、相关方法" class="headerlink" title="1、相关方法"></a>1、相关方法</h3><p>Android中与事件分发相关的方法主要包括dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent三个方法，而事件分发一般会经过三种容器，分别为Activity、ViewGroup、View。下表对这三种容器分别拥有的事件分发相关方法进行了整理。</p>
<table>
<thead>
<tr>
<th style="text-align:center">事件相关方法</th>
<th style="text-align:center">方法功能</th>
<th>Activity</th>
<th>ViewGroup</th>
<th>View</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public boolean dispatchTouchEvent</td>
<td style="text-align:center">事件分发</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td style="text-align:center">public boolean onInterceptTouchEvent</td>
<td style="text-align:center">事件拦截</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td style="text-align:center">public boolean onTouchEvent</td>
<td style="text-align:center">事件消费</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<ul>
<li>分发: dispatchTouchEvent如果返回true，则表示在当前View或者其子View(子子…View)中，找到了处理事件的View；反之，则表示没有寻找到</li>
<li>拦截: onInterceptTouchEvent如果返回true，则表示这个事件由当前View进行处理，不管处理结果如何，都不会再向子View传递这个事件；反之，则表示当前View不主动处理这个事件，除非他的子View返回的事件分发结果为false</li>
<li>消费: onTouchEvent如果返回true，则表示当前View就是事件传递的终点；反之，则表示当前View不是事件传递的终点</li>
</ul>
<p><br></p>
<a id="more"></a>
<h3 id="2、相关事件"><a href="#2、相关事件" class="headerlink" title="2、相关事件"></a>2、相关事件</h3><p>这篇文章中我们只考虑4种触摸事件: ACTION_DOWN、ACTION_UP、ACTION_MOVE、ACTION_CANAL。<br><br>事件序列:一个事件序列是指从手指触摸屏幕开始，到手指离开屏幕结束，这个过程中产生的一系列事件。一个事件序列以ACTION_DOWN事件开始，中间可能经过若干个MOVE，以ACTION_UP事件结束。<br><br>接下来我们将使用之前的文章<a href="http://www.idtkm.com/customview/customview8/">自定义View——弹性滑动</a>中例子来作为本文的示例，简单增加一些代码即可，修改之后的代码<a href="https://github.com/Idtk/Blog/tree/master/Code/11" target="_blank" rel="external">请点击查看</a>。<br></p>
<h2 id="二、示例的默认情况"><a href="#二、示例的默认情况" class="headerlink" title="二、示例的默认情况"></a>二、示例的默认情况</h2><p>我们可以从示例代码的xml中看出，图片都是可点击的。<br></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;com.idtk.customscroll.ParentView</div><div class="line">    xmlns:android="http://schemas.android.com/apk/res/android"</div><div class="line">    xmlns:tools="http://schemas.android.com/tools"</div><div class="line">    android:layout_width="match_parent"</div><div class="line">    android:layout_height="match_parent"</div><div class="line">    android:padding="10dp"</div><div class="line">    tools:context="com.idtk.customscroll.MainActivity"</div><div class="line">    &gt;</div><div class="line"></div><div class="line">    &lt;com.idtk.customscroll.ChildView</div><div class="line">        android:layout_width="match_parent"</div><div class="line">        android:layout_height="match_parent"</div><div class="line">        android:src="@drawable/zhiqinchun"</div><div class="line">        android:clickable="true"/&gt;</div><div class="line"></div><div class="line">    &lt;com.idtk.customscroll.ChildView</div><div class="line">        android:layout_width="wrap_content"</div><div class="line">        android:layout_height="wrap_content"</div><div class="line">        android:src="@drawable/hanzhan"</div><div class="line">        android:clickable="true"/&gt;</div><div class="line"></div><div class="line">    &lt;com.idtk.customscroll.ChildView</div><div class="line">        android:layout_width="match_parent"</div><div class="line">        android:layout_height="match_parent"</div><div class="line">        android:src="@drawable/shengui"</div><div class="line">        android:clickable="true"/&gt;</div><div class="line"></div><div class="line">    &lt;com.idtk.customscroll.ChildView</div><div class="line">        android:layout_width="match_parent"</div><div class="line">        android:layout_height="match_parent"</div><div class="line">        android:src="@drawable/dayu"</div><div class="line">        android:clickable="true"/&gt;</div><div class="line"></div><div class="line">&lt;/com.idtk.customscroll.ParentView&gt;</div></pre></td></tr></table></figure>
<p>我们现在来点击一下，查看下打印出的日志。<br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/onTouchTrue.png" alt="onTouchTrue" title="onTouchTrue"><br><br></p>
<p>根据打印出的log来绘制一张事件传递的流程图<br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/onTouchTrueXmind.png" alt="onTouchTrueXmind" title="onTouchTrueXmind"><br><br></p>
<p>现在来理一下事件序列的流程:</p>
<ul>
<li>ACTION_DOWN事件从Activity#dispatchTouchEvent方法开始</li>
<li>ACTION_DOWN事件传递至ViewGroup#dispatchTouchEvent方法，ViewGroup#onInterceptTouchEvent返回false，表示不拦截ACTION_DOWN</li>
<li>ACTION_DOWN事件传递到View#dispatchTouchEvent方法，在View#onTouchEvent进行执行，返回true，表示事件已经被消费</li>
<li>返回的结果true，被回传到View#dispatchTouchEvent，之后回传到ACTION_DOWN事件的起点Activity#dispatchTouchEvent方法</li>
<li>ACTION_UP事件的传递过程与ACTION_DOWN相同，这里不再复述</li>
</ul>
<hr>
<p>这里使用工作中的情况来模拟一下吧：老板(Activity)、项目经理(ViewGroup)、软件工程师(View)<br></p>
<ul>
<li>老板分配一个任务给项目经理(Activity#dispatchTouchEvent→ViewGroup#dispatchTouchEvent)，项目经理选择自己不做这个任务(ViewGroup#dispatchTouchEvent返回false)，交由软件工程师处理这个任务(View#dispatchTouchEvent)(我们忽略总监与组长的情况),软件工程师完成了这个任务(View#onTouchEvent返回true)</li>
<li>把结果告诉项目经理(返回结果true，View#dispatchTouchEvent→ViewGroup#dispatchTouchEvent)，项目经理把结果告诉老板(返回结果true，ViewGroup#dispatchTouchEvent→Activity#dispatchTouchEvent)</li>
<li>项目经理完成的不错，老板决定把这个项目的二期、三期等都交给项目经理，同样项目经理也觉得这个软件工程师完成的不错，所以也把二期、三期等都交给这个工程师来做</li>
</ul>
<hr>
<p>通过上面的传递过程，我们可以得出一些结论 ：</p>
<ul>
<li>事件总是由父元素分发给子元素</li>
<li>某个ViewGroup如果onInterceptTouchEvent返回为false，则表示ViewGroup不拦截事件，而是将其传递给View#dispatchTouchEvent方法</li>
<li>某个View如果onTouchEvent返回true，表示事件被消费，则其结果将直接通过dispatchTouchEvent方法传递回Activity</li>
<li>如果某个View消费了ACTION_DOWN事件，那么这个事件序列中的后续事件也将交由其进行处理(有一些特殊情况除外，比如在序列中的之后事件进行拦截）</li>
</ul>
<h2 id="三、在View中不消费事件"><a href="#三、在View中不消费事件" class="headerlink" title="三、在View中不消费事件"></a>三、在View中不消费事件</h2><p>我们现在修改示例代码的xml部分，<code>android:clickable=&quot;true&quot;</code>全部修改为<code>android:clickable=&quot;false&quot;</code><br><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;com.idtk.customscroll.ParentView</div><div class="line">    xmlns:android="http://schemas.android.com/apk/res/android"</div><div class="line">    xmlns:tools="http://schemas.android.com/tools"</div><div class="line">    android:layout_width="match_parent"</div><div class="line">    android:layout_height="match_parent"</div><div class="line">    android:padding="10dp"</div><div class="line">    tools:context="com.idtk.customscroll.MainActivity"</div><div class="line">    &gt;</div><div class="line"></div><div class="line">    &lt;com.idtk.customscroll.ChildView</div><div class="line">        android:layout_width="match_parent"</div><div class="line">        android:layout_height="match_parent"</div><div class="line">        android:src="@drawable/zhiqinchun"</div><div class="line">        android:clickable="false"/&gt;</div><div class="line"></div><div class="line">    &lt;com.idtk.customscroll.ChildView</div><div class="line">        android:layout_width="wrap_content"</div><div class="line">        android:layout_height="wrap_content"</div><div class="line">        android:src="@drawable/hanzhan"</div><div class="line">        android:clickable="false"/&gt;</div><div class="line"></div><div class="line">    &lt;com.idtk.customscroll.ChildView</div><div class="line">        android:layout_width="match_parent"</div><div class="line">        android:layout_height="match_parent"</div><div class="line">        android:src="@drawable/shengui"</div><div class="line">        android:clickable="false"/&gt;</div><div class="line"></div><div class="line">    &lt;com.idtk.customscroll.ChildView</div><div class="line">        android:layout_width="match_parent"</div><div class="line">        android:layout_height="match_parent"</div><div class="line">        android:src="@drawable/dayu"</div><div class="line">        android:clickable="false"/&gt;</div><div class="line"></div><div class="line">&lt;/com.idtk.customscroll.ParentView&gt;</div></pre></td></tr></table></figure></p>
<p>这时再点击一下，查看新打印出的日志<br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/onTouchFalse.png" alt="onTouchFalse" title="onTouchFalse"><br><br></p>
<p>现在根据log中显示的逻辑，分别绘制ACTION_DOWN事件与ACTION_UP事件传递的流程图<br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/onTouchFalseXmind.png" alt="onTouchFalseXmind" title="onTouchFalseXmind"><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/onTouchFalseXmind2.png" alt="onTouchFalseXmind" title="onTouchFalseXmind"><br><br></p>
<p>我们来整理下这个事件序列的流程：</p>
<ul>
<li>ACTION_DOWN事件的传递与之前相同，不同的地方在于，返回值的传递</li>
<li>因为不可点击，View#onTouchEvent返回值为false，将其传递给自己的dispatchTouchEvent方法，之后传递到ViewGroup#dispatchTouchEvent方法，再传递到ViewGroup#onTouchEvent方法</li>
<li>ViewGroup返回false之后，ACTION_DOWN事件交由Activity#onTouchEvent方法进行处理，然而依旧返回false，最后ACTION_DOWN事件的返回结果即为false</li>
<li>ACTION_UP事件在发现View、ViewGroup并不处理ACTION_DOWN事件后，直接将其传递给了Activity#onTouch方法处理，处理返回false，ACTION_UP事件的返回结果即为false</li>
</ul>
<hr>
<p>这里使用工作中的情况来模拟：依旧是老板(Activity)、项目经理(ViewGroup)、软件工程师(View)<br><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;从老板交任务给项目经理，项目经理交任务给工程师，这一段流程和之前的例子相同。不同之处是软件工程师没有完成这个任务(View#onTouchEvent返回false)，告诉项目经理我没有完成，然后项目经理自己进行了尝试，同样没有完成(ViewGroup#onTouchEvent返回false)，项目经理告诉了老板，我没有完成，然后老板自己试了下也没有完成这个任务(Activity#onTouchEvent返回false),但之后的也有项目的二期、三期，不过老板知道你们完成不了，所以都是他自己进行尝试，不过很惨都没完成。(这段有点与正常情况不同，不过只是打个比方)<br></p>
<hr>
<p>通过结合上面两个例子，可以得出一些结论 ：</p>
<ul>
<li>某个View如果onTouchEvent返回false，表示事件没有被消费，则事件将传递给其父View的onTouchEvent进行处理</li>
<li>某个View如果它不消耗ACTION_DOWN事件，那么这个序列的后续事件也不会再交由它来处理</li>
<li>如果事件没有View对其进行处理，那么最后将有Activity进行处理</li>
<li>View默认的onTouchEvent在View可点击的情况下，将会消耗事件，返回true；不可点击的情况下，则不消耗事件，返回false(longClickable的情况，读者可以自行测试，结果与clickable相同)</li>
</ul>
<h2 id="四、在ViewGroup中拦截事件"><a href="#四、在ViewGroup中拦截事件" class="headerlink" title="四、在ViewGroup中拦截事件"></a>四、在ViewGroup中拦截事件</h2><p>事件分发中拦截的情况，这里我把它分为2种，一种是在ACTION_DOWN事件时，就进行拦截的；另一种是在ACTION_DOWN之后的事件序列中，对事件进行了拦截。</p>
<h3 id="1、在事件开始时拦截"><a href="#1、在事件开始时拦截" class="headerlink" title="1、在事件开始时拦截"></a>1、在事件开始时拦截</h3><p>为了达到在ViewGroup中，一开始就拦截触摸事件的效果，我们需要进行修改，在ParentView#onInterceptTouchEvent方法的最后部分，我注释掉的<code>intercept=true;</code>进行恢复，然后为activity_main.xml中的ParentView增加<code>android:clickable=&quot;true&quot;</code>属性。<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;com.idtk.customscroll.ParentView</div><div class="line">    xmlns:android="http://schemas.android.com/apk/res/android"</div><div class="line">    xmlns:tools="http://schemas.android.com/tools"</div><div class="line">    android:layout_width="match_parent"</div><div class="line">    android:layout_height="match_parent"</div><div class="line">    android:padding="10dp"</div><div class="line">    tools:context="com.idtk.customscroll.MainActivity"</div><div class="line">    &gt;</div><div class="line"></div><div class="line">    &lt;com.idtk.customscroll.ChildView</div><div class="line">        android:layout_width="match_parent"</div><div class="line">        android:layout_height="match_parent"</div><div class="line">        android:src="@drawable/zhiqinchun"</div><div class="line">        android:clickable="true"/&gt;</div><div class="line"></div><div class="line">    &lt;com.idtk.customscroll.ChildView</div><div class="line">        android:layout_width="wrap_content"</div><div class="line">        android:layout_height="wrap_content"</div><div class="line">        android:src="@drawable/hanzhan"</div><div class="line">        android:clickable="true"/&gt;</div><div class="line"></div><div class="line">    &lt;com.idtk.customscroll.ChildView</div><div class="line">        android:layout_width="match_parent"</div><div class="line">        android:layout_height="match_parent"</div><div class="line">        android:src="@drawable/shengui"</div><div class="line">        android:clickable="true"/&gt;</div><div class="line"></div><div class="line">    &lt;com.idtk.customscroll.ChildView</div><div class="line">        android:layout_width="match_parent"</div><div class="line">        android:layout_height="match_parent"</div><div class="line">        android:src="@drawable/dayu"</div><div class="line">        android:clickable="true"/&gt;</div><div class="line"></div><div class="line">&lt;/com.idtk.customscroll.ParentView&gt;</div></pre></td></tr></table></figure></p>
<p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/intercept1.png" alt="intercept" title="intercept"><br><br></p>
<p>修改完成后，在此运行点击，查看打印出的log<br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/interceptTrue onTouchTrue.png" alt="interceptTrue onTouchTrue" title="interceptTrue onTouchTrue"><br><br></p>
<p>我们现在来看下拦截情况下的事件流程图<br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/interceptTrue onTouchTrueXmind.png" alt="interceptTrue onTouchTrueXmind" title="interceptTrue onTouchTrueXmind"><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/interceptTrue onTouchTrueXmind2.png" alt="interceptTrue onTouchTrueXmind" title="interceptTrue onTouchTrueXmind"><br><br></p>
<p>这里大部分和之前的例子相同，主要的区别是在于ViewGroup#onInterceptTouchEvent方法中，对传递的事件进行了拦截，返回true，ACTION_DOWN事件就传递到了ViewGroup#onTouchEvent中进行处理，ACTION_DOWN事件之后的传递就与之前的例子相同了。另一点重要的区别是，在ViewGroup拦截下事件之后，此事件序列的其余事件，在进入ViewGroup#dispatchTouchEvent方法之后，不在需要进行是否拦截事件的判断，而是直接进入了onTouchEvent方法之中。<br></p>
<hr>
<p>使用工作中的情况来模拟：老板(Activity)、项目经理(ViewGroup)、软件工程师(View)<br><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;老板吧任务交给项目经理，项目经理认为这个项目比较难，所以决定自己处理(ViewGroup#onInterceptTouchEvent,return true)，项目经理比较厉害他把任务完成了(ViewGroup#onTouchEvent,return true)，然后他告诉老板他完成了(return true,ViewGroup#dispatchTouchEvent→Activity#dispatchTouchEvent)。之后老板依旧会把任务交给项目经理，项目经理知道这个任务难度，所以不假思索(也就是这个事件序列中的其余事件没有经过ViewGroup#onInterceptTouchEvent)的自己来做。</p>
<hr>
<p>通过上面的例子，可以得出一些结论 ：</p>
<ul>
<li>某个ViewGroup如果onInterceptTouchEvent返回为true，则ViewGroup拦截事件，将事件传递给其onTouchEvent方法进行处理</li>
<li>某个ViewGroup如果它的onInterceptTouchEvent返回为true，那么这个事件序列中的后续事件，不会在进行onInterceptTouchEvent的判断，而是由它的dispatchTouchEvent方法直接传递给onTouchEvent方法进行处理</li>
</ul>
<h3 id="2、在事件序列中拦截"><a href="#2、在事件序列中拦截" class="headerlink" title="2、在事件序列中拦截"></a>2、在事件序列中拦截</h3><p>这里把使用的示例恢复到初始状态，然后把我在ParentView#onInterceptTouchEvent方法，switch内的两个注释掉的<code>intercept = true;</code>代码进行恢复，最后部分<code>intercept = true;</code>再次注释掉。<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;com.idtk.customscroll.ParentView</div><div class="line">    xmlns:android="http://schemas.android.com/apk/res/android"</div><div class="line">    xmlns:tools="http://schemas.android.com/tools"</div><div class="line">    android:layout_width="match_parent"</div><div class="line">    android:layout_height="match_parent"</div><div class="line">    android:padding="10dp"</div><div class="line">    tools:context="com.idtk.customscroll.MainActivity"</div><div class="line">    &gt;</div><div class="line"></div><div class="line">    &lt;com.idtk.customscroll.ChildView</div><div class="line">        android:layout_width="match_parent"</div><div class="line">        android:layout_height="match_parent"</div><div class="line">        android:src="@drawable/zhiqinchun"</div><div class="line">        android:clickable="true"/&gt;</div><div class="line"></div><div class="line">    &lt;com.idtk.customscroll.ChildView</div><div class="line">        android:layout_width="wrap_content"</div><div class="line">        android:layout_height="wrap_content"</div><div class="line">        android:src="@drawable/hanzhan"</div><div class="line">        android:clickable="true"/&gt;</div><div class="line"></div><div class="line">    &lt;com.idtk.customscroll.ChildView</div><div class="line">        android:layout_width="match_parent"</div><div class="line">        android:layout_height="match_parent"</div><div class="line">        android:src="@drawable/shengui"</div><div class="line">        android:clickable="true"/&gt;</div><div class="line"></div><div class="line">    &lt;com.idtk.customscroll.ChildView</div><div class="line">        android:layout_width="match_parent"</div><div class="line">        android:layout_height="match_parent"</div><div class="line">        android:src="@drawable/dayu"</div><div class="line">        android:clickable="true"/&gt;</div><div class="line"></div><div class="line">&lt;/com.idtk.customscroll.ParentView&gt;</div></pre></td></tr></table></figure></p>
<p><br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/intercept2.png" alt="intercept" title="intercept"><br><br><br><br><br>重新运行之后，滑动一个图片，来看看Log<br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/cancel1.png" alt="cancel" title="cancel" width="400"><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/cancel2.png" alt="cancel" title="cancel" width="400"><br><br><br><br><br>这里分成两张图片，是因为中间有很多ACTION_MOVE，为了方便观察，所以只截取了Log的首尾部分。<br><br><br><br>这里的关键部分，就是红框中的ACTION_CANCEL,可以看到ACTION_DOWN事件的传递时onInterceptTouchEvent并没有拦截，返回false，在其后的事件ACTION_MOVE再次进入onInterceptTouchEvent时，ViewGroup对事件进行了拦截，这样将会对View传递一个ACTION_CANCEL事件，之后的ACTION_MOVE事件就不再传递给View了。<br></p>
<hr>
<p>使用工作中的情况来模拟：老板(Activity)、项目经理(ViewGroup)、软件工程师(View)<br><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;这里的情况就是，一期的任务和第一个例子一样的情况一样，由软件工程师完成，不过忽然项目经理觉得二期的任务有点难，然后决定自己完成。这时就给工程师说，这个项目的后续任务，不要你来完成了(ACTION_CANCEL)。</p>
<hr>
<p>从这里也可以得出一个结论 ：</p>
<ul>
<li>某个View接收了ACTION_DOWN之后，这个序列的后续事件中，如果在某一刻被父View拦截了，则这个字View会收到一个ACTION_CANCEL事件，并且也不会再收到这个事件序列中的后续事件。</li>
</ul>
<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>本文通过示例打印出的各种Log对Android的事件分发机制进行，得出如下结论 ：<br></p>
<ul>
<li>一个事件序列是指从手指触摸屏幕开始，到手指离开屏幕结束，这个过程中产生的一系列事件。一个事件序列以ACTION_DOWN事件开始，中间可能经过若干个MOVE，以ACTION_UP事件结束。</li>
<li>事件的传递过程是由外向内的，即事件总是由父元素分发给子元素</li>
<li>如果某个View消费了ACTION_DOWN事件，那么通常情况下，这个事件序列中的后续事件也将交由其进行处理，但可以通过调用其父View的onInterceptTouchEvent方法，对后续事件进行拦截</li>
<li>如果某个View它不消耗ACTION_DOWN事件，那么这个序列的后续事件也不会再交由它来处理</li>
<li>如果事件没有View对其进行处理，那么最后将有Activity进行处理</li>
<li>如果事件传递的结果为true，回传的结果直接通过不断调用父View#dispatchTouchEvent方法，传递给Activity；如果事件传递的结果为false，回传的结果不断调用父View#onTouchEvent方法，获取返回结果。</li>
<li>View默认的onTouchEvent在View可点击的情况下，将会消耗事件，返回true；不可点击的情况下，则不消耗事件，返回false(longClickable的情况，读者可以自行测试，结果与clickable相同)</li>
<li>如果某个ViewGroup的onInterceptTouchEvent返回为true，那么这个事件序列中的后续事件，不会在进行onInterceptTouchEvent的判断，而是由它的dispatchTouchEvent方法直接传递给onTouchEvent方法进行处理</li>
<li>如果某个View接收了ACTION_DOWN之后，这个序列的后续事件中，在某一刻被父View拦截了，则这个字View会收到一个ACTION_CANCEL事件，并且也不会再收到这个事件序列中的后续事件</li>
</ul>
<p><br></p>
<table>
<thead>
<tr>
<th style="text-align:center">事件相关方法</th>
<th style="text-align:center">方法功能</th>
<th>Activity</th>
<th>ViewGroup</th>
<th>View</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public boolean dispatchTouchEvent</td>
<td style="text-align:center">事件分发</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td style="text-align:center">public boolean onInterceptTouchEvent</td>
<td style="text-align:center">事件拦截</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td style="text-align:center">public boolean onTouchEvent</td>
<td style="text-align:center">事件消费</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p><br><br>如果在阅读过程中，有任何疑问与问题，欢迎与我联系。<br><br><strong>博客:www.idtkm.com</strong><br><br><strong>GitHub:<a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><br><strong>微博:<a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><br><strong>邮箱:IdtkMa@gmail.com</strong><br><br><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事件分发是Android中非常重要的机制，是用户与界面交互的基础。这篇文章将通过示例打印出的Log，绘制出事件分发的流程图，让大家更容易的去理解Android的事件分发机制。&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Idtk/Blog&quot;&gt;自定义View系列目录&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、必要的基础知识&quot;&gt;&lt;a href=&quot;#一、必要的基础知识&quot; class=&quot;headerlink&quot; title=&quot;一、必要的基础知识&quot;&gt;&lt;/a&gt;一、必要的基础知识&lt;/h2&gt;&lt;h3 id=&quot;1、相关方法&quot;&gt;&lt;a href=&quot;#1、相关方法&quot; class=&quot;headerlink&quot; title=&quot;1、相关方法&quot;&gt;&lt;/a&gt;1、相关方法&lt;/h3&gt;&lt;p&gt;Android中与事件分发相关的方法主要包括dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent三个方法，而事件分发一般会经过三种容器，分别为Activity、ViewGroup、View。下表对这三种容器分别拥有的事件分发相关方法进行了整理。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;事件相关方法&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;方法功能&lt;/th&gt;
&lt;th&gt;Activity&lt;/th&gt;
&lt;th&gt;ViewGroup&lt;/th&gt;
&lt;th&gt;View&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;public boolean dispatchTouchEvent&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;事件分发&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;public boolean onInterceptTouchEvent&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;事件拦截&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;public boolean onTouchEvent&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;事件消费&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;分发: dispatchTouchEvent如果返回true，则表示在当前View或者其子View(子子…View)中，找到了处理事件的View；反之，则表示没有寻找到&lt;/li&gt;
&lt;li&gt;拦截: onInterceptTouchEvent如果返回true，则表示这个事件由当前View进行处理，不管处理结果如何，都不会再向子View传递这个事件；反之，则表示当前View不主动处理这个事件，除非他的子View返回的事件分发结果为false&lt;/li&gt;
&lt;li&gt;消费: onTouchEvent如果返回true，则表示当前View就是事件传递的终点；反之，则表示当前View不是事件传递的终点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="CustomView" scheme="http://www.idtkm.com/tags/CustomView/"/>
    
  </entry>
  
  <entry>
    <title>View的requestLayout传递与测量、布局流程分析</title>
    <link href="http://www.idtkm.com/2016/08/10/10%E3%80%81RequestLayout/"/>
    <id>http://www.idtkm.com/2016/08/10/10、RequestLayout/</id>
    <published>2016-08-09T16:00:00.000Z</published>
    <updated>2017-10-15T16:01:29.008Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在之前的<a href="https://github.com/Idtk/Blog/blob/master/Blog/9%E3%80%81Invalidate.md" target="_blank" rel="external">invalidate传递与绘制流程分析</a>文章中我们对invalidate的流程进行了详细分析，现在来继续分析下requestLayout的流程吧</strong></p>
<p><a href="https://github.com/Idtk/Blog" target="_blank" rel="external">自定义View系列目录</a></p>
<h2 id="一、requestLayout的请求传递"><a href="#一、requestLayout的请求传递" class="headerlink" title="一、requestLayout的请求传递"></a>一、requestLayout的请求传递</h2><p>我们从View#requestLayout方法的源码开始</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mMeasureCache != <span class="keyword">null</span>) mMeasureCache.clear();</div><div class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// Only trigger request-during-layout logic if this is the view requesting it,</span></div><div class="line">        <span class="comment">// not the views in its parent hierarchy</span></div><div class="line">        ViewRootImpl viewRoot = getViewRootImpl();</div><div class="line">        <span class="keyword">if</span> (viewRoot != <span class="keyword">null</span> &amp;&amp; viewRoot.isInLayout()) &#123;</div><div class="line">            <span class="keyword">if</span> (!viewRoot.requestLayoutDuringLayout(<span class="keyword">this</span>)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        mAttachInfo.mViewRequestingLayout = <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 增加PFLAG_FORCE_LAYOUT标记，在measure时会校验此属性</span></div><div class="line">    mPrivateFlags |= PFLAG_FORCE_LAYOUT;</div><div class="line">    mPrivateFlags |= PFLAG_INVALIDATED;</div><div class="line">	<span class="comment">// 父类不为空&amp;&amp;父类没有请求重新布局(是否有PFLAG_FORCE_LAYOUT标志)</span></div><div class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</div><div class="line">		<span class="comment">// 调用父类的requestLayout</span></div><div class="line">        mParent.requestLayout();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">this</span>) &#123;</div><div class="line">        mAttachInfo.mViewRequestingLayout = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>在源码中，会对measure的缓存进行清除，之后会判断ViewTree是否正在布局流程，接着为View设置标记，PFLAG_FORCE_LAYOUT标记会在View进行measure时验证。之后非常重要会判断父类是否为空以及检查是否正在请求重新布局(即检查之间设置的PFLAG_FORCE_LAYOUT标记)，如果满足条件则会父类的requestLayout方法，而ViewGroup继承自View，其requestLayout方法调用了View的requestLayout方法，所以会不断迭代的调用父类的requestLayout方法，直到DecorView的父类ViewRoot。<br></p>
<p>ViewRoot的实现类为ViewRootImpl，在这个类中的requestLayout方法与View中的并不相同，我们来看下他的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">// 是否在处理requestLayout</span></div><div class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</div><div class="line">		<span class="comment">// 检查创建view的线程是否为当前线程</span></div><div class="line">        checkThread();</div><div class="line">        mLayoutRequested = <span class="keyword">true</span>;</div><div class="line">        scheduleTraversals();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在ViewRootImpl#requestLayout中,首先判断是否正在requestLayout中，之后检查当前线程是否为创建View的线程。接着调用scheduleTraversals方法，发起请求。<br></p>
<p>ViewRootImpl#scheduleTraversals方法调用performTraversals方法的过程已经在<a href="https://github.com/Idtk/Blog/blob/master/Blog/9%E3%80%81Invalidate.md" target="_blank" rel="external">自定义View——invalidate流程分析</a>中进行了详细说明，在这里就不在赘述了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</div><div class="line">	...</div><div class="line">	Rect frame = mWinFrame;</div><div class="line">	<span class="keyword">if</span> (mFirst) &#123;</div><div class="line">		mFullRedrawNeeded = <span class="keyword">true</span>;</div><div class="line">		mLayoutRequested = <span class="keyword">true</span>;</div><div class="line">		<span class="keyword">if</span> (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL</div><div class="line">				|| lp.type == WindowManager.LayoutParams.TYPE_INPUT_METHOD) &#123;</div><div class="line">			<span class="comment">// NOTE -- system code, won't try to do compat mode.</span></div><div class="line">			Point size = <span class="keyword">new</span> Point();</div><div class="line">			mDisplay.getRealSize(size);</div><div class="line">			desiredWindowWidth = size.x;</div><div class="line">			desiredWindowHeight = size.y;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			DisplayMetrics packageMetrics =</div><div class="line">				mView.getContext().getResources().getDisplayMetrics();</div><div class="line">			desiredWindowWidth = packageMetrics.widthPixels;</div><div class="line">			desiredWindowHeight = packageMetrics.heightPixels;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// We used to use the following condition to choose 32 bits drawing caches:</span></div><div class="line">		<span class="comment">// PixelFormat.hasAlpha(lp.format) || lp.format == PixelFormat.RGBX_8888</span></div><div class="line">		<span class="comment">// However, windows are now always 32 bits by default, so choose 32 bits</span></div><div class="line">		mAttachInfo.mUse32BitDrawingCache = <span class="keyword">true</span>;</div><div class="line">		mAttachInfo.mHasWindowFocus = <span class="keyword">false</span>;</div><div class="line">		mAttachInfo.mWindowVisibility = viewVisibility;</div><div class="line">		mAttachInfo.mRecomputeGlobalAttributes = <span class="keyword">false</span>;</div><div class="line">		viewVisibilityChanged = <span class="keyword">false</span>;</div><div class="line">		mLastConfiguration.setTo(host.getResources().getConfiguration());</div><div class="line">		mLastSystemUiVisibility = mAttachInfo.mSystemUiVisibility;</div><div class="line">		<span class="comment">// Set the layout direction if it has not been set before (inherit is the default)</span></div><div class="line">		<span class="keyword">if</span> (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) &#123;</div><div class="line">			host.setLayoutDirection(mLastConfiguration.getLayoutDirection());</div><div class="line">		&#125;</div><div class="line">		host.dispatchAttachedToWindow(mAttachInfo, <span class="number">0</span>);</div><div class="line">		mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(<span class="keyword">true</span>);</div><div class="line">		dispatchApplyInsets(host);</div><div class="line">		<span class="comment">//Log.i(TAG, "Screen on initialized: " + attachInfo.mKeepScreenOn);</span></div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		desiredWindowWidth = frame.width();</div><div class="line">		desiredWindowHeight = frame.height();</div><div class="line">		<span class="keyword">if</span> (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) &#123;</div><div class="line">			<span class="keyword">if</span> (DEBUG_ORIENTATION) Log.v(TAG,</div><div class="line">					<span class="string">"View "</span> + host + <span class="string">" resized to: "</span> + frame);</div><div class="line">			mFullRedrawNeeded = <span class="keyword">true</span>;</div><div class="line">			mLayoutRequested = <span class="keyword">true</span>;</div><div class="line">			windowSizeMayChange = <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	...</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (mFirst || windowShouldResize || insetsChanged ||</div><div class="line">			viewVisibilityChanged || params != <span class="keyword">null</span>) &#123;</div><div class="line">		...</div><div class="line">		<span class="keyword">if</span> (!mStopped || mReportNextDraw) &#123;</div><div class="line">			<span class="keyword">boolean</span> focusChangedDueToTouchMode = ensureTouchModeLocally(</div><div class="line">					(relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != <span class="number">0</span>);</div><div class="line">			<span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</div><div class="line">					|| mHeight != host.getMeasuredHeight() || contentInsetsChanged) &#123;</div><div class="line">				<span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</div><div class="line">				<span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</div><div class="line"></div><div class="line">				<span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(TAG, <span class="string">"Ooops, something changed!  mWidth="</span></div><div class="line">						+ mWidth + <span class="string">" measuredWidth="</span> + host.getMeasuredWidth()</div><div class="line">						+ <span class="string">" mHeight="</span> + mHeight</div><div class="line">						+ <span class="string">" measuredHeight="</span> + host.getMeasuredHeight()</div><div class="line">						+ <span class="string">" coveredInsetsChanged="</span> + contentInsetsChanged);</div><div class="line"></div><div class="line">				 <span class="comment">// Ask host how big it wants to be</span></div><div class="line">				performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line"></div><div class="line">				<span class="comment">// Implementation of weights from WindowManager.LayoutParams</span></div><div class="line">				<span class="comment">// We just grow the dimensions as needed and re-measure if</span></div><div class="line">				<span class="comment">// needs be</span></div><div class="line">				<span class="keyword">int</span> width = host.getMeasuredWidth();</div><div class="line">				<span class="keyword">int</span> height = host.getMeasuredHeight();</div><div class="line">				<span class="keyword">boolean</span> measureAgain = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">				<span class="keyword">if</span> (lp.horizontalWeight &gt; <span class="number">0.0f</span>) &#123;</div><div class="line">					width += (<span class="keyword">int</span>) ((mWidth - width) * lp.horizontalWeight);</div><div class="line">					childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,</div><div class="line">							MeasureSpec.EXACTLY);</div><div class="line">					measureAgain = <span class="keyword">true</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> (lp.verticalWeight &gt; <span class="number">0.0f</span>) &#123;</div><div class="line">					height += (<span class="keyword">int</span>) ((mHeight - height) * lp.verticalWeight);</div><div class="line">					childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,</div><div class="line">							MeasureSpec.EXACTLY);</div><div class="line">					measureAgain = <span class="keyword">true</span>;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				<span class="keyword">if</span> (measureAgain) &#123;</div><div class="line">					<span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(TAG,</div><div class="line">							<span class="string">"And hey let's measure once more: width="</span> + width</div><div class="line">							+ <span class="string">" height="</span> + height);</div><div class="line">					performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				layoutRequested = <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</div><div class="line">	<span class="keyword">boolean</span> triggerGlobalLayoutListener = didLayout</div><div class="line">			|| mAttachInfo.mRecomputeGlobalAttributes;</div><div class="line">	<span class="keyword">if</span> (didLayout) &#123;</div><div class="line">		performLayout(lp, desiredWindowWidth, desiredWindowHeight);</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面截取了performTraversals的主要相关代码，在其中一般情况下蒋会执行performMeasure、performLayout、performDraw三个方法。调用<strong>performMeasure</strong>方法之前，会先分别对焦点、测量的宽高、View内容的变化情况进行判断，如果变化则会执行performMeasure。接着会检查窗口属性是否包含weight，如果包含蒋会再执行一次performMeasure方法，在之后会设置layoutRequested = true，表示需要重新布局。在执行<strong>performLayout</strong>方法之前，会对didLayout参数进行检查，判断是否请求重新布局，窗口是否停止，是否需要再次绘制，而layoutRequested参数再performMeasure后设置为true，mStopped默认为false，所以将执行performMeasure方法。<strong>performDraw</strong>方法就像在<a href="https://github.com/Idtk/Blog/blob/master/Blog/9%E3%80%81Invalidate.md" target="_blank" rel="external">自定义View——invalidate流程分析</a>中分析的一样，蒋会执行，但是在ViewRootImpl#draw中进行dirty判断时，会发现dirty为空，所以不会继续执行绘制过程。那么一般情况下的进行requestLayout请求后，view的重新绘制在什么地方呢？这将会在稍后的layout过程中看到答案。</p>
<h2 id="二、测量流程"><a href="#二、测量流程" class="headerlink" title="二、测量流程"></a>二、测量流程</h2><p>在查看performMeasure的源码之前，我们先看看传入performMeasure的两个参数childWidthMeasureSpec, childHeightMeasureSpec的获取，代码中可以看出参数是通过调用getRootMeasureSpec方法来获得，现在来看下getRootMeasureSpec的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> measureSpec;</div><div class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</div><div class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</div><div class="line">        <span class="comment">// Window can't resize. Force root view to be windowSize.</span></div><div class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</div><div class="line">        <span class="comment">// Window can resize. Set max size for root view.</span></div><div class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></div><div class="line">        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> measureSpec;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上述getRootMeasureSpec的代码，就可以清楚的看出LayoutParams与测量模式的对应关系。<br></p>
<table>
<thead>
<tr>
<th>LayoutParams</th>
<th style="text-align:center">Mode</th>
<th>size</th>
</tr>
</thead>
<tbody>
<tr>
<td>MATCH_PARENT</td>
<td style="text-align:center">EXACTLY</td>
<td>windowSize</td>
</tr>
<tr>
<td>WRAP_CONTENT</td>
<td style="text-align:center">AT_MOST</td>
<td>windowSize</td>
</tr>
<tr>
<td>固定大小</td>
<td style="text-align:center">EXACTLY</td>
<td>rootSize</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>我们继续看看performMeasure方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</div><div class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上述代码可以看出，将会执行View的measure方法，measure方法中将会执行onMeasure方法，ViewRootImpl的调用的view为DecorView(DecorView为布局的顶层view),现在来看看DecorView#onMeasure方法<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> DisplayMetrics metrics = getContext().getResources().getDisplayMetrics();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isPortrait = metrics.widthPixels &lt; metrics.heightPixels;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> widthMode = getMode(widthMeasureSpec);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> heightMode = getMode(heightMeasureSpec);</div><div class="line">    <span class="keyword">boolean</span> fixedWidth = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (widthMode == AT_MOST) &#123;</div><div class="line">        <span class="keyword">final</span> TypedValue tvw = isPortrait ? mFixedWidthMinor : mFixedWidthMajor;</div><div class="line">		<span class="comment">// tvw不会为NULL，等级也不会为NULL，具体原因可以跟踪一下源码。</span></div><div class="line">        <span class="keyword">if</span> (tvw != <span class="keyword">null</span> &amp;&amp; tvw.type != TypedValue.TYPE_NULL) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> w;</div><div class="line">			<span class="comment">// 获取视图宽度</span></div><div class="line">            <span class="keyword">if</span> (tvw.type == TypedValue.TYPE_DIMENSION) &#123;</div><div class="line">                w = (<span class="keyword">int</span>) tvw.getDimension(metrics);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tvw.type == TypedValue.TYPE_FRACTION) &#123;</div><div class="line">                w = (<span class="keyword">int</span>) tvw.getFraction(metrics.widthPixels, metrics.widthPixels);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                w = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">			<span class="comment">// 设置测量模式为EXACTLY</span></div><div class="line">            <span class="keyword">if</span> (w &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">                widthMeasureSpec = MeasureSpec.makeMeasureSpec(</div><div class="line">                        Math.min(w, widthSize), EXACTLY);</div><div class="line">                fixedWidth = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// heightMode的处理方式与widthMode相同</span></div><div class="line">    <span class="keyword">if</span> (heightMode == AT_MOST) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码中，将会分别检查宽高测量模式，这里以宽度测量属性为例，首先检查测量模式是否为AT_MOST，如果是，则获取视图的宽度，然后与宽度测量属性的大小取小，接着与测量模式EXACTLY，作为MeasureSpec.makeMeasureSpec方法的参数一起生成新的宽度测量属性。之后会把新生成的测量属性传递给DecorView的父类，也就是FrameLayout的onMeasure方法继续处理。我们来看看它是怎么做的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> count = getChildCount();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> measureMatchParentChildren =</div><div class="line">            MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</div><div class="line">            MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</div><div class="line">    mMatchParentChildren.clear();</div><div class="line">    <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> childState = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        <span class="keyword">final</span> View child = getChildAt(i);</div><div class="line">        <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</div><div class="line">            measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</div><div class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class="line">			<span class="comment">// 获取子view中最大的宽度和高度</span></div><div class="line">            maxWidth = Math.max(maxWidth,</div><div class="line">                    child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</div><div class="line">            maxHeight = Math.max(maxHeight,</div><div class="line">                    child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</div><div class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</div><div class="line">            <span class="keyword">if</span> (measureMatchParentChildren) &#123;</div><div class="line">				<span class="comment">// 如果子View的宽or高为MATCH_PARENT，则保存子View</span></div><div class="line">                <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</div><div class="line">                        lp.height == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                    mMatchParentChildren.add(child);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Account for padding too</span></div><div class="line">    maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</div><div class="line">    maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</div><div class="line">    <span class="comment">// Check against our minimum height and width</span></div><div class="line">    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</div><div class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</div><div class="line">    <span class="comment">// Check against our foreground's minimum height and width</span></div><div class="line">    <span class="keyword">final</span> Drawable drawable = getForeground();</div><div class="line">    <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</div><div class="line">        maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</div><div class="line">        maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 保存测量结果</span></div><div class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</div><div class="line">            resolveSizeAndState(maxHeight, heightMeasureSpec,</div><div class="line">                    childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</div><div class="line">    count = mMatchParentChildren.size();</div><div class="line">	<span class="comment">// 对之前保存的子view，分别重新测量MeasureSpec</span></div><div class="line">    <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            <span class="keyword">final</span> View child = mMatchParentChildren.get(i);</div><div class="line">            <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec;</div><div class="line">            <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> width = Math.max(<span class="number">0</span>, getMeasuredWidth()</div><div class="line">                        - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</div><div class="line">                        - lp.leftMargin - lp.rightMargin);</div><div class="line">                childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</div><div class="line">                        width, MeasureSpec.EXACTLY);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</div><div class="line">                        getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</div><div class="line">                        lp.leftMargin + lp.rightMargin,</div><div class="line">                        lp.width);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec;</div><div class="line">            <span class="keyword">if</span> (lp.height == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> height = Math.max(<span class="number">0</span>, getMeasuredHeight()</div><div class="line">                        - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</div><div class="line">                        - lp.topMargin - lp.bottomMargin);</div><div class="line">                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</div><div class="line">                        height, MeasureSpec.EXACTLY);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,</div><div class="line">                        getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</div><div class="line">                        lp.topMargin + lp.bottomMargin,</div><div class="line">                        lp.height);</div><div class="line">            &#125;</div><div class="line">			<span class="comment">// 测量子View</span></div><div class="line">            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>FrameLayout的测量过程中，首先遍历子View，调用measureChildWithMargins方法，之后获取子view中的最大宽度or高度，这是因为FrameLayout的布局，如果在wrap_content的情况下，其宽度就等于所以子View中的最大宽度，高度就等于所以子View中最大的高度。然后对子View的宽or高为MATCH_PARENT的View进行存储。之后处理一些属性，保存测量结果。resolveSizeAndState方法，我已经在之前的<a href="https://github.com/Idtk/Blog/blob/master/Blog/7%E3%80%81RadarChart.md" target="_blank" rel="external">自定义View——雷达图(蜘蛛网图)</a>中进行过分析。最后就是对之前保存的子view进行处理了。从measureChildWithMargins方法的参数可以看出，测量值与view的测量值以及子view相关，现在我们来看下它的测量过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></div><div class="line">        <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</div><div class="line">        <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed) &#123;</div><div class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                    + widthUsed, lp.width);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                    + heightUsed, lp.height);</div><div class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述方法中，会先调用getChildMeasureSpec方法，获取测量的宽高属性之后，最后对子View进行测量。由代码可以看出测量属性的获取与父view的MeasureSpec、View的padding、子View的LayoutParams相关，具体的关系我们来看看ViewGroup的getChildMeasureSpec方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</div><div class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</div><div class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">    <span class="comment">// Parent has imposed an exact size on us</span></div><div class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">            resultSize = childDimension;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">            <span class="comment">// Child wants to be our size. So be it.</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">            <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">            <span class="comment">// bigger than us.</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.AT_MOST;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="comment">// Parent has imposed a maximum size on us</span></div><div class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// Child wants a specific size... so be it</span></div><div class="line">            resultSize = childDimension;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">            <span class="comment">// Child wants to be our size, but our size is not fixed.</span></div><div class="line">            <span class="comment">// Constrain child to not be bigger than us.</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.AT_MOST;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">            <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">            <span class="comment">// bigger than us.</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.AT_MOST;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="comment">// Parent asked to see how big we want to be</span></div><div class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// Child wants a specific size... let him have it</span></div><div class="line">            resultSize = childDimension;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">            <span class="comment">// Child wants to be our size... find out how big it should</span></div><div class="line">            <span class="comment">// be</span></div><div class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">            resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">            <span class="comment">// Child wants to determine its own size.... find out how</span></div><div class="line">            <span class="comment">// big it should be</span></div><div class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">            resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述方法并不难，写的如此有规律，它主要是根据View的MeasureSpec与子View的LayoutParams参数来确定子View的MeasureSpec属性。接下来，我们为getChildMeasureSpec方法的逻辑建立一个表格。<br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/getChildMeasureSpec.png" alt="getChildMeasureSpec" title="getChildMeasureSpec" width="800"><br><br><br></p>
<p>现在我们回到measureChildWithMargins方法，测量完成之后，就是对子View的测量，DecorView的子View就是我们平时setContentView中的布局，这里以LinearLayout为例。自然也是和之前一样LinearLayout的measure调用onMeasure，直接来看看LinearLayout#onMeasure<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</div><div class="line">        measureVertical(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        measureHorizontal(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码可以看出，LinearLayout将根据属性来选择一种测量方式，我们选择LinearLayout的水平布局的测量方式，即measureHorizontal，这里简单的挑选其中的主要部分说明一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureHorizontal</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">	...</div><div class="line">	<span class="comment">// See how wide everyone is. Also remember max height.</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">		<span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line">		...</div><div class="line">		<span class="keyword">final</span> LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)</div><div class="line">				child.getLayoutParams();</div><div class="line">		<span class="comment">// 计算比重</span></div><div class="line">		totalWeight += lp.weight;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (widthMode == MeasureSpec.EXACTLY &amp;&amp; lp.width == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</div><div class="line">			<span class="comment">// Optimization: don't bother measuring children who are going to use</span></div><div class="line">			<span class="comment">// leftover space. These views will get measured again down below if</span></div><div class="line">			<span class="comment">// there is any leftover space.</span></div><div class="line">			<span class="keyword">if</span> (isExactly) &#123;</div><div class="line">				mTotalLength += lp.leftMargin + lp.rightMargin;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">				mTotalLength = Math.max(totalLength, totalLength +</div><div class="line">						lp.leftMargin + lp.rightMargin);</div><div class="line">			&#125;</div><div class="line">			...</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">int</span> oldWidth = Integer.MIN_VALUE;</div><div class="line">			<span class="comment">//子View宽度为0，有weight，LayoutParams为WRAP_CONTENT，</span></div><div class="line">			<span class="comment">//转换父view的LayoutParams为WRAP_CONTENT</span></div><div class="line">			<span class="keyword">if</span> (lp.width == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</div><div class="line">				<span class="comment">// widthMode is either UNSPECIFIED or AT_MOST, and this</span></div><div class="line">				<span class="comment">// child</span></div><div class="line">				<span class="comment">// wanted to stretch to fill available space. Translate that to</span></div><div class="line">				<span class="comment">// WRAP_CONTENT so that it does not end up with a width of 0</span></div><div class="line">				oldWidth = <span class="number">0</span>;</div><div class="line">				lp.width = LayoutParams.WRAP_CONTENT;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// Determine how big this child would like to be. If this or</span></div><div class="line">			<span class="comment">// previous children have given a weight, then we allow it to</span></div><div class="line">			<span class="comment">// use all available space (and we will shrink things later</span></div><div class="line">			<span class="comment">// if needed).</span></div><div class="line">			<span class="comment">// 测量子View，调用之前说的measureChildWithMargins()方法</span></div><div class="line">			measureChildBeforeLayout(child, i, widthMeasureSpec,</div><div class="line">					totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>,</div><div class="line">					heightMeasureSpec, <span class="number">0</span>);</div><div class="line">			...</div><div class="line">		&#125;</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line"></div><div class="line">	<span class="comment">// Add in our padding</span></div><div class="line">	<span class="comment">//处理padding</span></div><div class="line">	mTotalLength += mPaddingLeft + mPaddingRight;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> widthSize = mTotalLength;</div><div class="line"></div><div class="line">	<span class="comment">// Check against our minimum width</span></div><div class="line">	<span class="comment">//view高度与背景尺寸和mMinWidth的运算结果比较，取最大值</span></div><div class="line">	widthSize = Math.max(widthSize, getSuggestedMinimumWidth());</div><div class="line"></div><div class="line">	<span class="comment">// Reconcile our calculated size with the widthMeasureSpec</span></div><div class="line">	<span class="comment">// MEASURED_SIZE_MASK = 0x00ffffff，取得测量属性的后30位，即尺寸</span></div><div class="line">	<span class="keyword">int</span> widthSizeAndState = resolveSizeAndState(widthSize, widthMeasureSpec, <span class="number">0</span>);</div><div class="line">	widthSize = widthSizeAndState &amp; MEASURED_SIZE_MASK;</div><div class="line"></div><div class="line">	<span class="comment">// Either expand children with weight to take up available space or</span></div><div class="line">	<span class="comment">// shrink them if they extend beyond our current bounds. If we skipped</span></div><div class="line">	<span class="comment">// measurement on any children, we need to measure them now.</span></div><div class="line">	<span class="keyword">int</span> delta = widthSize - mTotalLength;</div><div class="line">	<span class="keyword">if</span> (skippedMeasure || delta != <span class="number">0</span> &amp;&amp; totalWeight &gt; <span class="number">0.0f</span>) &#123;</div><div class="line">		<span class="keyword">float</span> weightSum = mWeightSum &gt; <span class="number">0.0f</span> ? mWeightSum : totalWeight;</div><div class="line"></div><div class="line">		maxAscent[<span class="number">0</span>] = maxAscent[<span class="number">1</span>] = maxAscent[<span class="number">2</span>] = maxAscent[<span class="number">3</span>] = -<span class="number">1</span>;</div><div class="line">		maxDescent[<span class="number">0</span>] = maxDescent[<span class="number">1</span>] = maxDescent[<span class="number">2</span>] = maxDescent[<span class="number">3</span>] = -<span class="number">1</span>;</div><div class="line">		maxHeight = -<span class="number">1</span>;</div><div class="line"></div><div class="line">		mTotalLength = <span class="number">0</span>;</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">			<span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (child == <span class="keyword">null</span> || child.getVisibility() == View.GONE) &#123;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="keyword">final</span> LinearLayout.LayoutParams lp =</div><div class="line">					(LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">			<span class="keyword">float</span> childExtra = lp.weight;</div><div class="line">			<span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</div><div class="line">				<span class="comment">// Child said it could absorb extra space -- give him his share</span></div><div class="line">				<span class="comment">// 高度 = 子View的weight*剩余高度/总weight</span></div><div class="line">				<span class="keyword">int</span> share = (<span class="keyword">int</span>) (childExtra * delta / weightSum);</div><div class="line">				weightSum -= childExtra;</div><div class="line">				delta -= share;</div><div class="line">				<span class="comment">//测量子View</span></div><div class="line">				<span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(</div><div class="line">						heightMeasureSpec,</div><div class="line">						mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin,</div><div class="line">						lp.height);</div><div class="line"></div><div class="line">				<span class="comment">// <span class="doctag">TODO:</span> Use a field like lp.isMeasured to figure out if this</span></div><div class="line">				<span class="comment">// child has been previously measured</span></div><div class="line">				<span class="keyword">if</span> ((lp.width != <span class="number">0</span>) || (widthMode != MeasureSpec.EXACTLY)) &#123;</div><div class="line">					<span class="comment">// child was measured once already above ... base new measurement</span></div><div class="line">					<span class="comment">// on stored values</span></div><div class="line">					<span class="keyword">int</span> childWidth = child.getMeasuredWidth() + share;</div><div class="line">					<span class="keyword">if</span> (childWidth &lt; <span class="number">0</span>) &#123;</div><div class="line">						childWidth = <span class="number">0</span>;</div><div class="line">					&#125;</div><div class="line"></div><div class="line">					child.measure(</div><div class="line">						MeasureSpec.makeMeasureSpec(childWidth, MeasureSpec.EXACTLY),</div><div class="line">						childHeightMeasureSpec);</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					<span class="comment">// child was skipped in the loop above. Measure for this first time here</span></div><div class="line">					child.measure(MeasureSpec.makeMeasureSpec(</div><div class="line">							share &gt; <span class="number">0</span> ? share : <span class="number">0</span>, MeasureSpec.EXACTLY),</div><div class="line">							childHeightMeasureSpec);</div><div class="line">				&#125;</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码，在关键部分增加了一些注释，这里再简单说一下，遍历子View，计算下当前的比重，之后调用measureChildBeforeLayout方法，这个方法将会调用我们之前说的measureChildWithMargins()方法，来完成对子View的测量。接下来用view当前宽度与背景宽度和mMinWidth的运算结果比较，取最大值；再使用resolveSizeAndState(<a href="https://github.com/Idtk/Blog/blob/master/Blog/7%E3%80%81RadarChart.md" target="_blank" rel="external">自定义View——雷达图(蜘蛛网图)</a>)方法获取测量属性，之后与MEASURED_SIZE_MASK按位与获取view的宽度值。然后再按照weight的属性，对view的剩余宽度进行分配，之后调用getChildMeasureSpec方法进行测量值获取。最后依旧使用child.measure方法，继续对子View进行测量。<br></p>
<p>现在测量流程到了LinearLayout的子View，我们这里假设是一个View。自然也是调用View的measure方法，之后调用onMeasure方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码就是默认的View测量方法，其中setMeasuredDimension将会设置View的测量值，这里需要关注的是getDefaultSize方法，这在我之前的文章<a href="https://github.com/Idtk/Blog/blob/master/Blog/7%E3%80%81RadarChart.md" target="_blank" rel="external">自定义View——雷达图(蜘蛛网图)</a>，已经进行了分析。但是getDefaultSize方法一般是无法满足我们对LayoutParams = wrap_content情况下的测量要求的，需要我们自己进行一定的修改。<br></p>
<p>现在已经完成了整个View的测量过程，在整个测量的过程中，我们不断的通过child.measure对子View进行测量，而测量值的获取主要根据View的MeasureSpec、padding，子View的size、LayoutParams、margin以及View的自身特性(比如weight)等属性来完成，这也是我们自己在自定义View时，编写onMeaure方法的主要方式。</p>
<h2 id="三、布局流程"><a href="#三、布局流程" class="headerlink" title="三、布局流程"></a>三、布局流程</h2><p>接着第一节的结尾，Layout流程的分析从ViewRootImpl的performLayout开始<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth,</span></span></div><div class="line">		<span class="keyword">int</span> desiredWindowHeight) &#123;</div><div class="line">	mLayoutRequested = <span class="keyword">false</span>;</div><div class="line">	mScrollMayChange = <span class="keyword">true</span>;</div><div class="line">	mInLayout = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">	<span class="keyword">final</span> View host = mView;</div><div class="line">	Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"layout"</span>);</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</div><div class="line">		...</div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">		Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">	&#125;</div><div class="line">	mInLayout = <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>布局流程中View的组成和测量流程中一样(DecorView→LinearLayout→View)，上述代码，调用了DecorView的layout方法(即View的layout方法)，并传入了参数。left、top传入0，rigth传入host.getMeasuredWidth()，bottom传入host.getMeasuredHeight()。接着来看看layout方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</div><div class="line">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> oldL = mLeft;</div><div class="line">    <span class="keyword">int</span> oldT = mTop;</div><div class="line">    <span class="keyword">int</span> oldB = mBottom;</div><div class="line">    <span class="keyword">int</span> oldR = mRight;</div><div class="line">	<span class="comment">// 这里会判断要不要invalidate</span></div><div class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line">	<span class="comment">// 验证PFLAG_LAYOUT_REQUIRED标记</span></div><div class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">		<span class="comment">// 需要自定义的确定子布局方法</span></div><div class="line">        onLayout(changed, l, t, r, b);</div><div class="line">		<span class="comment">// 去除measure时增加的标记</span></div><div class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line">        ListenerInfo li = mListenerInfo;</div><div class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</div><div class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">            <span class="keyword">int</span> numListeners = listenersCopy.size();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">                listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 去除在requestLayout中增加的标记</span></div><div class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码在主要部分都进行了注释，这里主要看下setFrame方法，使用这个方法传入l, t, r, b，用于确定view在父View中的位置。setOpticalFrame方法最终也会调用setFrame，我们来看下setFrame方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</div><div class="line">        changed = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">// Remember our drawn bit</span></div><div class="line">        <span class="keyword">int</span> drawn = mPrivateFlags &amp; PFLAG_DRAWN;</div><div class="line">        <span class="keyword">int</span> oldWidth = mRight - mLeft;</div><div class="line">        <span class="keyword">int</span> oldHeight = mBottom - mTop;</div><div class="line">        <span class="keyword">int</span> newWidth = right - left;</div><div class="line">        <span class="keyword">int</span> newHeight = bottom - top;</div><div class="line">        <span class="keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</div><div class="line">        <span class="comment">// Invalidate our old position</span></div><div class="line">        invalidate(sizeChanged);</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> changed;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上述代码可以看出，在setFrame中我们将会判断新旧的位置参数，如果有一个不相等，则会发起invalidate请求，进行View重绘。看到这里也就明白，为什么在requestLayout之后一般都会进行View重绘了。<br><br>现在继续来看上面的DecorView#layout方法，在判断是否需要invalidate之后，将会进行PFLAG_LAYOUT_REQUIRED标记的验证，之后运行DecorView的onLayout方法，它会对超出的View会进行平移，这个只是提一下，主要关注的是其继承的FrameLayout的onLayout方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">	layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom,</span></span></div><div class="line">							  <span class="keyword">boolean</span> forceLeftGravity) &#123;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</div><div class="line"></div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> parentLeft = getPaddingLeftWithForeground();</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> parentRight = right - left - getPaddingRightWithForeground();</div><div class="line"></div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> parentTop = getPaddingTopWithForeground();</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> parentBottom = bottom - top - getPaddingBottomWithForeground();</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">		<span class="keyword">final</span> View child = getChildAt(i);</div><div class="line">		<span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</div><div class="line">			<span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">			<span class="keyword">final</span> <span class="keyword">int</span> width = child.getMeasuredWidth();</div><div class="line">			<span class="keyword">final</span> <span class="keyword">int</span> height = child.getMeasuredHeight();</div><div class="line"></div><div class="line">			<span class="keyword">int</span> childLeft;</div><div class="line">			<span class="keyword">int</span> childTop;</div><div class="line"></div><div class="line">			<span class="keyword">int</span> gravity = lp.gravity;</div><div class="line">			<span class="keyword">if</span> (gravity == -<span class="number">1</span>) &#123;</div><div class="line">				gravity = DEFAULT_CHILD_GRAVITY;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</div><div class="line">			<span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</div><div class="line">			<span class="keyword">final</span> <span class="keyword">int</span> verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</div><div class="line">			<span class="comment">// 根据不同属性确定子View的位置</span></div><div class="line">			<span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</div><div class="line">				<span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</div><div class="line">					childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> +</div><div class="line">					lp.leftMargin - lp.rightMargin;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">case</span> Gravity.RIGHT:</div><div class="line">					<span class="keyword">if</span> (!forceLeftGravity) &#123;</div><div class="line">						childLeft = parentRight - width - lp.rightMargin;</div><div class="line">						<span class="keyword">break</span>;</div><div class="line">					&#125;</div><div class="line">				<span class="keyword">case</span> Gravity.LEFT:</div><div class="line">				<span class="keyword">default</span>:</div><div class="line">					childLeft = parentLeft + lp.leftMargin;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="keyword">switch</span> (verticalGravity) &#123;</div><div class="line">				<span class="keyword">case</span> Gravity.TOP:</div><div class="line">					childTop = parentTop + lp.topMargin;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">case</span> Gravity.CENTER_VERTICAL:</div><div class="line">					childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> +</div><div class="line">					lp.topMargin - lp.bottomMargin;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">case</span> Gravity.BOTTOM:</div><div class="line">					childTop = parentBottom - height - lp.bottomMargin;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">default</span>:</div><div class="line">					childTop = parentTop + lp.topMargin;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			child.layout(childLeft, childTop, childLeft + width, childTop + height);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码中，主要是遍历所有子View，根据不同的居中情况(如果设置了居中属性的话)，重新确定子View的left与top布局，之后根据这些位置以及View测量的宽高，确定right、bottom的位置，最后传递给子View的layout方法。这里的子View按照我们之前在measure中的流程，就是LinearLayout，我们来看看他的onLayout方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</div><div class="line">        layoutVertical(l, t, r, b);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        layoutHorizontal(l, t, r, b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>LinearLayout的onLyaout方法和onMeasure的逻辑一样，根据LinearLayout属性来选择布局方法，我们也和上次一样选取layoutHorizontal方法看看，这里截取了其中的主要代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutHorizontal</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">	...</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</div><div class="line">	...</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">		<span class="keyword">int</span> childIndex = start + dir * i;</div><div class="line">		<span class="keyword">final</span> View child = getVirtualChildAt(childIndex);</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">			childLeft += measureNullChild(childIndex);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</div><div class="line">			<span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</div><div class="line">			<span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</div><div class="line">			<span class="keyword">int</span> childBaseline = -<span class="number">1</span>;</div><div class="line"></div><div class="line">			<span class="keyword">final</span> LinearLayout.LayoutParams lp =</div><div class="line">					(LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (baselineAligned &amp;&amp; lp.height != LayoutParams.MATCH_PARENT) &#123;</div><div class="line">				childBaseline = child.getBaseline();</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="keyword">int</span> gravity = lp.gravity;</div><div class="line">			<span class="keyword">if</span> (gravity &lt; <span class="number">0</span>) &#123;</div><div class="line">				gravity = minorGravity;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="keyword">switch</span> (gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) &#123;</div><div class="line">				<span class="keyword">case</span> Gravity.TOP:</div><div class="line">					childTop = paddingTop + lp.topMargin;</div><div class="line">					<span class="keyword">if</span> (childBaseline != -<span class="number">1</span>) &#123;</div><div class="line">						childTop += maxAscent[INDEX_TOP] - childBaseline;</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line"></div><div class="line">				<span class="keyword">case</span> Gravity.CENTER_VERTICAL:</div><div class="line">					<span class="comment">// Removed support for baseline alignment when layout_gravity or</span></div><div class="line">					<span class="comment">// gravity == center_vertical. See bug #1038483.</span></div><div class="line">					<span class="comment">// Keep the code around if we need to re-enable this feature</span></div><div class="line">					<span class="comment">// if (childBaseline != -1) &#123;</span></div><div class="line">					<span class="comment">//     // Align baselines vertically only if the child is smaller than us</span></div><div class="line">					<span class="comment">//     if (childSpace - childHeight &gt; 0) &#123;</span></div><div class="line">					<span class="comment">//         childTop = paddingTop + (childSpace / 2) - childBaseline;</span></div><div class="line">					<span class="comment">//     &#125; else &#123;</span></div><div class="line">					<span class="comment">//         childTop = paddingTop + (childSpace - childHeight) / 2;</span></div><div class="line">					<span class="comment">//     &#125;</span></div><div class="line">					<span class="comment">// &#125; else &#123;</span></div><div class="line">					childTop = paddingTop + ((childSpace - childHeight) / <span class="number">2</span>)</div><div class="line">							+ lp.topMargin - lp.bottomMargin;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line"></div><div class="line">				<span class="keyword">case</span> Gravity.BOTTOM:</div><div class="line">					childTop = childBottom - childHeight - lp.bottomMargin;</div><div class="line">					<span class="keyword">if</span> (childBaseline != -<span class="number">1</span>) &#123;</div><div class="line">						<span class="keyword">int</span> descent = child.getMeasuredHeight() - childBaseline;</div><div class="line">						childTop -= (maxDescent[INDEX_BOTTOM] - descent);</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">default</span>:</div><div class="line">					childTop = paddingTop;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (hasDividerBeforeChildAt(childIndex)) &#123;</div><div class="line">				childLeft += mDividerWidth;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			childLeft += lp.leftMargin;</div><div class="line">			<span class="comment">// 确定子View布局</span></div><div class="line">			setChildFrame(child, childLeft + getLocationOffset(child), childTop,</div><div class="line">					childWidth, childHeight);</div><div class="line">			<span class="comment">// 不断增大的childLeft</span></div><div class="line">			childLeft += childWidth + lp.rightMargin +</div><div class="line">					getNextLocationOffset(child);</div><div class="line"></div><div class="line">			i += getChildrenSkipCount(child, childIndex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上述代码中，会遍历所有的子View，并根据它的居中属性，对childTop进行调整。调用setChildFrame方法来确定子View的布局，如果你跟踪一下，你会发现，它其实调用了child.layout方法，同时每次调用之后，不断增大当前的childLeft，以使下一次的布局不断平移。<br></p>
<p>按照measure的流程，接下来应该是View的layout流程，View#layout方法，之后又跳转到View的onLayout方法，这个方法只是一个空的实现，一般情况下我们也不需要重载该方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们已经完成了layout方法的分析。<br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/requestLayout.png" alt="requestLayout" title="requestLayout" width="800"><br></p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本文分析了View的requestLayout流程，并以DecorView和LinearLayout为例，对View的测量流程、布局流程进行了分析。如果在阅读过程中，有任何疑问与问题，欢迎与我联系。<br></p>
<p><strong>博客:www.idtkm.com</strong><br><br><strong>GitHub:<a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><br><strong>微博:<a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><br><strong>邮箱:IdtkMa@gmail.com</strong><br><br><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;在之前的&lt;a href=&quot;https://github.com/Idtk/Blog/blob/master/Blog/9%E3%80%81Invalidate.md&quot;&gt;invalidate传递与绘制流程分析&lt;/a&gt;文章中我们对invalidate的流程进行了详细分析，现在来继续分析下requestLayout的流程吧&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Idtk/Blog&quot;&gt;自定义View系列目录&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、requestLayout的请求传递&quot;&gt;&lt;a href=&quot;#一、requestLayout的请求传递&quot; class=&quot;headerlink&quot; title=&quot;一、requestLayout的请求传递&quot;&gt;&lt;/a&gt;一、requestLayout的请求传递&lt;/h2&gt;&lt;p&gt;我们从View#requestLayout方法的源码开始&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;requestLayout&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mMeasureCache != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) mMeasureCache.clear();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mAttachInfo != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; mAttachInfo.mViewRequestingLayout == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Only trigger request-during-layout logic if this is the view requesting it,&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// not the views in its parent hierarchy&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ViewRootImpl viewRoot = getViewRootImpl();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (viewRoot != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; viewRoot.isInLayout()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!viewRoot.requestLayoutDuringLayout(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        mAttachInfo.mViewRequestingLayout = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 增加PFLAG_FORCE_LAYOUT标记，在measure时会校验此属性&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    mPrivateFlags |= PFLAG_FORCE_LAYOUT;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    mPrivateFlags |= PFLAG_INVALIDATED;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 父类不为空&amp;amp;&amp;amp;父类没有请求重新布局(是否有PFLAG_FORCE_LAYOUT标志)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mParent != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !mParent.isLayoutRequested()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// 调用父类的requestLayout&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        mParent.requestLayout();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mAttachInfo != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; mAttachInfo.mViewRequestingLayout == &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        mAttachInfo.mViewRequestingLayout = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="CustomView" scheme="http://www.idtkm.com/tags/CustomView/"/>
    
  </entry>
  
  <entry>
    <title>View的invalidate传递与绘制流程分析</title>
    <link href="http://www.idtkm.com/2016/08/02/9%E3%80%81Invalidate/"/>
    <id>http://www.idtkm.com/2016/08/02/9、Invalidate/</id>
    <published>2016-08-01T16:00:00.000Z</published>
    <updated>2017-10-15T16:01:35.384Z</updated>
    
    <content type="html"><![CDATA[<p><strong>上一篇文章<a href="http://www.idtkm.com/customview/customview8/">自定义View——View的弹性滑动</a>中，我们对View的滑动进行了实战以及简单分析。但在文章的最后，仍然遗留了两个问题,第一个是invalidate与postInvalidate有什么区别呢？第二个是invalidate是如何调用computeScroll()方法的呢？这两个问题将在这一篇文章中进行分析。</strong></p>
<p><a href="https://github.com/Idtk/Blog" target="_blank" rel="external">自定义View系列目录</a></p>
<h2 id="一、invalidate与postInvalidate"><a href="#一、invalidate与postInvalidate" class="headerlink" title="一、invalidate与postInvalidate"></a>一、invalidate与postInvalidate</h2><p>invalidate与postInvadlidate都是用于请求View重绘的API，invalidate在主线程中进行调用，而postInvadlidate则在子线程中进行调用。<br><br>我们来分析下postInvadlidate的源码 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postInvalidate</span><span class="params">()</span> </span>&#123;</div><div class="line">    postInvalidateDelayed(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>postInvalidate()蒋会调用postInvalidateDelayed(0)方法，继续跟进。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postInvalidateDelayed</span><span class="params">(<span class="keyword">long</span> delayMilliseconds)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</div><div class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</div><div class="line">        attachInfo.mViewRootImpl.dispatchInvalidateDelayed(<span class="keyword">this</span>, delayMilliseconds);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>postInvalidateDelayed方法，通过attachInfo获取到当前的ViewRootImpl对象，调用它的dispatchInvalidateDelayed方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchInvalidateDelayed</span><span class="params">(View view, <span class="keyword">long</span> delayMilliseconds)</span> </span>&#123;</div><div class="line">    Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view);</div><div class="line">    mHandler.sendMessageDelayed(msg, delayMilliseconds);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>从上面的源码已经可以看出，postInvalidate的子线程这一个特性了。再继续跟下去看看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">    <span class="keyword">case</span> MSG_INVALIDATE:</div><div class="line">        ((View) msg.obj).invalidate();</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">	...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码跟到这里，也就明白了，postInvalidate通过sendMessageDelayed的方法，加入到了looper中，之后在handleMessage中再调用对应View的invalidate()方法，请求View重绘。</p>
<h2 id="二、invalidate流程分析"><a href="#二、invalidate流程分析" class="headerlink" title="二、invalidate流程分析"></a>二、invalidate流程分析</h2><p>现在我们来看看invalidate是如何让View进行重绘的呢？<br><br><strong>(PS:我这里使用的API版本为23，具体的代码可能和其他的版本有稍许不同)</strong></p>
<h3 id="1、invalidate的请求传递"><a href="#1、invalidate的请求传递" class="headerlink" title="1、invalidate的请求传递"></a>1、invalidate的请求传递</h3><p>我们的旅程从View的invalidate传递过程开始<br></p>
<p>现在来看看View#invalidate()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</div><div class="line">    invalidate(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(<span class="keyword">boolean</span> invalidateCache)</span> </span>&#123;</div><div class="line">    invalidateInternal(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop, invalidateCache, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>invalidate调用View#invalidateInternal方法传入当前View的位置参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalidateInternal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b, <span class="keyword">boolean</span> invalidateCache,</span></span></div><div class="line">        <span class="keyword">boolean</span> fullInvalidate) &#123;</div><div class="line"></div><div class="line">	<span class="comment">// 如果View重绘，则它也将重绘</span></div><div class="line">    <span class="keyword">if</span> (mGhostView != <span class="keyword">null</span>) &#123;</div><div class="line">        mGhostView.invalidate(<span class="keyword">true</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">// View是否可见，是否在动画运行中</span></div><div class="line">    <span class="keyword">if</span> (skipInvalidate()) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">// 根据View的标记来判断View是否需要进行重绘</span></div><div class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)</div><div class="line">            || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)</div><div class="line">            || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED</div><div class="line">            || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123;</div><div class="line">        <span class="keyword">if</span> (fullInvalidate) &#123;</div><div class="line">            mLastIsOpaque = isOpaque();</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_DRAWN;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">		<span class="comment">// 设置标志，表明View正在被重绘</span></div><div class="line">        mPrivateFlags |= PFLAG_DIRTY;</div><div class="line">		<span class="comment">//清除缓存，设置标志，表明重绘由当前View发起</span></div><div class="line">        <span class="keyword">if</span> (invalidateCache) &#123;</div><div class="line">            mPrivateFlags |= PFLAG_INVALIDATED;</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 把需要重绘的View区域传递给父View</span></div><div class="line">        <span class="keyword">final</span> AttachInfo ai = mAttachInfo;</div><div class="line">        <span class="keyword">final</span> ViewParent p = mParent;</div><div class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; ai != <span class="keyword">null</span> &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</div><div class="line">            <span class="keyword">final</span> Rect damage = ai.mTmpInvalRect;</div><div class="line">			<span class="comment">// 设置重绘区域</span></div><div class="line">            damage.set(l, t, r, b);</div><div class="line">			<span class="comment">// 关键代码，调用父View的方法，向上传递重绘事件</span></div><div class="line">            p.invalidateChild(<span class="keyword">this</span>, damage);</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码中，会判断当前View的状态，是否需要进行重绘，之后设置一系列标记位。通过父View的invalidateChild(this, damage)方法，将需要重绘的区域传递给父View。<br><br>接着来看下ViewGroup#invalidateChild方法，这里仅截取了其中的主要代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invalidateChild</span><span class="params">(View child, <span class="keyword">final</span> Rect dirty)</span> </span>&#123;</div><div class="line">    ViewParent parent = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</div><div class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</div><div class="line">        ...</div><div class="line">		<span class="comment">// 保存子View的left、top</span></div><div class="line">		<span class="keyword">final</span> <span class="keyword">int</span>[] location = attachInfo.mInvalidateChildLocation;</div><div class="line">		location[CHILD_LEFT_INDEX] = child.mLeft;</div><div class="line">		location[CHILD_TOP_INDEX] = child.mTop;</div><div class="line">        <span class="keyword">if</span> (!childMatrix.isIdentity() ||</div><div class="line">                (mGroupFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != <span class="number">0</span>) &#123;</div><div class="line">            RectF boundingRect = attachInfo.mTmpTransformRect;</div><div class="line">            boundingRect.set(dirty);</div><div class="line">            Matrix transformMatrix;</div><div class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != <span class="number">0</span>) &#123;</div><div class="line">                Transformation t = attachInfo.mTmpTransformation;</div><div class="line">                <span class="keyword">boolean</span> transformed = getChildStaticTransformation(child, t);</div><div class="line">                <span class="keyword">if</span> (transformed) &#123;</div><div class="line">                    transformMatrix = attachInfo.mTmpMatrix;</div><div class="line">                    transformMatrix.set(t.getMatrix());</div><div class="line">                    <span class="keyword">if</span> (!childMatrix.isIdentity()) &#123;</div><div class="line">                        transformMatrix.preConcat(childMatrix);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    transformMatrix = childMatrix;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                transformMatrix = childMatrix;</div><div class="line">            &#125;</div><div class="line">            transformMatrix.mapRect(boundingRect);</div><div class="line">			<span class="comment">// 设置需要重绘的区域</span></div><div class="line">            dirty.set((<span class="keyword">int</span>) (boundingRect.left - <span class="number">0.5f</span>),</div><div class="line">                    (<span class="keyword">int</span>) (boundingRect.top - <span class="number">0.5f</span>),</div><div class="line">                    (<span class="keyword">int</span>) (boundingRect.right + <span class="number">0.5f</span>),</div><div class="line">                    (<span class="keyword">int</span>) (boundingRect.bottom + <span class="number">0.5f</span>));</div><div class="line">        &#125;</div><div class="line">		<span class="comment">// 这里的do...while方法，让view可以不断的去调用父类的</span></div><div class="line">		<span class="comment">// invalidateChildInParent方法，来传递重绘请求</span></div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            View view = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> View) &#123;</div><div class="line">                view = (View) parent;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (drawAnimation) &#123;</div><div class="line">                <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">                    view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ViewRootImpl) &#123;</div><div class="line">                    ((ViewRootImpl) parent).mIsAnimating = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// If the parent is dirty opaque or not dirty, mark it dirty with the opaque</span></div><div class="line">            <span class="comment">// flag coming from the child that initiated the invalidate</span></div><div class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> ((view.mViewFlags &amp; FADING_EDGE_MASK) != <span class="number">0</span> &amp;&amp;</div><div class="line">                        view.getSolidColor() == <span class="number">0</span>) &#123;</div><div class="line">                    opaqueFlag = PFLAG_DIRTY;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123;</div><div class="line">                    view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">			<span class="comment">// 这里是关键代码，他会调用父类的</span></div><div class="line">            parent = parent.invalidateChildInParent(location, dirty);</div><div class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Account for transform on current parent</span></div><div class="line">                Matrix m = view.getMatrix();</div><div class="line">                <span class="keyword">if</span> (!m.isIdentity()) &#123;</div><div class="line">                    RectF boundingRect = attachInfo.mTmpTransformRect;</div><div class="line">                    boundingRect.set(dirty);</div><div class="line">                    m.mapRect(boundingRect);</div><div class="line">                    dirty.set((<span class="keyword">int</span>) (boundingRect.left - <span class="number">0.5f</span>),</div><div class="line">                            (<span class="keyword">int</span>) (boundingRect.top - <span class="number">0.5f</span>),</div><div class="line">                            (<span class="keyword">int</span>) (boundingRect.right + <span class="number">0.5f</span>),</div><div class="line">                            (<span class="keyword">int</span>) (boundingRect.bottom + <span class="number">0.5f</span>));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">while</span> (parent != <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码中，设置了需要重绘的区域dirty。之后再do…while方法中，反复的调用<strong>parent = parent.invalidateChildInParent(location, dirty)</strong>方法，来调用父类的invalidateChildInParent对View的重绘请求进行传递。这里的parent有可能是ViewGroup，也有可能是ViewRoot，我们先来看看ViewGroup#invalidateChildInParent方法<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ViewParent <span class="title">invalidateChildInParent</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span>[] location, <span class="keyword">final</span> Rect dirty)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWN) == PFLAG_DRAWN ||</div><div class="line">            (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) &#123;</div><div class="line">        <span class="keyword">if</span> ((mGroupFlags &amp; (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) !=</div><div class="line">                    FLAG_OPTIMIZE_INVALIDATE) &#123;</div><div class="line">			<span class="comment">// 子View中的布局位置转换为父View中的布局位置</span></div><div class="line">            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX,</div><div class="line">                    location[CHILD_TOP_INDEX] - mScrollY);</div><div class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == <span class="number">0</span>) &#123;</div><div class="line">				<span class="comment">// 合并绘制区域集合</span></div><div class="line">                dirty.union(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> left = mLeft;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> top = mTop;</div><div class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123;</div><div class="line">                <span class="keyword">if</span> (!dirty.intersect(<span class="number">0</span>, <span class="number">0</span>, mRight - left, mBottom - top)) &#123;</div><div class="line">                    dirty.setEmpty();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</div><div class="line">            location[CHILD_LEFT_INDEX] = left;</div><div class="line">            location[CHILD_TOP_INDEX] = top;</div><div class="line">            <span class="keyword">if</span> (mLayerType != LAYER_TYPE_NONE) &#123;</div><div class="line">                mPrivateFlags |= PFLAG_INVALIDATED;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> mParent;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_DRAWN &amp; ~PFLAG_DRAWING_CACHE_VALID;</div><div class="line">            location[CHILD_LEFT_INDEX] = mLeft;</div><div class="line">            location[CHILD_TOP_INDEX] = mTop;</div><div class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123;</div><div class="line">                dirty.set(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// in case the dirty rect extends outside the bounds of this container</span></div><div class="line">                dirty.union(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (mLayerType != LAYER_TYPE_NONE) &#123;</div><div class="line">                mPrivateFlags |= PFLAG_INVALIDATED;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> mParent;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上述代码中，将会使用offset，把子View需要重绘的坐标区域转换为父View中的坐标区域。之后使用union对子View与父View的区域进行集合运算，获得需要绘制的区域。<br><br>接下来我们再来看看ViewRoot#invalidateChildInParent方法，ViewRoot并不是View，ViewRoot的实现类为ViewRootImpl，我们来看下它的invalidateChildInParent方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ViewParent <span class="title">invalidateChildInParent</span><span class="params">(<span class="keyword">int</span>[] location, Rect dirty)</span> </span>&#123;</div><div class="line">	<span class="comment">// 检查线程是否为创建View的线程，即创建View的线程中是否含有此ViewRootImpl</span></div><div class="line">    checkThread();</div><div class="line">    <span class="keyword">if</span> (DEBUG_DRAW) Log.v(TAG, <span class="string">"Invalidate child: "</span> + dirty);</div><div class="line">	<span class="comment">// 检查重绘区域</span></div><div class="line">    <span class="keyword">if</span> (dirty == <span class="keyword">null</span>) &#123;</div><div class="line">        invalidate();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 动画和滑动的检查设置</span></div><div class="line">    <span class="keyword">if</span> (mCurScrollY != <span class="number">0</span> || mTranslator != <span class="keyword">null</span>) &#123;</div><div class="line">        mTempRect.set(dirty);</div><div class="line">        dirty = mTempRect;</div><div class="line">        <span class="keyword">if</span> (mCurScrollY != <span class="number">0</span>) &#123;</div><div class="line">            dirty.offset(<span class="number">0</span>, -mCurScrollY);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</div><div class="line">            mTranslator.translateRectInAppWindowToScreen(dirty);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (mAttachInfo.mScalingRequired) &#123;</div><div class="line">            dirty.inset(-<span class="number">1</span>, -<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    invalidateRectOnScreen(dirty);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invalidateRectOnScreen</span><span class="params">(Rect dirty)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;</div><div class="line">		<span class="comment">//关键代码，ViewTree列表</span></div><div class="line">        scheduleTraversals();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码中，进入之后会线程以及重绘区域的检查，之后调用invalidateRectOnScreen方法，然后调用scheduleTraversals()方法。<br></p>
<p>来继续看看ViewRootImpl#scheduleTraversals()。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</div><div class="line">        mTraversalScheduled = <span class="keyword">true</span>;</div><div class="line">		<span class="comment">// handler消息传递绘制请求</span></div><div class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</div><div class="line">        mChoreographer.postCallback(</div><div class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</div><div class="line">            scheduleConsumeBatchedInput();</div><div class="line">        &#125;</div><div class="line">        notifyRendererOfFramePending();</div><div class="line">        pokeDrawLockIfNeeded();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        doTraversal();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</div><div class="line">        mTraversalScheduled = <span class="keyword">false</span>;</div><div class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</div><div class="line">        <span class="keyword">if</span> (mProfile) &#123;</div><div class="line">            Debug.startMethodTracing(<span class="string">"ViewAncestor"</span>);</div><div class="line">        &#125;</div><div class="line">		<span class="comment">// 关键代码，执行ViewTree遍历</span></div><div class="line">        performTraversals();</div><div class="line">        <span class="keyword">if</span> (mProfile) &#123;</div><div class="line">            Debug.stopMethodTracing();</div><div class="line">            mProfile = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码中，将会之后handler，之后会调用mTraversalRunnable类，从而调用doTraversal方法，最后调用performTraversals()执行ViewTree的遍历。<br></p>
<p>现在继续查看ViewRootImpl#performTraversals()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</div><div class="line">	...</div><div class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</div><div class="line">        <span class="keyword">if</span> (!skipDraw || mReportNextDraw) &#123;</div><div class="line">            <span class="keyword">if</span> (mPendingTransitions != <span class="keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;</div><div class="line">                    mPendingTransitions.get(i).startChangingAnimations();</div><div class="line">                &#125;</div><div class="line">                mPendingTransitions.clear();</div><div class="line">            &#125;</div><div class="line">			<span class="comment">// 关键代码</span></div><div class="line">            performDraw();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performDraw</span><span class="params">()</span> </span>&#123;</div><div class="line">    ...</div><div class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> fullRedrawNeeded = mFullRedrawNeeded;</div><div class="line">    mFullRedrawNeeded = <span class="keyword">false</span>;</div><div class="line">    mIsDrawing = <span class="keyword">true</span>;</div><div class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"draw"</span>);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">		<span class="comment">// 关键代码</span></div><div class="line">        draw(fullRedrawNeeded);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        mIsDrawing = <span class="keyword">false</span>;</div><div class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在其中进行View的是否可见，是否为surfasce，是否正在绘制，是否存在于删除列表中等判断，之后调用performDraw()开始执行绘制。在performDraw()又调用了ViewRootImpl的draw方法，并传递了fullRedrawNeeded参数，此参数源自mFullRedrawNeeded成员变量，用于表示是否需要重新绘制全部的View。现在继续看看ViewRootImpl#draw源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</div><div class="line">    Surface surface = mSurface;</div><div class="line">    ...</div><div class="line">	<span class="comment">// 获取mDirty，该值表示需要重绘的区域</span></div><div class="line">    <span class="keyword">final</span> Rect dirty = mDirty;</div><div class="line">    <span class="keyword">if</span> (mSurfaceHolder != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// The app owns the surface, we won't draw.</span></div><div class="line">        dirty.setEmpty();</div><div class="line">        <span class="keyword">if</span> (animating) &#123;</div><div class="line">            <span class="keyword">if</span> (mScroller != <span class="keyword">null</span>) &#123;</div><div class="line">                mScroller.abortAnimation();</div><div class="line">            &#125;</div><div class="line">            disposeResizeBuffer();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 如果为ture，则设置dirty区域为全屏</span></div><div class="line">    <span class="keyword">if</span> (fullRedrawNeeded) &#123;</div><div class="line">        mAttachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</div><div class="line">        dirty.set(<span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">int</span>) (mWidth * appScale + <span class="number">0.5f</span>), (<span class="keyword">int</span>) (mHeight * appScale + <span class="number">0.5f</span>));</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">	<span class="comment">// 重绘区域、动画判断</span></div><div class="line">		<span class="comment">// 硬件渲染判断</span></div><div class="line">			<span class="comment">// 关键代码</span></div><div class="line">            <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在draw方法中，根据传如fullRedrawNeeded参数，设置需要重绘的dirty区域，最后调用drawSoftware方法，把参数传递进去，现在继续看ViewRootImpl#drawSoftware源码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></div><div class="line">        <span class="keyword">boolean</span> scalingRequired, Rect dirty) &#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!canvas.isOpaque() || yoff != <span class="number">0</span> || xoff != <span class="number">0</span>) &#123;</div><div class="line">            canvas.drawColor(<span class="number">0</span>, PorterDuff.Mode.CLEAR);</div><div class="line">        &#125;</div><div class="line">        dirty.setEmpty();</div><div class="line">        mIsAnimating = <span class="keyword">false</span>;</div><div class="line">        mView.mPrivateFlags |= View.PFLAG_DRAWN;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            canvas.translate(-xoff, -yoff);</div><div class="line">            <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</div><div class="line">                mTranslator.translateCanvas(canvas);</div><div class="line">            &#125;</div><div class="line">            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : <span class="number">0</span>);</div><div class="line">            attachInfo.mSetIgnoreDirtyState = <span class="keyword">false</span>;</div><div class="line">			<span class="comment">// 关键代码，mView为DecorView，开启View绘制</span></div><div class="line">            mView.draw(canvas);</div><div class="line">            drawAccessibilityFocusedDrawableIfNeeded(canvas);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (!attachInfo.mSetIgnoreDirtyState) &#123;</div><div class="line">                <span class="comment">// Only clear the flag if it was not set during the mView.draw() call</span></div><div class="line">                attachInfo.mIgnoreDirtyState = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码中，首先对canvas进行一些属性设置，包括色块、平移等。之后调用mView.draw(canvas)方法，开始对View进行绘制。mView就是window中的顶级视图DecorView(这个坑会在之后的文章中说明，这里当做一个顶级的ViewGroup即可)。</p>
<h3 id="2、绘制流程"><a href="#2、绘制流程" class="headerlink" title="2、绘制流程"></a>2、绘制流程</h3><p>DecorView继承自FrameLayout，而ViewGroup的draw方法继承自View，so，所以我们直接看View#draw即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</div><div class="line">            (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</div><div class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Draw traversal performs several drawing steps which must be executed</div><div class="line">     * in the appropriate order:</div><div class="line">     *</div><div class="line">     *      1. Draw the background</div><div class="line">     *      2. If necessary, save the canvas' layers to prepare for fading</div><div class="line">     *      3. Draw view's content</div><div class="line">     *      4. Draw children</div><div class="line">     *      5. If necessary, draw the fading edges and restore layers</div><div class="line">     *      6. Draw decorations (scrollbars for instance)</div><div class="line">     */</div><div class="line">    <span class="comment">// Step 1, draw the background, if needed</span></div><div class="line">    <span class="keyword">int</span> saveCount;</div><div class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;</div><div class="line">        drawBackground(canvas);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</div><div class="line">    <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</div><div class="line">        <span class="comment">// Step 3, draw the content</span></div><div class="line">        <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</div><div class="line">        <span class="comment">// Step 4, draw the children</span></div><div class="line">        dispatchDraw(canvas);</div><div class="line">        <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></div><div class="line">        <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</div><div class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></div><div class="line">        onDrawForeground(canvas);</div><div class="line">        <span class="comment">// we're done...</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>draw方法中，官方对其的步骤进行了清晰的注释，我们来看下流程，在执行流程之前会检查绘制区域是否透明:</p>
<ul>
<li>1、绘制View背景，如果透明则不绘制</li>
<li>2、如果需要，则保存画布的图层</li>
<li>3、绘制View内容，如果透明则不绘制</li>
<li>4、绘制子View————这个很重要</li>
<li>5、如果需要，则绘制View的褪色边缘和恢复图层</li>
<li>6、绘制装饰滚动条</li>
</ul>
<p>这里最重要的步骤是第四步，绘制子View，现在我们来看下这个ViewGroup#dispatchDraw(canvas)方法，注意这里的View是一个DecorView，所以要在ViewGroup中去查看这个方法，View中的这个方法是一个空方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</div><div class="line">        <span class="keyword">while</span> (transientIndex &gt;= <span class="number">0</span> &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;</div><div class="line">            <span class="keyword">final</span> View transientChild = mTransientViews.get(transientIndex);</div><div class="line">            <span class="keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</div><div class="line">                    transientChild.getAnimation() != <span class="keyword">null</span>) &#123;</div><div class="line">                more |= drawChild(canvas, transientChild, drawingTime);</div><div class="line">            &#125;</div><div class="line">            transientIndex++;</div><div class="line">            <span class="keyword">if</span> (transientIndex &gt;= transientCount) &#123;</div><div class="line">                transientIndex = -<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;</div><div class="line">        <span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>)</div><div class="line">                ? children[childIndex] : preorderedList.get(childIndex);</div><div class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;</div><div class="line">            more |= drawChild(canvas, child, drawingTime);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (transientIndex &gt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// there may be additional transient views after the normal views</span></div><div class="line">        <span class="keyword">final</span> View transientChild = mTransientViews.get(transientIndex);</div><div class="line">        <span class="keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</div><div class="line">                transientChild.getAnimation() != <span class="keyword">null</span>) &#123;</div><div class="line">            more |= drawChild(canvas, transientChild, drawingTime);</div><div class="line">        &#125;</div><div class="line">        transientIndex++;</div><div class="line">        <span class="keyword">if</span> (transientIndex &gt;= transientCount) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码对所有的子View进行遍历，并调用ViewGroup#drawChild方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>drawChild又调用了子View的draw方法，这样绘制就传递了下去，当然这个draw方法和之前这一小节一开始介绍的View#draw方法并不一样，我们来看看<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</div><div class="line">	...</div><div class="line">	<span class="keyword">if</span> (!drawingWithRenderNode) &#123;</div><div class="line">    	computeScroll();</div><div class="line">    	sx = mScrollX;</div><div class="line">    	sy = mScrollY;</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">    <span class="keyword">if</span> (!drawingWithDrawingCache) &#123;</div><div class="line">        <span class="keyword">if</span> (drawingWithRenderNode) &#123;</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</div><div class="line">            ((DisplayListCanvas) canvas).drawRenderNode(renderNode);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Fast path for layouts with no backgrounds</span></div><div class="line">            <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</div><div class="line">                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</div><div class="line">                dispatchDraw(canvas);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                draw(canvas);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</div><div class="line">        mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</div><div class="line">        <span class="keyword">if</span> (layerType == LAYER_TYPE_NONE) &#123;</div><div class="line">            <span class="comment">// no layer paint, use temporary paint to draw bitmap</span></div><div class="line">            Paint cachePaint = parent.mCachePaint;</div><div class="line">            <span class="keyword">if</span> (cachePaint == <span class="keyword">null</span>) &#123;</div><div class="line">                cachePaint = <span class="keyword">new</span> Paint();</div><div class="line">                cachePaint.setDither(<span class="keyword">false</span>);</div><div class="line">                parent.mCachePaint = cachePaint;</div><div class="line">            &#125;</div><div class="line">            cachePaint.setAlpha((<span class="keyword">int</span>) (alpha * <span class="number">255</span>));</div><div class="line">            canvas.drawBitmap(cache, <span class="number">0.0f</span>, <span class="number">0.0f</span>, cachePaint);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// use layer paint to draw the bitmap, merging the two alphas, but also restore</span></div><div class="line">            <span class="keyword">int</span> layerPaintAlpha = mLayerPaint.getAlpha();</div><div class="line">            mLayerPaint.setAlpha((<span class="keyword">int</span>) (alpha * layerPaintAlpha));</div><div class="line">            canvas.drawBitmap(cache, <span class="number">0.0f</span>, <span class="number">0.0f</span>, mLayerPaint);</div><div class="line">            mLayerPaint.setAlpha(layerPaintAlpha);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码会先判断之前是否进行过了绘制，如果没有则进入快速绘制通道，对没有背景的View进行绘制。判断是否需要跳过自身的draw绘制方法，如果跳过则进入dispatchDraw，不跳过则进入当前View的draw方法，即这一小节开头的draw方法，就此形成了循环。同时我们在这里看到了<strong>computeScroll()</strong>方法，也就印证了上一篇文章对于弹性滑动过程的描述。<br></p>
<p>流程图如下:</p>
<p><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/invalidate.png" alt="invalidate" title="invalidate" width="800"><br></p>
<h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>本文对上一篇遗留的问题postInvalidate与invalidate的区别进行了回答与分析，对invalidate的传递流程，以及View的绘制流程进行了源码分析，解答了invalidate是如何调用computeScroll()的问题。如果在阅读过程中，有任何疑问与问题，欢迎与我联系。<br></p>
<p><strong>博客:www.idtkm.com</strong><br><br><strong>GitHub:<a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><br><strong>微博:<a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><br><strong>邮箱:IdtkMa@gmail.com</strong><br><br><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;上一篇文章&lt;a href=&quot;http://www.idtkm.com/customview/customview8/&quot;&gt;自定义View——View的弹性滑动&lt;/a&gt;中，我们对View的滑动进行了实战以及简单分析。但在文章的最后，仍然遗留了两个问题,第一个是invalidate与postInvalidate有什么区别呢？第二个是invalidate是如何调用computeScroll()方法的呢？这两个问题将在这一篇文章中进行分析。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Idtk/Blog&quot;&gt;自定义View系列目录&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、invalidate与postInvalidate&quot;&gt;&lt;a href=&quot;#一、invalidate与postInvalidate&quot; class=&quot;headerlink&quot; title=&quot;一、invalidate与postInvalidate&quot;&gt;&lt;/a&gt;一、invalidate与postInvalidate&lt;/h2&gt;&lt;p&gt;invalidate与postInvadlidate都是用于请求View重绘的API，invalidate在主线程中进行调用，而postInvadlidate则在子线程中进行调用。&lt;br&gt;&lt;br&gt;我们来分析下postInvadlidate的源码 :&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;postInvalidate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    postInvalidateDelayed(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;postInvalidate()蒋会调用postInvalidateDelayed(0)方法，继续跟进。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;postInvalidateDelayed&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; delayMilliseconds)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; AttachInfo attachInfo = mAttachInfo;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (attachInfo != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        attachInfo.mViewRootImpl.dispatchInvalidateDelayed(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, delayMilliseconds);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;postInvalidateDelayed方法，通过attachInfo获取到当前的ViewRootImpl对象，调用它的dispatchInvalidateDelayed方法&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dispatchInvalidateDelayed&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(View view, &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; delayMilliseconds)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    mHandler.sendMessageDelayed(msg, delayMilliseconds);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="CustomView" scheme="http://www.idtkm.com/tags/CustomView/"/>
    
  </entry>
  
  <entry>
    <title>View的弹性滑动</title>
    <link href="http://www.idtkm.com/2016/07/27/8%E3%80%81Scroll/"/>
    <id>http://www.idtkm.com/2016/07/27/8、Scroll/</id>
    <published>2016-07-26T16:00:00.000Z</published>
    <updated>2017-10-15T16:01:42.653Z</updated>
    
    <content type="html"><![CDATA[<p><strong>滑动是Android开发中非常重要的UI效果，几乎所有应用都包含了滑动效果，而本文将对滑动的使用以及原理进行介绍。</strong></p>
<p><a href="https://github.com/Idtk/Blog" target="_blank" rel="external">自定义View系列目录</a></p>
<h2 id="一、scrollTo与ScrollBy"><a href="#一、scrollTo与ScrollBy" class="headerlink" title="一、scrollTo与ScrollBy"></a>一、scrollTo与ScrollBy</h2><p>View提供了专门的方法用于实现滑动效果，分别为scrollTo与scrollBy。先来看看它们的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Set the scrolled position of your view. This will cause a call to</div><div class="line"> * &#123;<span class="doctag">@link</span> #onScrollChanged(int, int, int, int)&#125; and the view will be</div><div class="line"> * invalidated.</div><div class="line"> * <span class="doctag">@param</span> x the x position to scroll to</div><div class="line"> * <span class="doctag">@param</span> y the y position to scroll to</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</div><div class="line">        <span class="keyword">int</span> oldX = mScrollX;</div><div class="line">        <span class="keyword">int</span> oldY = mScrollY;</div><div class="line">        mScrollX = x;</div><div class="line">        mScrollY = y;</div><div class="line">        invalidateParentCaches();</div><div class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);</div><div class="line">        <span class="keyword">if</span> (!awakenScrollBars()) &#123;</div><div class="line">            postInvalidateOnAnimation();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Move the scrolled position of your view. This will cause a call to</div><div class="line"> * &#123;<span class="doctag">@link</span> #onScrollChanged(int, int, int, int)&#125; and the view will be</div><div class="line"> * invalidated.</div><div class="line"> * <span class="doctag">@param</span> x the amount of pixels to scroll by horizontally</div><div class="line"> * <span class="doctag">@param</span> y the amount of pixels to scroll by vertically</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">    scrollTo(mScrollX + x, mScrollY + y);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从源码中可以看出scrollBy实际上是调用了scrollTo函数来实现它的功能。scrollBy实现的是输入参数的相对滑动，而scrollTo是绝对滑动。需要说明的是mScrollX、mScrollY这两个View的属性，这两个属性可以通过getScrollX、getScrollY获得。<br></p>
<a id="more"></a>
<ul>
<li>mScrollX : View的左边缘在View内容的左边缘的右边时，为正值，反之为负值。</li>
<li>mScrollY : View的上边缘在View内容的上边缘的下边时，为正值，反之为负值。<br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/mScrollXY.png" alt="mScrollXY" title="mScrollXY" width="500"><br><br><br>下面我们来实现一个滑动的效果：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorizontalScroller</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTouchSlop;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mLastXIntercept=<span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mLastYIntercept=<span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mLastX=<span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mLastY=<span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftBorder;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rightBorder;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HorizontalScroller</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line">        init(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HorizontalScroller</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        init(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HorizontalScroller</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</div><div class="line">        init(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span></span>&#123;</div><div class="line">        ViewConfiguration configuration = ViewConfiguration.get(context);</div><div class="line">        <span class="comment">// 获取TouchSlop值</span></div><div class="line">        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> intercept = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">float</span> xIntercept = ev.getX();</div><div class="line">        <span class="keyword">float</span> yIntercept = ev.getY();</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (ev.getAction()) &#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">                intercept = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">                <span class="keyword">float</span> deltaX = xIntercept-mLastXIntercept;</div><div class="line">                <span class="keyword">float</span> deltaY = yIntercept-mLastYIntercept;</div><div class="line">                <span class="comment">// 当水平方向的滑动距离大于竖直方向的滑动距离，且手指拖动值大于TouchSlop值时，拦截事件</span></div><div class="line">                <span class="keyword">if</span> (Math.abs(deltaX)&gt;Math.abs(deltaY) &amp;&amp; Math.abs(deltaX)&gt;mTouchSlop) &#123;</div><div class="line">                    intercept=<span class="keyword">true</span>;</div><div class="line">                &#125;<span class="keyword">else</span> &#123;</div><div class="line">                    intercept = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                intercept = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mLastX = xIntercept;</div><div class="line">        mLastY = yIntercept;</div><div class="line">        mLastXIntercept = xIntercept;</div><div class="line">        mLastYIntercept = yIntercept;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> intercept;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">float</span> xTouch = event.getX();</div><div class="line">        <span class="keyword">float</span> yTouch = event.getY();</div><div class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">                <span class="keyword">float</span> deltaX = xTouch-mLastX;</div><div class="line">                <span class="keyword">float</span> deltaY = yTouch-mLastY;</div><div class="line">                <span class="keyword">float</span> scrollByStart = deltaX;</div><div class="line">                <span class="keyword">if</span> (getScrollX() - deltaX &lt; leftBorder) &#123;</div><div class="line">                    scrollByStart = getScrollX()-leftBorder;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getScrollX() + getWidth() - deltaX &gt; rightBorder) &#123;</div><div class="line">                    scrollByStart = rightBorder-getWidth()-getScrollX();</div><div class="line">                &#125;</div><div class="line">                scrollBy((<span class="keyword">int</span>) -scrollByStart, <span class="number">0</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                <span class="comment">// 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面</span></div><div class="line">                <span class="keyword">int</span> targetIndex = (getScrollX() + getWidth() / <span class="number">2</span>) / getWidth();</div><div class="line">                <span class="keyword">int</span> dx = targetIndex * getWidth() - getScrollX();</div><div class="line">                scrollTo(getScrollX()+dx,<span class="number">0</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mLastX = xTouch;</div><div class="line">        mLastY = yTouch;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> childCount = getChildCount();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">            View childView = getChildAt(i);</div><div class="line">            <span class="comment">// 测量每一个子控件的大小</span></div><div class="line">            measureChild(childView, widthMeasureSpec, heightMeasureSpec);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (changed) &#123;</div><div class="line">            <span class="keyword">int</span> childCount = getChildCount();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">                View childView = getChildAt(i);</div><div class="line">                <span class="comment">// 在水平方向上对子控件进行布局</span></div><div class="line">                childView.layout(i * getMeasuredWidth(), <span class="number">0</span>, i * getMeasuredWidth()+childView.getMeasuredWidth()+getPaddingLeft(), childView.getMeasuredHeight());</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 初始化左右边界值</span></div><div class="line">            leftBorder = <span class="number">0</span>;</div><div class="line">            rightBorder = getChildCount()*getMeasuredWidth();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>现在我们来分析下这段代码:<br></p>
<ul>
<li>首先在构造函数中获取了最小滑动距离TouchSlop。</li>
<li>重写onInterceptTouchEvent拦截事件，记录当前坐标。点下时，默认不拦截，只有当滑动还未完成的情况下，才继续拦截。在移动时，对滑动冲突进行了处理，当水平方向的移动距离大于竖直方向的移动距离，并且移动距离大于最小滑动距离时，我们判断此时为水平滑动，拦截事件自己处理；否则不拦截，交由子View处理。提起手指时，同样不拦截事件。</li>
<li>重写onTouchEvent处理事件，记录当前坐标。在手指按下时，与拦截事件时做相似处理。在ACTION_MOVE时，向左滑动，如果滑动距离超过左边界，则对滑动距离进行处理，相对的滑动距离超出又边界，也是一样处理，之后把滑动的距离交给scrollBy进行处理。当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面，然后使用scrollTo滑动到那个子控件。</li>
<li>重写了onMeasure和onLayout方法，在onMeasure中测量每一个子控件的大小值，在onLayout中对每一个子view在水平方向上进行布局。子view的layout的right增加父类的paddingLeft参数，来处理设置padding的情况。这两个函数的流程分析将会放在之后的文章中详细说明。</li>
</ul>
<p>这个类的使用方法如下 :<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;com.idtk.customscroll.HorizontalScroller</div><div class="line">    xmlns:android="http://schemas.android.com/apk/res/android"</div><div class="line">    xmlns:tools="http://schemas.android.com/tools"</div><div class="line">    android:layout_width="match_parent"</div><div class="line">    android:layout_height="match_parent"</div><div class="line">    android:padding="10dp"</div><div class="line">    tools:context="com.idtk.customscroll.MainActivity"&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:layout_width="match_parent"</div><div class="line">        android:layout_height="match_parent"</div><div class="line">        android:src="@drawable/zhiqinchun"</div><div class="line">        android:clickable="true"/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:layout_width="wrap_content"</div><div class="line">        android:layout_height="wrap_content"</div><div class="line">        android:src="@drawable/hanzhan"</div><div class="line">        android:clickable="true"/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:layout_width="match_parent"</div><div class="line">        android:layout_height="match_parent"</div><div class="line">        android:src="@drawable/shengui"</div><div class="line">        android:clickable="true"/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:layout_width="match_parent"</div><div class="line">        android:layout_height="match_parent"</div><div class="line">        android:src="@drawable/dayu"</div><div class="line">        android:clickable="true"/&gt;</div><div class="line"></div><div class="line">&lt;/com.idtk.customscroll.HorizontalScroller&gt;</div></pre></td></tr></table></figure></p>
<p>HorizontalScroller设置全屏，padding为10dp。使用4个ImageView作为子View，并且都设置为可点击状态。示例效果图如下:<br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/scroll0.gif" alt="scroll" title="scroll" width="300"><br><br></p>
<h2 id="二、Scroller"><a href="#二、Scroller" class="headerlink" title="二、Scroller"></a>二、Scroller</h2><p>可以看到上面使用scrollTo与ScrollBy方法的滑动都是瞬时完成的，这有些无法满足我们在切换子view时的需求。我们希望切换子View时，可以拥有滑动过程的效果，而Scroller正好可以完成这一点。<br>Scroller的使用方法：</p>
<ul>
<li>1、创建Scroller实例</li>
<li>2、使用startScroll方法，对其进行初始化</li>
<li>3、重写computeScroll()方法，在其内部调用scrollTo或ScrollBy方法，完成滑动过程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建实例</span></div><div class="line">mScroller = <span class="keyword">new</span> Scroller(context);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> ScrollX = getScrollX();</div><div class="line">    <span class="keyword">int</span> ScrollY = getScrollY();</div><div class="line">	<span class="comment">//初始化，1000ms内缓慢滑动到deltaX</span></div><div class="line">    mScroller.startScroll(ScrollX, <span class="number">0</span>, <span class="number">0</span>, deltaX, <span class="number">1000</span>);</div><div class="line">    invalidate();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(mScroller.computeScrollOffset())&#123;</div><div class="line">        <span class="keyword">int</span> currX = mScroller.getCurrX();</div><div class="line">        <span class="keyword">int</span> currY = mScroller.getCurrY();</div><div class="line">        scrollTo(currX, currY);</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码是Scroller的典型用法，也就是传说中的套路。当时Scroller使用startScroll方法时，只是对一系列参数进行了初始化。我们从下面的源码中可以看出。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScroll</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> duration)</span> </span>&#123;</div><div class="line">    mMode = SCROLL_MODE;</div><div class="line">    mFinished = <span class="keyword">false</span>;</div><div class="line">    mDuration = duration;</div><div class="line">    mStartTime = AnimationUtils.currentAnimationTimeMillis();</div><div class="line">    mStartX = startX;</div><div class="line">    mStartY = startY;</div><div class="line">    mFinalX = startX + dx;</div><div class="line">    mFinalY = startY + dy;</div><div class="line">    mDeltaX = dx;</div><div class="line">    mDeltaY = dy;</div><div class="line">    mDurationReciprocal = <span class="number">1.0f</span> / (<span class="keyword">float</span>) mDuration;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参数中，startX、startY是滑动的起点，dx、dy是滑动的距离，duration是滑动的时间系统设置为250ms。我们可以看到startScroll只是进行了滑动时间、是否滑动完成、起点、终点、滑动距离等的参数的设置，那么是如何调用computeScroll()函数的呢？其实computeScroll()的调用是由之后的invalidate()函数来完成的，invalidate可以请求View重绘，在View重绘时会调用draw方法，draw方法又会去调用computeScroll函数。但computeScroll()函数在view中是一个空的函数，需要我们去实现它。<br><br>computeScroll()函数的实现已经在上面给出了，有了computeScroll方法之后，就可以实现View的弹性滑动了。来看下computeScroll()的实现过程，首先要进行computeScrollOffset()的判断，来看下它的源码 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">computeScrollOffset</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mFinished) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> timePassed = (<span class="keyword">int</span>)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);</div><div class="line">    <span class="keyword">if</span> (timePassed &lt; mDuration) &#123;</div><div class="line">        <span class="keyword">switch</span> (mMode) &#123;</div><div class="line">        <span class="keyword">case</span> SCROLL_MODE:</div><div class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);</div><div class="line">            mCurrX = mStartX + Math.round(x * mDeltaX);</div><div class="line">            mCurrY = mStartY + Math.round(x * mDeltaY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> FLING_MODE:</div><div class="line">            <span class="keyword">final</span> <span class="keyword">float</span> t = (<span class="keyword">float</span>) timePassed / mDuration;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = (<span class="keyword">int</span>) (NB_SAMPLES * t);</div><div class="line">            <span class="keyword">float</span> distanceCoef = <span class="number">1</span>.f;</div><div class="line">            <span class="keyword">float</span> velocityCoef = <span class="number">0</span>.f;</div><div class="line">            <span class="keyword">if</span> (index &lt; NB_SAMPLES) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> t_inf = (<span class="keyword">float</span>) index / NB_SAMPLES;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> t_sup = (<span class="keyword">float</span>) (index + <span class="number">1</span>) / NB_SAMPLES;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> d_inf = SPLINE_POSITION[index];</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> d_sup = SPLINE_POSITION[index + <span class="number">1</span>];</div><div class="line">                velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);</div><div class="line">                distanceCoef = d_inf + (t - t_inf) * velocityCoef;</div><div class="line">            &#125;</div><div class="line">            mCurrVelocity = velocityCoef * mDistance / mDuration * <span class="number">1000.0f</span>;</div><div class="line"></div><div class="line">            mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));</div><div class="line">            <span class="comment">// Pin to mMinX &lt;= mCurrX &lt;= mMaxX</span></div><div class="line">            mCurrX = Math.min(mCurrX, mMaxX);</div><div class="line">            mCurrX = Math.max(mCurrX, mMinX);</div><div class="line"></div><div class="line">            mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));</div><div class="line">            <span class="comment">// Pin to mMinY &lt;= mCurrY &lt;= mMaxY</span></div><div class="line">            mCurrY = Math.min(mCurrY, mMaxY);</div><div class="line">            mCurrY = Math.max(mCurrY, mMinY);</div><div class="line">            <span class="keyword">if</span> (mCurrX == mFinalX &amp;&amp; mCurrY == mFinalY) &#123;</div><div class="line">                mFinished = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        mCurrX = mFinalX;</div><div class="line">        mCurrY = mFinalY;</div><div class="line">        mFinished = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>computeScrollOffset()首先检测scroller是否完成滑动，完成则返回false，未完成则继续AnimationUtils.currentAnimationTimeMillis获取当前的毫秒值，减去之前startScroll方法时获得毫秒值，就是当前滑动的执行时间。之后判断执行时间是否小于设置的总时间，如果小于，根据startScroll时设置的模式SCROLL_MODE，然后根据Interpolator计算出当前滑动的mcurrX、mcurrY（顺便提一下在实例化scroller的时候，是可以设置动画插值器。）；如果执行时间大于或者等于设置的总时间，则直接设置mcurrX、mcurrY为终点值，并且设置mFinished，表示动画已经完成。<br><br>Scroller弹性滑动的流程如下<br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/scroller.png" alt="scroller" title="scroller" width="300"><br><br><br>现在使用Scroller方法来更改一下上面的代码，当ACTION_UP时，子View的滑动可以有一个过程，而不是瞬时完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    <span class="keyword">private</span> Scroller mScroller;</div><div class="line">	...</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span></span>&#123;</div><div class="line">        <span class="comment">// 第一步，创建Scroller的实例</span></div><div class="line">        mScroller = <span class="keyword">new</span> Scroller(context);</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">float</span> xTouch = event.getX();</div><div class="line">        <span class="keyword">float</span> yTouch = event.getY();</div><div class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">            ...</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                <span class="comment">// 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面</span></div><div class="line">                <span class="keyword">int</span> targetIndex = (getScrollX() + getWidth() / <span class="number">2</span>) / getWidth();</div><div class="line">                <span class="keyword">int</span> dx = targetIndex * getWidth() - getScrollX();</div><div class="line">                <span class="comment">// 第二步，使用startScroll方法，对其进行初始化</span></div><div class="line">                mScroller.startScroll(getScrollX(), <span class="number">0</span>, dx, <span class="number">0</span>);</div><div class="line">                invalidate();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">			<span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mLastX = xTouch;</div><div class="line">        mLastY = yTouch;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 第三步，重写computeScroll()方法，在其内部调用scrollTo或ScrollBy方法，完成滑动过程</span></div><div class="line">        <span class="keyword">if</span> (mScroller.computeScrollOffset()) &#123;</div><div class="line">            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</div><div class="line">            postInvalidate();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面就是代码中需要增加和修改的部分，我们来简单分析下。<br></p>
<ul>
<li>在构造函数中增加对<strong>Scroller进行了实例化</strong>。</li>
<li>替换onTouchEvent中手指抬起后的方法，改为<strong>使用startScroll方法，对mScroller进行初始化</strong>，之后invalidate请求重绘。</li>
<li>增加<strong>重写的computeScroll()方法</strong>，在其内部调用scrollTo或ScrollBy方法，完成滑动过程，之后使用postInvalidate()请求view重绘。</li>
</ul>
<p>示例效果图如下 : <br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/scroll.gif" alt="scroll" title="scroll" width="300"><br><br></p>
<h2 id="三、回弹效果"><a href="#三、回弹效果" class="headerlink" title="三、回弹效果"></a>三、回弹效果</h2><p>从上面的效果图可以看出，我们已经实现了view的平滑滚动，滑动位置超过当前view的1/2时，松手之后变会自动滑出此item的View。可是如果想要在首位两端实现回弹效果，该如何做呢？其实只要修改onTouchEvent方法即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">float</span> xTouch = event.getX();</div><div class="line">    <span class="keyword">float</span> yTouch = event.getY();</div><div class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">            <span class="keyword">if</span> (!mScroller.isFinished())</div><div class="line">                mScroller.abortAnimation();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">            <span class="keyword">float</span> deltaX = xTouch-mLastX;</div><div class="line">            <span class="keyword">float</span> deltaY = yTouch-mLastY;</div><div class="line">            <span class="keyword">float</span> scrollByStart = deltaX;</div><div class="line">			<span class="comment">//如果超出边界，则把滑动距离缩小到1/3</span></div><div class="line">            <span class="keyword">if</span> (getScrollX() - deltaX &lt; leftBorder) &#123;</div><div class="line">                scrollByStart = deltaX/<span class="number">3</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getScrollX() + getWidth() - deltaX &gt; rightBorder) &#123;</div><div class="line">                scrollByStart = deltaX/<span class="number">3</span>;</div><div class="line">            &#125;</div><div class="line">            scrollBy((<span class="keyword">int</span>) -scrollByStart, <span class="number">0</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">            <span class="comment">// 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面</span></div><div class="line">            <span class="keyword">int</span> targetIndex = (getScrollX() + getWidth() / <span class="number">2</span>) / getWidth();</div><div class="line">			<span class="comment">//如果超过右边界，则回弹到最后一个View</span></div><div class="line">            <span class="keyword">if</span> (targetIndex&gt;getChildCount()-<span class="number">1</span>)&#123;</div><div class="line">                targetIndex = getChildCount()-<span class="number">1</span>;</div><div class="line">			<span class="comment">//如果超过左边界，则回弹到第一个View</span></div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (targetIndex&lt;<span class="number">0</span>)&#123;</div><div class="line">                targetIndex =<span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> dx = targetIndex * getWidth() - getScrollX();</div><div class="line">            <span class="comment">// 第二步，使用startScroll方法，对其进行初始化</span></div><div class="line">            mScroller.startScroll(getScrollX(), <span class="number">0</span>, dx, <span class="number">0</span>);</div><div class="line">            invalidate();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    mLastX = xTouch;</div><div class="line">    mLastY = yTouch;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>来简单分析下修改的onTouchEvent方法:<br></p>
<p>在滑动的过程中，如果滑动的位置超过了试图的左、右边界，则缩小View的滑动距离，使之为手指滑动距离的1/3。当手指离开时，如果通过view宽度获得的当前inder小与0，则index为第一个View；如果获得的当前index超过了子View的数量-1，则index为最后一个View。View的回弹效果如下:<br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/scroll2.gif" alt="scroll" title="scroll" width="300"><br><br></p>
<h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>本文介绍弹性滑动的实现方法，并对弹性滑动的过程进行了详细分析。在之后通过例子实现了view的弹性滑动以及回弹效果，但<strong>最后还留有两个问题，即invalidate与postInvalidate的区别又在哪里呢？invalidate是如何调用computeScroll()函数的呢？</strong>，这些问题我将在下一篇文章中进行详细的分析。<br><br>如果在阅读过程中，有任何疑问与问题，欢迎与我联系。<br></p>
<p><strong>博客:www.idtkm.com</strong><br><br><strong>GitHub:<a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><br><strong>微博:<a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><br><strong>邮箱:IdtkMa@gmail.com</strong><br><br><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;滑动是Android开发中非常重要的UI效果，几乎所有应用都包含了滑动效果，而本文将对滑动的使用以及原理进行介绍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Idtk/Blog&quot;&gt;自定义View系列目录&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、scrollTo与ScrollBy&quot;&gt;&lt;a href=&quot;#一、scrollTo与ScrollBy&quot; class=&quot;headerlink&quot; title=&quot;一、scrollTo与ScrollBy&quot;&gt;&lt;/a&gt;一、scrollTo与ScrollBy&lt;/h2&gt;&lt;p&gt;View提供了专门的方法用于实现滑动效果，分别为scrollTo与scrollBy。先来看看它们的源码：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * Set the scrolled position of your view. This will cause a call to&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@link&lt;/span&gt; #onScrollChanged(int, int, int, int)&amp;#125; and the view will be&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * invalidated.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; x the x position to scroll to&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; y the y position to scroll to&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;scrollTo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mScrollX != x || mScrollY != y) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; oldX = mScrollX;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; oldY = mScrollY;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        mScrollX = x;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        mScrollY = y;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        invalidateParentCaches();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        onScrollChanged(mScrollX, mScrollY, oldX, oldY);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!awakenScrollBars()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            postInvalidateOnAnimation();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * Move the scrolled position of your view. This will cause a call to&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@link&lt;/span&gt; #onScrollChanged(int, int, int, int)&amp;#125; and the view will be&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * invalidated.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; x the amount of pixels to scroll by horizontally&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; y the amount of pixels to scroll by vertically&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;scrollBy&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    scrollTo(mScrollX + x, mScrollY + y);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;从源码中可以看出scrollBy实际上是调用了scrollTo函数来实现它的功能。scrollBy实现的是输入参数的相对滑动，而scrollTo是绝对滑动。需要说明的是mScrollX、mScrollY这两个View的属性，这两个属性可以通过getScrollX、getScrollY获得。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="CustomView" scheme="http://www.idtkm.com/tags/CustomView/"/>
    
  </entry>
  
  <entry>
    <title>雷达图(蜘蛛网图)的实现</title>
    <link href="http://www.idtkm.com/2016/07/01/7%E3%80%81RadarChart/"/>
    <id>http://www.idtkm.com/2016/07/01/7、RadarChart/</id>
    <published>2016-06-30T16:00:00.000Z</published>
    <updated>2017-10-15T16:01:51.378Z</updated>
    
    <content type="html"><![CDATA[<p>效果图:<br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/radar.png" alt="radar" title="radar" width="300"><br></p>
<p>阅读本文前需了解View的绘制流程，画布操作，以及Path的常用方法，如果不熟悉，请先查看我之前的文章<a href="http://www.idtkm.com/customview/customview1/">Android坐标系与View绘制流程</a>、<a href="http://www.idtkm.com/customview/customview2/">Canvas与ValueAnimator</a>、<a href="http://www.idtkm.com/customview/customview4/">Path图形与逻辑运算</a><br></p>
<p><a href="https://github.com/Idtk/Blog" target="_blank" rel="external">自定义View系列目录</a></p>
<h2 id="一、获取View宽高以及cos、sin"><a href="#一、获取View宽高以及cos、sin" class="headerlink" title="一、获取View宽高以及cos、sin"></a>一、获取View宽高以及cos、sin</h2><p>在onSizeChanged函数中，可以获取当前View的宽高以及根据padding值计算出的实际绘制区域的宽高，同时计算出雷达图的半径设置并通过PathMeasure类的<strong>getPosTan</strong>方法获得此任意正多边形各角坐标的余弦值、正弦值。<br></p>
<a id="more"></a>
<p>因为在之前的文章中并没有介绍getPosTan方法，这里对其进行一个简单的介绍。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean getPosTan (float distance, float[] pos, float[] tan)</div></pre></td></tr></table></figure></p>
<ul>
<li>distance为距离当前path起点的距离，取值范围为0到path的长度。</li>
<li>pos 如果不为null，则返回path当前距离的位置坐标，pos[0] = x,pos[1] = y 。</li>
<li>tan 如果不为null，则返回当前位置坐标的切线，tan[0] = x, tan[1] = y 。</li>
<li>返回值为boolean，true表示成功，数据会存入pas、tan，反之则为失败，数据也不会存入pas、tan。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</div><div class="line">    mViewWidth = w;</div><div class="line">	mViewHeight = h;</div><div class="line">	mWidth = mViewWidth - getPaddingLeft() - getPaddingRight();</div><div class="line">	mHeight = mViewHeight - getPaddingTop() - getPaddingBottom();</div><div class="line">    radius = Math.min(mWidth,mHeight)*<span class="number">0.35f</span>;</div><div class="line">    ...</div><div class="line">    <span class="comment">//增加圆形路径，起点从90度开始，顺时针旋转</span></div><div class="line">    mPath.addCircle(<span class="number">0</span>,<span class="number">0</span>,mRadarAxisData.getAxisLength(), Path.Direction.CW);</div><div class="line">    <span class="comment">//为PathMeasure设置路径</span></div><div class="line">    measure.setPath(mPath,<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="keyword">float</span>[] cosArray = <span class="keyword">new</span> <span class="keyword">float</span>[mRadarAxisData.getTypes().length];</div><div class="line">    <span class="keyword">float</span>[] sinArray = <span class="keyword">new</span> <span class="keyword">float</span>[mRadarAxisData.getTypes().length];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mRadarAxisData.getTypes().length; i++)&#123;</div><div class="line">    	<span class="comment">//获取Path距离起点当前距离的坐标，以及切线</span></div><div class="line">        measure.getPosTan((<span class="keyword">float</span>) (Math.PI*<span class="number">2</span>*mRadarAxisData.getAxisLength()*i/</div><div class="line">                mRadarAxisData.getTypes().length),pos,tan);</div><div class="line">        <span class="comment">//装填cos、sin</span></div><div class="line">        cosArray[i] = tan[<span class="number">0</span>];</div><div class="line">        sinArray[i] = tan[<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    mPath.reset();</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二、绘制坐标网络"><a href="#二、绘制坐标网络" class="headerlink" title="二、绘制坐标网络"></a>二、绘制坐标网络</h2><p>雷达图的坐标网络(即正多边形)的绘制将在onDraw函数中进行。</p>
<ul>
<li><p>首先通过画布缩放的方式绘制一圈圈的网格。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;number; i++)&#123;</div><div class="line">    canvas.save();</div><div class="line">    <span class="comment">//缩放画布</span></div><div class="line">    canvas.scale(<span class="number">1</span>-i/number,<span class="number">1</span>-i/number);</div><div class="line">    移动至第一点</div><div class="line">    mPathRing.moveTo(<span class="number">0</span>,radarAxisData.getAxisLength());</div><div class="line">    <span class="comment">//连接个点</span></div><div class="line">    <span class="keyword">if</span> (radarAxisData.getTypes()!=<span class="keyword">null</span>)</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;radarAxisData.getTypes().length; j++)&#123;</div><div class="line">            mPathRing.lineTo(radarAxisData.getAxisLength()*radarAxisData.getCosArray()[j],</div><div class="line">                    radarAxisData.getAxisLength()*radarAxisData.getSinArray()[j]);</div><div class="line">        &#125;</div><div class="line">    <span class="comment">//闭合路径</span></div><div class="line">    mPathRing.close();</div><div class="line">    <span class="comment">//绘制路径</span></div><div class="line">    canvas.drawPath(mPathRing,mPaintLine);</div><div class="line">    mPathRing.reset();</div><div class="line">    canvas.restore();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>然后是绘制正多边形各角的连线以及对应的名称</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (radarAxisData.getTypes()!=<span class="keyword">null</span>)</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;radarAxisData.getTypes().length; j++)&#123;</div><div class="line">    	<span class="comment">//连接各点</span></div><div class="line">        mPathLine.moveTo(<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">        mPathLine.lineTo(radarAxisData.getAxisLength()*radarAxisData.getCosArray()[j],</div><div class="line">                radarAxisData.getAxisLength()*radarAxisData.getSinArray()[j]);</div><div class="line">        <span class="comment">//绘制文字</span></div><div class="line">        canvas.save();</div><div class="line">        canvas.rotate(<span class="number">180</span>);</div><div class="line">        <span class="comment">//设置文字坐标</span></div><div class="line">        mPointF.y = -radarAxisData.getAxisLength()*radarAxisData.getSinArray()[j]*<span class="number">1.1f</span>;</div><div class="line">        mPointF.x = -radarAxisData.getAxisLength()*radarAxisData.getCosArray()[j]*<span class="number">1.1f</span>;</div><div class="line">        <span class="comment">//根据cos值，判断文字位置，设置居左、居中、居右</span></div><div class="line">        <span class="keyword">if</span> (radarAxisData.getCosArray()[j]&gt;<span class="number">0.2</span>)&#123;</div><div class="line">            textCenter(<span class="keyword">new</span> String[]&#123;radarAxisData.getTypes()[j]&#125;,mPaintText,canvas,mPointF, Paint.Align.RIGHT);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (radarAxisData.getCosArray()[j]&lt;-<span class="number">0.2</span>)&#123;</div><div class="line">            textCenter(<span class="keyword">new</span> String[]&#123;radarAxisData.getTypes()[j]&#125;,mPaintText,canvas,mPointF, Paint.Align.LEFT);</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            textCenter(<span class="keyword">new</span> String[]&#123;radarAxisData.getTypes()[j]&#125;,mPaintText,canvas,mPointF, Paint.Align.CENTER);</div><div class="line">        &#125;</div><div class="line">        canvas.restore();</div><div class="line">    &#125;</div><div class="line">mPathLine.close();</div><div class="line">canvas.drawPath(mPathLine,mPaintLine);</div><div class="line">mPathLine.reset();</div><div class="line">canvas.restore();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>因为文字的方向性，所以在代码中选转180，回到初始的角度。同时通过判断cos值的大小，来设置文字的居左、居中、居右。</p>
<ul>
<li>最后给网格绘制刻度，因为y轴正方向是向下的，所以在设置坐标是需这只负值。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置小数点位数</span></div><div class="line">NumberFormat numberFormat = NumberFormat.getNumberInstance();</div><div class="line">numberFormat.setMaximumFractionDigits(radarAxisData.getDecimalPlaces());</div><div class="line"><span class="keyword">if</span> (radarAxisData.getIsTextSize())</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;number+<span class="number">1</span>; i++)&#123;</div><div class="line">        mPointF.x = <span class="number">0</span>;</div><div class="line">        mPointF.y = -radarAxisData.getAxisLength()*(<span class="number">1</span>-i/number);</div><div class="line">        <span class="comment">//绘制文字</span></div><div class="line">        canvas.drawText(numberFormat.format(radarAxisData.getMinimum()+radarAxisData.getInterval()*(number-i))</div><div class="line">                +<span class="string">" "</span>+radarAxisData.getUnit(), mPointF.x, mPointF.y, mPaintText);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="三、绘制数据覆盖区域"><a href="#三、绘制数据覆盖区域" class="headerlink" title="三、绘制数据覆盖区域"></a>三、绘制数据覆盖区域</h2><p>绘制实际数据也是在onDraw中进行的，只需计算出各个数据在画布上的实际长度，再乘以相应的cos、sin之后，就可以获得相应的坐标点。需要注意的是，绘制的点数需要以传入的各角的字符串的数量为准，同时在数据为空的情况下，设置数据为0即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawGraph</span><span class="params">(Canvas canvas, <span class="keyword">float</span> animatedValue)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;radarAxisData.getTypes().length; i++)&#123;</div><div class="line">        <span class="keyword">if</span> (i&lt;radarData.getValue().size()) &#123;</div><div class="line">            <span class="keyword">float</span> value = radarData.getValue().get(i);</div><div class="line">            <span class="keyword">float</span> yValue = (value-radarAxisData.getMinimum())*radarAxisData.getAxisScale();</div><div class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>)&#123;</div><div class="line">            	<span class="comment">//移动至第一点</span></div><div class="line">                mPath.moveTo(yValue*radarAxisData.getCosArray()[i],yValue*radarAxisData.getSinArray()[i]);</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">            	<span class="comment">//连接其余各点</span></div><div class="line">                mPath.lineTo(yValue*radarAxisData.getCosArray()[i],yValue*radarAxisData.getSinArray()[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            mPath.lineTo(<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    mPath.close();</div><div class="line">    <span class="comment">//填充区域绘制</span></div><div class="line">    mPaintFill.setColor(radarData.getColor());</div><div class="line">    mPaintFill.setAlpha(radarData.getAlpha());</div><div class="line">    canvas.drawPath(mPath,mPaintFill);</div><div class="line">    <span class="comment">//描线路径绘制</span></div><div class="line">    mPaintStroke.setColor(radarData.getColor());</div><div class="line">    canvas.drawPath(mPath,mPaintStroke);</div><div class="line">    mPath.reset();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="四、适应wrap-content"><a href="#四、适应wrap-content" class="headerlink" title="四、适应wrap_content"></a>四、适应wrap_content</h2><p>View原有的<strong>onMeasure</strong>函数中，使用了<strong>getDefaultSize</strong>方法，来根据不同的测量方式，生成View的实际宽高。来看下<strong>getDefaultSize</strong>的源码 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = size;</div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);<span class="comment">//获取测量方式</span></div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);<span class="comment">//获取测量数值</span></div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">        result = size;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">        result = specSize;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出<strong>getDefaultSize方法</strong>中，对于xml中设置wrap_content时，使用的<strong>AT_MOST</strong>测量方法与<strong>EXACTLY</strong>做了相同处理，并不符合我们的需求。<br><br><br><br>View中还有另一个方法<strong>resolveSizeAndState</strong>可以满足我们对<strong>AT_MOST</strong>情况下View宽高的需求。源码 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveSizeAndState</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec, <span class="keyword">int</span> childMeasuredState)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> result;</div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">            <span class="keyword">if</span> (specSize &lt; size) &#123;</div><div class="line">                result = specSize | MEASURED_STATE_TOO_SMALL;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                result = size;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">            result = specSize;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            result = size;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result | (childMeasuredState &amp; MEASURED_STATE_MASK);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p><strong>resolveSizeAndState</strong>方法中，在<strong>AT_MOST</strong>测量模式下。如果<strong>onMeasure</strong>传递的measureSpec值小于，你给定的size值，则会使用<br>MEASURED_STATE_TOO_SMALL(值为<strong>0x01000000</strong>)整理后的specSize值；如果你给定的size更小，那么就是用你的size作为返回。最后通过与MEASURED_STATE_MASK合成出返回值。</p>
</li>
<li><p>在<strong>EXACTLY</strong>时，和之前的<strong>getDefaultSize</strong>相同，即给定宽高值得情况下，使用了<strong>onMeasure</strong>中获取的值。</p>
</li>
<li><p>在<strong>UNSPECIFIED</strong>时，也和之前的<strong>getDefaultSize</strong>相同，即View想要多大就多大的情况下，使用了给定的size作为返回值，而我们没有子View，childMeasuredState设置为0即可。最后通过与MEASURED_STATE_MASK合成出返回值。</p>
</li>
</ul>
<p>现在使用<strong>resolveSizeAndState</strong>方法只差size值了，获取size值的方法与之前的<a href="https://github.com/Idtk/Blog/blob/master/Blog/5%E3%80%81PieChart.md" target="_blank" rel="external">PieChart</a>类似，通过计算需要绘制文字的宽高以及数量，来计算出size值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> wrapSize;</div><div class="line">    <span class="keyword">if</span> (mDataList!=<span class="keyword">null</span>&amp;&amp;mDataList.size()&gt;<span class="number">1</span>&amp;&amp;mRadarAxisData.getTypes().length&gt;<span class="number">1</span>)&#123;</div><div class="line">    	<span class="comment">//设置小数位数</span></div><div class="line">        NumberFormat numberFormat =NumberFormat.getPercentInstance();</div><div class="line">        numberFormat.setMinimumFractionDigits(mRadarAxisData.getDecimalPlaces());</div><div class="line">        paintText.setStrokeWidth(mRadarAxisData.getPaintWidth());</div><div class="line">        paintText.setTextSize(mRadarAxisData.getTextSize());</div><div class="line">        <span class="comment">//获取FontMetrics</span></div><div class="line">        Paint.FontMetrics fontMetrics= paintText.getFontMetrics();</div><div class="line">        <span class="keyword">float</span> top = fontMetrics.top;<span class="comment">//获取baseline之上高度</span></div><div class="line">        <span class="keyword">float</span> bottom = fontMetrics.bottom; <span class="comment">//获取baseline之下高度</span></div><div class="line">        <span class="keyword">float</span> webWidth = (bottom-top)*(<span class="keyword">float</span>) Math.ceil((mRadarAxisData.getMaximum()-mRadarAxisData.getMinimum())</div><div class="line">                /mRadarAxisData.getInterval());<span class="comment">//计算单个高度*数量</span></div><div class="line">        <span class="keyword">float</span> nameWidth = paintText.measureText(mRadarAxisData.getTypes()[<span class="number">0</span>]);<span class="comment">//计算正多边形各角字符的长度</span></div><div class="line">        wrapSize = (<span class="keyword">int</span>) (webWidth*<span class="number">2</span>+nameWidth*<span class="number">1.1</span>);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        wrapSize = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> wrapSize;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由代码可以看出通过计算出刻度值的高度乘以刻度个数与各角字符的高度乘以2相加来合成Size值。<br><br>最后只要在<strong>onMeasure</strong>中使用size值，即可实现雷达图<strong>wrap_content</strong>效果。与getSuggestedMinimumWidth()获取的值相比较是为了防止，size过小而出现以外，虽然此情况出现的几率并不大。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    setMeasuredDimension(</div><div class="line">            Math.max(getSuggestedMinimumWidth(),</div><div class="line">                    resolveSize(getCurrentWidth(),</div><div class="line">                            widthMeasureSpec)),</div><div class="line">            Math.max(getSuggestedMinimumHeight(),</div><div class="line">                    resolveSize(getCurrentHeight(),</div><div class="line">                            heightMeasureSpec)));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>本文通过重写View中的相关流程函数，详细的说明了雷达图(蜘蛛网图)的具体实现，同时比较<strong>resolveSizeAndState</strong>和<strong>getDefaultSize</strong>的大致内容，以选取更合适的方法来动态的适应<strong>wrap_content</strong>。并且简单介绍了PathMeasure类的<strong>getPosTan</strong>方法，使用此方法可以更方便的获取雷达图各顶点方向的cos、sin值。<br></p>
<p>如果在阅读过程中，有任何疑问与问题，欢迎与我联系。<br><br><strong>博客:www.idtkm.com</strong><br><br><strong>GitHub:<a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><br><strong>微博:<a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><br><strong>邮箱:IdtkMa@gmail.com</strong><br><br><br></p>
<p><a href="https://github.com/Idtk/SmallChart" target="_blank" rel="external">雷达图源码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;效果图:&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ompb0h8qq.bkt.clouddn.com/old/radar.png&quot; alt=&quot;radar&quot; title=&quot;radar&quot; width=&quot;300&quot;/&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;阅读本文前需了解View的绘制流程，画布操作，以及Path的常用方法，如果不熟悉，请先查看我之前的文章&lt;a href=&quot;http://www.idtkm.com/customview/customview1/&quot;&gt;Android坐标系与View绘制流程&lt;/a&gt;、&lt;a href=&quot;http://www.idtkm.com/customview/customview2/&quot;&gt;Canvas与ValueAnimator&lt;/a&gt;、&lt;a href=&quot;http://www.idtkm.com/customview/customview4/&quot;&gt;Path图形与逻辑运算&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Idtk/Blog&quot;&gt;自定义View系列目录&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、获取View宽高以及cos、sin&quot;&gt;&lt;a href=&quot;#一、获取View宽高以及cos、sin&quot; class=&quot;headerlink&quot; title=&quot;一、获取View宽高以及cos、sin&quot;&gt;&lt;/a&gt;一、获取View宽高以及cos、sin&lt;/h2&gt;&lt;p&gt;在onSizeChanged函数中，可以获取当前View的宽高以及根据padding值计算出的实际绘制区域的宽高，同时计算出雷达图的半径设置并通过PathMeasure类的&lt;strong&gt;getPosTan&lt;/strong&gt;方法获得此任意正多边形各角坐标的余弦值、正弦值。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="CustomView" scheme="http://www.idtkm.com/tags/CustomView/"/>
    
  </entry>
  
  <entry>
    <title>Path中的贝塞尔曲线</title>
    <link href="http://www.idtkm.com/2016/06/21/6%E3%80%81Bezier/"/>
    <id>http://www.idtkm.com/2016/06/21/6、Bezier/</id>
    <published>2016-06-20T16:00:00.000Z</published>
    <updated>2017-10-15T16:02:06.322Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Idtk/Blog" target="_blank" rel="external">自定义View系列目录</a></p>
<h2 id="一、数学中的贝塞尔"><a href="#一、数学中的贝塞尔" class="headerlink" title="一、数学中的贝塞尔"></a>一、数学中的贝塞尔</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>贝塞尔曲线于1962年，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau于1959年运用de Casteljau算法开发，以稳定数值的方法求出贝塞尔曲线。<br><br>在计算机图形学中贝赛尔曲线的运用也很广泛，Photoshop中的钢笔效果，Flash5的贝塞尔曲线工具，在软件GUI开发中一般也会提供对应的方法来实现贝赛尔曲线。</p>
<h3 id="线性贝塞尔曲线"><a href="#线性贝塞尔曲线" class="headerlink" title="线性贝塞尔曲线"></a>线性贝塞尔曲线</h3><p>给定点P0、P1，线性贝兹曲线只是一条两点之间的直线。<br>就像由0至1的连续t，B（t）描述一条由P0至P1的直线。<br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/Bézier_1_big.gif" alt="Bezier" title="Bezier" width="300"><br><br><br></p>
<a id="more"></a>
<h3 id="二次贝塞尔曲线"><a href="#二次贝塞尔曲线" class="headerlink" title="二次贝塞尔曲线"></a>二次贝塞尔曲线</h3><p>二次方贝塞尔曲线的路径由给定点P0、P1、P2的函数B（t）追踪：<br></p>
<p><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/Bézier_2_big.svg.png" alt="Bezier" title="Bezier" width="300"><br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/Bézier_2_big.gif" alt="Bezier" title="Bezier" width="300"><br><br><br></p>
<h3 id="三阶贝塞尔曲线"><a href="#三阶贝塞尔曲线" class="headerlink" title="三阶贝塞尔曲线"></a>三阶贝塞尔曲线</h3><p>P0、P1、P2、P3四个点在平面或在三维空间中定义了三次方贝塞尔曲线。曲线起始于P0走向P1，并从P2的方向来到P3。一般不会经过P1或P2；这两个点只是在那里提供方向资讯。P0和P1之间的间距，决定了曲线在转而趋进P2之前，走向P1方向的“长度有多长”。<br><br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/Bézier_3_big.svg.png" alt="Bezier" title="Bezier" width="300"><br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/Bézier_3_big.gif" alt="Bezier" title="Bezier" width="300"><br><br><br></p>
<p>(<strong>PS:以上内容来自<a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A" target="_blank" rel="external">Wike</a></strong>)</p>
<h2 id="二、Android中的贝塞尔使用"><a href="#二、Android中的贝塞尔使用" class="headerlink" title="二、Android中的贝塞尔使用"></a>二、Android中的贝塞尔使用</h2><p>数学的一节内容只要有个直观的感受就好，重点主要是Android中的贝塞尔曲线。<br><br></p>
<h3 id="1、quadTo"><a href="#1、quadTo" class="headerlink" title="1、quadTo"></a>1、quadTo</h3><p><strong>Path.quadTo</strong>是Android的二次贝塞尔曲线的API，示例如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</div><div class="line">    mViewWidth = w;</div><div class="line">    mViewHeight = h;</div><div class="line">    mWidth = mViewWidth - getPaddingLeft() - getPaddingRight();</div><div class="line">    mHeight = mViewHeight - getPaddingTop() - getPaddingBottom();</div><div class="line">    r = Math.min(mWidth,mHeight)*<span class="number">0.4f</span>;</div><div class="line">    rectF = <span class="keyword">new</span> RectF(-r,-r,r,r);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    mPaint.setColor(Color.MAGENTA);</div><div class="line">    mPaint.setStrokeWidth(<span class="number">8</span>);</div><div class="line">    canvas.translate(mViewWidth/<span class="number">2</span>,mViewHeight/<span class="number">2</span>);</div><div class="line">    mPath.moveTo(-r/<span class="number">2</span>,<span class="number">0</span>);</div><div class="line">    mPath.quadTo(<span class="number">0</span>,-r/<span class="number">2</span>,r/<span class="number">2</span>,<span class="number">0</span>);</div><div class="line">    canvas.drawPath(mPath,mPaint);</div><div class="line">    mPath.rewind();</div><div class="line">    mPaint.setColor(Color.GRAY);</div><div class="line">    mPaint.setStrokeWidth(<span class="number">20</span>);</div><div class="line">    canvas.drawPoints(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</div><div class="line">            start.x,start.y,</div><div class="line">            end.x,end.y,</div><div class="line">            control1.x,control1.y</div><div class="line">    &#125;,mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/quadTo.png" alt="quadTo" title="quadTo" width="300"><br><br></p>
<ul>
<li>使用二次贝塞尔函数完成一个正弦波，这里使用rQuadTo<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    mPaint.setColor(Color.MAGENTA);</div><div class="line">    mPaint.setStrokeWidth(<span class="number">8</span>);</div><div class="line">    canvas.translate(mViewWidth/<span class="number">2</span>,mViewHeight/<span class="number">2</span>);</div><div class="line">    mPath.moveTo(-r,<span class="number">0</span>);</div><div class="line">    mPath.rQuadTo(r/<span class="number">2</span>,-r/<span class="number">8</span>,r,<span class="number">0</span>);</div><div class="line">    mPath.rQuadTo(r/<span class="number">2</span>,r/<span class="number">8</span>,r,<span class="number">0</span>);</div><div class="line">    canvas.drawPath(mPath,mPaint);</div><div class="line">    mPath.rewind();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/quadTo2.png" alt="quadTo" title="quadTo" width="300"><br><br></p>
<ul>
<li><p>增加一个圆,以r为半径，(0,0)为圆心</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">canvas.drawCircle(<span class="number">0</span>,<span class="number">0</span>,r,mPaint2);</div></pre></td></tr></table></figure>
</li>
<li><p>增加一个连接正弦波两端点的半圆弧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rectF = <span class="keyword">new</span> RectF(-r,-r,r,r);</div><div class="line">mPath.addArc(rectF,<span class="number">0</span>,<span class="number">180</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/quadTo3.png" alt="quadTo" title="quadTo" width="300"><br><br></p>
<ul>
<li><strong>更进一步</strong><br><br>如果我希望水量是30%，80%或者别的值呢？其实只需要修改正弦值的周期即可。具体代码如下(已省略set方法) :<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by Idtk on 2016/6/19.</div><div class="line"> * Blog : http://www.idtkm.com</div><div class="line"> * GitHub : https://github.com/Idtk</div><div class="line"> * 描述 : 显示百分比注水球</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bezier</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Paint mPaint,mPaint2;</div><div class="line">    <span class="keyword">private</span> Path mPath = <span class="keyword">new</span> Path();</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> mViewWidth,mViewHeight;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> mWidth,mHeight;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> r,rArc,x;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> percent=<span class="number">0.5f</span>;</div><div class="line">    <span class="keyword">private</span> RectF rectF;</div><div class="line">    <span class="keyword">private</span> PointF mPointF = <span class="keyword">new</span> PointF(<span class="number">0</span>,<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bezier2</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bezier2</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line"></div><div class="line">        mPaint = <span class="keyword">new</span> Paint();</div><div class="line">        mPaint.setColor(Color.BLACK);</div><div class="line">        mPaint.setStrokeWidth(<span class="number">3</span>);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setTextSize(<span class="number">100</span>);</div><div class="line"></div><div class="line">        mPaint2 = <span class="keyword">new</span> Paint();</div><div class="line">        mPaint2.setColor(Color.CYAN);</div><div class="line">        mPaint2.setStrokeWidth(<span class="number">8</span>);</div><div class="line">        mPaint2.setStyle(Paint.Style.FILL);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</div><div class="line"></div><div class="line">        mViewWidth = w;</div><div class="line">        mViewHeight = h;</div><div class="line"></div><div class="line">        mWidth = mViewWidth - getPaddingLeft() - getPaddingRight();</div><div class="line">        mHeight = mViewHeight - getPaddingTop() - getPaddingBottom();</div><div class="line"></div><div class="line">        r = Math.min(mWidth,mHeight)*<span class="number">0.4f</span>;</div><div class="line">        rectF = <span class="keyword">new</span> RectF(-r,-r,r,r);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line"><span class="comment">//        super.onDraw(canvas);</span></div><div class="line">        canvas.translate(mViewWidth/<span class="number">2</span>,mViewHeight/<span class="number">2</span>);</div><div class="line">        canvas.drawCircle(<span class="number">0</span>,<span class="number">0</span>,r,mPaint);</div><div class="line">        rArc = r*(<span class="number">1</span>-<span class="number">2</span>*percent);</div><div class="line">        <span class="keyword">double</span> angle= Math.acos((<span class="keyword">double</span>) rArc/r);</div><div class="line">        x = r*(<span class="keyword">float</span>) Math.sin(angle);</div><div class="line">        mPath.addArc(rectF,<span class="number">90</span>-(<span class="keyword">float</span>) Math.toDegrees(angle),(<span class="keyword">float</span>) Math.toDegrees(angle)*<span class="number">2</span>);</div><div class="line">        mPath.moveTo(-x,rArc);</div><div class="line">        mPath.rQuadTo(x/<span class="number">2</span>,-r/<span class="number">8</span>,x,<span class="number">0</span>);</div><div class="line">        mPath.rQuadTo(x/<span class="number">2</span>,r/<span class="number">8</span>,x,<span class="number">0</span>);</div><div class="line">        canvas.drawPath(mPath,mPaint2);</div><div class="line">        mPath.rewind();</div><div class="line">        NumberFormat numberFormat =NumberFormat.getPercentInstance();</div><div class="line">        numberFormat.setMinimumFractionDigits(<span class="number">1</span>);</div><div class="line">        textCenter(<span class="keyword">new</span> String[]&#123;numberFormat.format(percent)&#125;,mPaint,canvas,mPointF, Paint.Align.CENTER);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 多行文本居中、居右、居左</div><div class="line">     * <span class="doctag">@param</span> strings 文本字符串列表</div><div class="line">     * <span class="doctag">@param</span> paint 画笔</div><div class="line">     * <span class="doctag">@param</span> canvas 画布</div><div class="line">     * <span class="doctag">@param</span> point 点的坐标</div><div class="line">     * <span class="doctag">@param</span> align 居中、居右、居左</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">textCenter</span><span class="params">(String[] strings, Paint paint, Canvas canvas, PointF point, Paint.Align align)</span></span>&#123;</div><div class="line">        paint.setTextAlign(align);</div><div class="line">        Paint.FontMetrics fontMetrics= paint.getFontMetrics();</div><div class="line">        <span class="keyword">float</span> top = fontMetrics.top;</div><div class="line">        <span class="keyword">float</span> bottom = fontMetrics.bottom;</div><div class="line">        <span class="keyword">int</span> length = strings.length;</div><div class="line">        <span class="keyword">float</span> total = (length-<span class="number">1</span>)*(-top+bottom)+(-fontMetrics.ascent+fontMetrics.descent);</div><div class="line">        <span class="keyword">float</span> offset = total/<span class="number">2</span>-bottom;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">            <span class="keyword">float</span> yAxis = -(length - i - <span class="number">1</span>) * (-top + bottom) + offset;</div><div class="line">            canvas.drawText(strings[i], point.x, point.y + yAxis, paint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/quadTo4.png" alt="quadTo" title="quadTo" width="300"><br><br></p>
<h3 id="2、cubicTo"><a href="#2、cubicTo" class="headerlink" title="2、cubicTo"></a>2、cubicTo</h3><p><strong>Path.cubicTo</strong>是Android的三次贝塞尔曲线的API，示例如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</div><div class="line">    mViewWidth = w;</div><div class="line">    mViewHeight = h;</div><div class="line">    mWidth = mViewWidth - getPaddingLeft() - getPaddingRight();</div><div class="line">    mHeight = mViewHeight - getPaddingTop() - getPaddingBottom();</div><div class="line">    r = Math.min(mWidth,mHeight)*<span class="number">0.4f</span>;</div><div class="line">    start.x = -r;</div><div class="line">    start.y = <span class="number">0</span>;</div><div class="line">    control1.x = -r/<span class="number">2</span>;</div><div class="line">    control1.y = -r/<span class="number">2</span>;</div><div class="line">    control2.x = r/<span class="number">2</span>;</div><div class="line">    control2.y = r/<span class="number">2</span>;</div><div class="line">    end.x = r;</div><div class="line">    end.y = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    canvas.translate(mViewWidth/<span class="number">2</span>,mViewHeight/<span class="number">2</span>);</div><div class="line">    mPaint.setColor(Color.MAGENTA);</div><div class="line">    mPaint.setStrokeWidth(<span class="number">8</span>);</div><div class="line">    mPath.moveTo(start.x,start.y);</div><div class="line">    mPath.cubicTo(control1.x,control1.y,control2.x,control2.y,end.x,end.y);</div><div class="line">    canvas.drawPath(mPath,mPaint);</div><div class="line">    mPath.rewind();</div><div class="line">    mPaint.setColor(Color.GRAY);</div><div class="line">    mPaint.setStrokeWidth(<span class="number">20</span>);</div><div class="line">    canvas.drawPoints(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</div><div class="line">            start.x,start.y,</div><div class="line">            end.x,end.y,</div><div class="line">            control1.x,control1.y,</div><div class="line">            control2.x,control2.y</div><div class="line">    &#125;,mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/cubicTo.png" alt="cubicTo" title="cubicTo" width="300"><br><br><br>是不是和之前quadTo生成的水纹很像？如果想要在上面的<strong>百分比注水球类</strong>中加入动画，并且不要求一定是正弦波的情况下，使用cubicTo可以更为方便。<br><br><br>我最近在做的开源图表库<a href="https://github.com/Idtk/SmallChart" target="_blank" rel="external">SmallChart</a>中绘制曲线时，就是用了cubicTo。同时使用了MPChart项目中的算法，对高阶贝塞尔曲线进行了降阶，相关代码如下 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">cubicPath.moveTo((cur.x-xAxisData.getMinimum())*xAxisData.getAxisScale(),</div><div class="line">        -(cur.y-yAxisData.getMinimum())*yAxisData.getAxisScale()*animatedValue);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt; curveData.getValue().size(); j++)&#123;</div><div class="line">    prevPrev = curveData.getValue().get(j == <span class="number">1</span> ? <span class="number">0</span> : j - <span class="number">2</span>);</div><div class="line">    prev = curveData.getValue().get(j-<span class="number">1</span>);</div><div class="line">    cur = curveData.getValue().get(j);</div><div class="line">    next = curveData.getValue().size() &gt; j+<span class="number">1</span> ? curveData.getValue().get(j+<span class="number">1</span>) : cur;</div><div class="line">    prevDx = (cur.x-prevPrev.x)*intensity*xAxisData.getAxisScale();</div><div class="line">    prevDy = (cur.y-prevPrev.y)*intensity*yAxisData.getAxisScale();</div><div class="line">    curDx = (next.x-prev.x)*intensity*xAxisData.getAxisScale();</div><div class="line">    curDy = (next.y-prev.y)*intensity*yAxisData.getAxisScale();</div><div class="line">    cubicPath.cubicTo((prev.x-xAxisData.getMinimum())*xAxisData.getAxisScale()+prevDx,</div><div class="line">            -(((prev.y-yAxisData.getMinimum())*yAxisData.getAxisScale()+prevDy)*animatedValue),</div><div class="line">            ((cur.x-xAxisData.getMinimum())*xAxisData.getAxisScale()-curDx),</div><div class="line">            -(((cur.y-yAxisData.getMinimum())*yAxisData.getAxisScale()-curDy)*animatedValue),</div><div class="line">            ((cur.x-xAxisData.getMinimum())*xAxisData.getAxisScale()),</div><div class="line">            -(((cur.y-yAxisData.getMinimum())*yAxisData.getAxisScale())*animatedValue));</div><div class="line">&#125;</div><div class="line">canvas.save();</div><div class="line">canvas.translate(offset,<span class="number">0</span>);</div><div class="line">cubicPaint.setColor(curveData.getColor());</div><div class="line">canvas.drawPath(cubicPath,cubicPaint);</div><div class="line">cubicPath.rewind();</div></pre></td></tr></table></figure></p>
<p><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/cubicTo2.png" alt="cubicTo" title="cubicTo" width="300"><br><br></p>
<h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>本文介绍了Path的贝塞尔曲线，同时通过百分比注水图以及平滑曲线的例子，进行了实战。贝塞尔曲线是Android中非常重要的方法，可以实现多种效果，比如以下的几个例子：</p>
<ul>
<li>QQ的拖拽小红点<br></li>
<li>饿了吗点餐动画<br></li>
<li>水滴效果<br></li>
<li>平滑曲线<br></li>
<li>弹性效果<br></li>
</ul>
<p>如果在阅读过程中，有任何疑问与问题，欢迎与我联系。<br><br><strong>博客:www.idtkm.com</strong><br><br><strong>GitHub:<a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><br><strong>微博:<a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><br><strong>邮箱:IdtkMa@gmail.com</strong><br><br><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Idtk/Blog&quot;&gt;自定义View系列目录&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、数学中的贝塞尔&quot;&gt;&lt;a href=&quot;#一、数学中的贝塞尔&quot; class=&quot;headerlink&quot; title=&quot;一、数学中的贝塞尔&quot;&gt;&lt;/a&gt;一、数学中的贝塞尔&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;贝塞尔曲线于1962年，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau于1959年运用de Casteljau算法开发，以稳定数值的方法求出贝塞尔曲线。&lt;br&gt;&lt;br&gt;在计算机图形学中贝赛尔曲线的运用也很广泛，Photoshop中的钢笔效果，Flash5的贝塞尔曲线工具，在软件GUI开发中一般也会提供对应的方法来实现贝赛尔曲线。&lt;/p&gt;
&lt;h3 id=&quot;线性贝塞尔曲线&quot;&gt;&lt;a href=&quot;#线性贝塞尔曲线&quot; class=&quot;headerlink&quot; title=&quot;线性贝塞尔曲线&quot;&gt;&lt;/a&gt;线性贝塞尔曲线&lt;/h3&gt;&lt;p&gt;给定点P0、P1，线性贝兹曲线只是一条两点之间的直线。&lt;br&gt;就像由0至1的连续t，B（t）描述一条由P0至P1的直线。&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ompb0h8qq.bkt.clouddn.com/old/Bézier_1_big.gif&quot; alt=&quot;Bezier&quot; title=&quot;Bezier&quot; width=&quot;300&quot; /&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="CustomView" scheme="http://www.idtkm.com/tags/CustomView/"/>
    
  </entry>
  
  <entry>
    <title>PieChart扇形图的实现</title>
    <link href="http://www.idtkm.com/2016/06/13/5%E3%80%81PieChart/"/>
    <id>http://www.idtkm.com/2016/06/13/5、PieChart/</id>
    <published>2016-06-12T16:00:00.000Z</published>
    <updated>2017-10-15T16:02:11.740Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ompb0h8qq.bkt.clouddn.com/all/PieChart.gif" alt="PieChat" title="PieChat" width="300"><br></p>
<p>(<strong>PS: 经过之前<a href="http://www.idtkm.com/category/customview/">4篇博客</a>的基础知识学习，终于可以开始编写PieChart了 ~(≧▽≦)/~啦啦啦</strong>)</p>
<a id="more"></a>
<p><a href="https://github.com/Idtk/Blog" target="_blank" rel="external">自定义View系列目录</a></p>
<h2 id="一、数据需求"><a href="#一、数据需求" class="headerlink" title="一、数据需求"></a>一、数据需求</h2><p>来分析下，用户需要提供怎样的数据，首先要有数据的值，然后还需要对应的数据名称，以及颜色。绘制PieChart需要什么呢，由图可以看出，需要百分比值，扇形角度，色块颜色。所以总共属性有:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PieData</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> value;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> percentage;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> color = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> angle = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>各属性的set与get请自行增加。</p>
<h2 id="二、构造函数"><a href="#二、构造函数" class="headerlink" title="二、构造函数"></a>二、构造函数</h2><p>构造函数中，增加一些xml设置，创建一个attrs.xml<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;declare-styleable name="PieChart"&gt;</div><div class="line">        &lt;attr name="name" format="string"/&gt;</div><div class="line">        &lt;attr name="percentDecimal" format="integer"/&gt;</div><div class="line">        &lt;attr name="textSize" format="dimension"/&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p>
<p>这是只设置了一部分属性，如果你有强迫症希望全部设置的话，可以自行增加。在PieChart中使用TypedArray进行属性的获取。建议使用如下的写法，<strong>可以避免在没有设置属性时，也运行getXXX方法</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.PieChart, defStyleAttr,defStyleRes);</div><div class="line"><span class="keyword">int</span> n = array.getIndexCount();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</div><div class="line">    <span class="keyword">int</span> attr = array.getIndex(i);</div><div class="line">    <span class="keyword">switch</span> (attr)&#123;</div><div class="line">        <span class="keyword">case</span> R.styleable.PieChart_name:</div><div class="line">            name = array.getString(attr);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> R.styleable.PieChart_percentDecimal:</div><div class="line">            percentDecimal = array.getInt(attr,percentDecimal);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> R.styleable.PieChart_textSize:</div><div class="line">            percentTextSize = array.getDimensionPixelSize(attr,percentTextSize);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">array.recycle();</div></pre></td></tr></table></figure></p>
<h2 id="三、动画函数"><a href="#三、动画函数" class="headerlink" title="三、动画函数"></a>三、动画函数</h2><p>绘制一个完整的圆，旋转的角度为360，动画时间为可set参数，默认5秒，监听animatedValue参数，用于与绘制时进行计算。ValueAnimator类涉及到的参数的意义请查看<a href="http://www.idtkm.com/customview/customview2/">自定义View——Canvas与ValueAnimator</a>文章。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAnimator</span><span class="params">(<span class="keyword">long</span> duration)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (animator !=<span class="keyword">null</span> &amp;&amp;animator.isRunning())&#123;</div><div class="line">        animator.cancel();</div><div class="line">        animator.start();</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        animator=ValueAnimator.ofFloat(<span class="number">0</span>,<span class="number">360</span>).setDuration(duration);</div><div class="line">        animator.setInterpolator(timeInterpolator);</div><div class="line">        animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</div><div class="line">                animatedValue = (<span class="keyword">float</span>) animation.getAnimatedValue();</div><div class="line">                invalidate();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        animator.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="四、onMeasure"><a href="#四、onMeasure" class="headerlink" title="四、onMeasure"></a>四、onMeasure</h2><p>View默认的onMeasure方法中，并没有根据测量模式，对布局宽高进行调整，所以为了适应<strong>wrap_content</strong>的布局设置，需要对onMeasure方法进行重写。<br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> width = measureDimension(widthMeasureSpec);</div><div class="line">    <span class="keyword">int</span> height = measureDimension(heightMeasureSpec);</div><div class="line">    setMeasuredDimension(width,height);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br><br>重写的onMeasure方法，调用了自定义的<strong>measureDimension</strong>方法处理数据，完成后交给系统的setMeasuredDimension方法。接下来看下自定义的<strong>measureDimension</strong>方法。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">measureDimension</span><span class="params">(<span class="keyword">int</span> measureSpec)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> size = measureWrap(mPaint);</div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line">    <span class="keyword">switch</span> (specMode)&#123;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">            size = measureWrap(mPaint);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">            size = specSize;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">			<span class="comment">//合适尺寸不得大于View的尺寸</span></div><div class="line">            size = Math.min(specSize,measureWrap(mPaint));</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><br><br><strong>measureDimension</strong>根据测量的类型，分别计算尺寸的长度，每个类型的含义在<a href="http://www.idtkm.com/customview/customview1/">第一篇</a>中已经进行了说明，在这里不再赘述。<strong>EXACTLY</strong>是在xml中定义<strong>match_parent以及具体的数值</strong>是使用，而<strong>AT_MOST</strong>则是在<strong>wrap_content</strong>时使用，<strong>measureWrap</strong>方法用于计算当前PieChart的最小合适长度，接下来看看这个方法。<br><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">measureWrap</span><span class="params">(Paint paint)</span></span>&#123;</div><div class="line">    <span class="keyword">float</span> wrapSize;</div><div class="line">    <span class="keyword">if</span> (mPieData!=<span class="keyword">null</span>&amp;&amp;mPieData.size()&gt;<span class="number">1</span>)&#123;</div><div class="line">        NumberFormat numberFormat =NumberFormat.getPercentInstance();</div><div class="line">        numberFormat.setMinimumFractionDigits(percentDecimal);</div><div class="line">        paint.setTextSize(percentTextSize);</div><div class="line">        <span class="keyword">float</span> percentWidth = paint.measureText(numberFormat.format(mPieData.get(stringId).getPercentage())+<span class="string">""</span>);</div><div class="line">        paint.setTextSize(centerTextSize);</div><div class="line">        <span class="keyword">float</span> nameWidth = paint.measureText(name+<span class="string">""</span>);</div><div class="line">        wrapSize = (percentWidth*<span class="number">4</span>+nameWidth*<span class="number">1.0f</span>)*(<span class="keyword">float</span>) offsetScaleRadius;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        wrapSize = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) wrapSize;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><br><br>测量宽高的方式类似于TextView，根据PieChart中的<strong>图名与百分比文本的宽度</strong>进行计算的。其中stringId是在处理数据的过程中，计算出的拥有最长字符的区域Id。<br></p>
<p>从代码中可以看出，<strong>wrap_content情况下的，PieChart的宽高就等于百分比字符长度的4倍，加上图名的长度。</strong><br><br></p>
<h2 id="五、onSizeChanged"><a href="#五、onSizeChanged" class="headerlink" title="五、onSizeChanged"></a>五、onSizeChanged</h2><p>在此函数中，获取当前View的宽高以及根据<strong>padding</strong>值计算出的实际绘制区域的宽高，同时进行PieChart绘制所需的半径以及布局位置设置。<br><br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/onSizeChange.png" alt="onSizeChanged" title="onSizeChanged" width="300"><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</div><div class="line">    mWidth = w-getPaddingLeft()-getPaddingRight();<span class="comment">//适应padding设置</span></div><div class="line">    mHeight = h-getPaddingTop()-getPaddingBottom();<span class="comment">//适应padding设置</span></div><div class="line">    mViewWidth = w;</div><div class="line">    mViewHeight = h;</div><div class="line">    <span class="comment">//标准圆环</span></div><div class="line">    <span class="comment">//圆弧</span></div><div class="line">    r = (<span class="keyword">float</span>) (Math.min(mWidth,mHeight)/<span class="number">2</span>*widthScaleRadius);<span class="comment">// 饼状图半径</span></div><div class="line">    <span class="comment">// 饼状图绘制区域</span></div><div class="line">    rectF.left = -r;</div><div class="line">    rectF.top = -r;</div><div class="line">    rectF.right =r;</div><div class="line">    rectF.bottom = r;</div><div class="line">    <span class="comment">//白色圆弧</span></div><div class="line">    <span class="comment">//透明圆弧</span></div><div class="line">    rTra = (<span class="keyword">float</span>) (r*radiusScaleTransparent);</div><div class="line">    rectFTra.left = -rTra;</div><div class="line">    rectFTra.top = -rTra;</div><div class="line">    rectFTra.right = rTra;</div><div class="line">    rectFTra.bottom = rTra;</div><div class="line">    <span class="comment">//白色圆</span></div><div class="line">    rWhite = (<span class="keyword">float</span>) (r*radiusScaleInside);</div><div class="line"></div><div class="line">    <span class="comment">//浮出圆环</span></div><div class="line">    <span class="comment">//圆弧</span></div><div class="line">    <span class="comment">// 饼状图半径</span></div><div class="line">    rF = (<span class="keyword">float</span>) (Math.min(mWidth,mHeight)/<span class="number">2</span>*widthScaleRadius*offsetScaleRadius);</div><div class="line">    <span class="comment">// 饼状图绘制区域</span></div><div class="line">    rectFF.left = -rF;</div><div class="line">    rectFF.top = -rF;</div><div class="line">    rectFF.right = rF;</div><div class="line">    rectFF.bottom = rF;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="六、onDraw"><a href="#六、onDraw" class="headerlink" title="六、onDraw"></a>六、onDraw</h2><p>onDraw分为绘制扇形，绘制文本，绘制图名三个部分。绘制扇形和文本时需要与Valueanimator的监听值进行计算，完成动画；另外还要在Touch时进行交互，完成浮出动画。<br><br>在进行具体的绘制之前，需要坐标原点平移至中心位置，并且判断数据是否为空。</p>
<h3 id="1、绘制扇形"><a href="#1、绘制扇形" class="headerlink" title="1、绘制扇形"></a>1、绘制扇形</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">float</span> currentStartAngle = <span class="number">0</span>;<span class="comment">// 当前起始角度</span></div><div class="line">canvas.save();</div><div class="line">canvas.rotate(mStartAngle);</div><div class="line"><span class="keyword">float</span> drawAngle;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mPieData.size(); i++)&#123;</div><div class="line">    PieData pie = mPieData.get(i);</div><div class="line">    <span class="keyword">if</span> (Math.min(pie.getAngle()-<span class="number">1</span>,animatedValue-currentStartAngle)&gt;=<span class="number">0</span>)&#123;</div><div class="line">        drawAngle = Math.min(pie.getAngle()-<span class="number">1</span>,animatedValue-currentStartAngle);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        drawAngle = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (i==angleId)&#123;</div><div class="line">        drawArc(canvas,currentStartAngle,drawAngle,pie,rectFF,rectFTraF,reatFWhite,mPaint);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        drawArc(canvas,currentStartAngle,drawAngle,pie,rectF,rectFTra,rectFIn,mPaint);</div><div class="line">    &#125;</div><div class="line">    currentStartAngle += pie.getAngle();</div><div class="line">&#125;</div><div class="line">canvas.restore();</div></pre></td></tr></table></figure>
<ul>
<li>根据当前的初始角度旋转画布。初始化扇形的起始角度，通过累加计算出下一次的起始角度。<br></li>
<li>drawArc用于绘制扇形，和<a href="http://www.idtkm.com/customview/customview4/">上一篇</a>最后的环形图片一样，通过一大一小两个扇形进行补集运算，获得可知半径的及宽度的圆环，只不过这里多了一个为了立体效果而增加的半透明圆弧。<br></li>
</ul>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/%E7%BB%98%E5%88%B6%E6%89%87%E5%BD%A2.png" alt="绘制扇形" title="绘制扇形" width="300"><br></p>
<ul>
<li>绘制扇形时，使用当前的动画值减去起始角度与当前的扇形经过的角度对比取小，作为当前扇形的需要绘制的经过角度。减1是为了生存扇形区域之间的间隔。<br></li>
<li>angleId用于Touch时显示点击是哪一块扇形，具体判断会在TouchEvent中进行。</li>
</ul>
<h3 id="2、绘制文本"><a href="#2、绘制文本" class="headerlink" title="2、绘制文本"></a>2、绘制文本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//扇形百分比文字</span></div><div class="line">currentStartAngle = mStartAngle;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mPieData.size(); i++)&#123;</div><div class="line">    PieData pie = mPieData.get(i);</div><div class="line">    mPaint.setColor(percentTextColor);</div><div class="line">    mPaint.setTextSize(percentTextSize);</div><div class="line">    mPaint.setTextAlign(Paint.Align.CENTER);</div><div class="line">    NumberFormat numberFormat =NumberFormat.getPercentInstance();</div><div class="line">    numberFormat.setMinimumFractionDigits(percentDecimal);</div><div class="line">    <span class="comment">//根据Paint的TextSize计算Y轴的值</span></div><div class="line">    <span class="keyword">if</span> (animatedValue&gt;pieAngles[i]-pie.getAngle()/<span class="number">2</span>&amp;&amp;percentFlag) &#123;</div><div class="line">        <span class="keyword">if</span> (i == angleId) &#123;</div><div class="line">            drawText(canvas,pie,currentStartAngle,numberFormat,<span class="keyword">true</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (pie.getAngle() &gt; minAngle) &#123;</div><div class="line">                drawText(canvas,pie,currentStartAngle,numberFormat,<span class="keyword">false</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        currentStartAngle += pie.getAngle();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li><strong>文本是有方向的，无法在画布旋转后绘制</strong>，所以初始化当前扇形的起始角度为PieChart的起始角度。<br></li>
<li>然后循环绘制文本，当扇形绘制到当前区域的1/2时，开始绘制当前区域的文字。为了防止文本遮挡视线，在绘制前需要判断此扇形经过的角度是否大于最小显示角度。<br></li>
<li>angleId用于Touch时显示点击是哪一块扇形，具体判断会在TouchEvent中进行。<br><br></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawText</span><span class="params">(Canvas canvas, PieData pie ,<span class="keyword">float</span> currentStartAngle, NumberFormat numberFormat,<span class="keyword">boolean</span> flag)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> textPathX = (<span class="keyword">int</span>) (Math.cos(Math.toRadians(currentStartAngle + (pie.getAngle() / <span class="number">2</span>))) * (r + rTra) / <span class="number">2</span>);</div><div class="line">    <span class="keyword">int</span> textPathY = (<span class="keyword">int</span>) (Math.sin(Math.toRadians(currentStartAngle + (pie.getAngle() / <span class="number">2</span>))) * (r + rTra) / <span class="number">2</span>);</div><div class="line">    mPoint.x = textPathX;</div><div class="line">    mPoint.y = textPathY;</div><div class="line">    String[] strings;</div><div class="line">    <span class="keyword">if</span> (flag)&#123;</div><div class="line">        strings = <span class="keyword">new</span> String[]&#123;pie.getName() + <span class="string">""</span>, numberFormat.format(pie.getPercentage()) + <span class="string">""</span>&#125;;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        strings = <span class="keyword">new</span> String[]&#123;numberFormat.format(pie.getPercentage()) + <span class="string">""</span>&#125;;</div><div class="line">    &#125;</div><div class="line">    textCenter(strings, mPaint, canvas, mPoint, Paint.Align.CENTER);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/%E7%BB%98%E5%88%B6%E6%96%87%E6%9C%AC.png" alt="绘制文本" title="绘制文本" width="300"><br><br>drawText函数的主要作用就是根据传入的Pie，获取大小扇形的半径合除以2，角度取一半，计算出扇形中心点，然后使用之前介绍的<a href="http://www.idtkm.com/customview/customview3/">textCenter多行文本居中函数</a>进行文本绘制。最后累加当前扇形的起始角度，用于下一个扇形使用。<br></p>
<h3 id="3、绘制图名"><a href="#3、绘制图名" class="headerlink" title="3、绘制图名"></a>3、绘制图名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//饼图名</span></div><div class="line">mPaint.setColor(centerTextColor);</div><div class="line">mPaint.setTextSize(centerTextSize);</div><div class="line">mPaint.setTextAlign(Paint.Align.CENTER);</div><div class="line"><span class="comment">//根据Paint的TextSize计算Y轴的值</span></div><div class="line">mPoint.x=<span class="number">0</span>;</div><div class="line">mPoint.y=<span class="number">0</span>;</div><div class="line">String[] strings = <span class="keyword">new</span> String[]&#123;name+<span class="string">""</span>&#125;;</div><div class="line">textCenter(strings,mPaint,canvas,mPoint, Paint.Align.CENTER);</div></pre></td></tr></table></figure>
<p>绘制图名的部分就比较简单了，和之前绘制单个Pie时类似，获取x，y坐标为(0,0),然后使用textCenter多行文本绘制函数进行文本绘制。</p>
<h2 id="七、onTouchEvent"><a href="#七、onTouchEvent" class="headerlink" title="七、onTouchEvent"></a>七、onTouchEvent</h2><p>onTouchEvent用于处理当前的点击事件，具体内容在<a href="http://www.idtkm.com/customview/customview1/">第一篇文章</a>中已经进行了说明，这里使用其中的<strong>ACTION_DOWN</strong>与<strong>ACTION_UP</strong>事件。<br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (touchFlag&amp;&amp;mPieData.size()&gt;<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">switch</span> (event.getAction())&#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">                <span class="keyword">float</span> x = event.getX()-(mWidth/<span class="number">2</span>);</div><div class="line">                <span class="keyword">float</span> y = event.getY()-(mHeight/<span class="number">2</span>);</div><div class="line">                <span class="keyword">float</span> touchAngle = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span> (x&lt;<span class="number">0</span>&amp;&amp;y&lt;<span class="number">0</span>)&#123;</div><div class="line">                    touchAngle += <span class="number">180</span>;</div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (y&lt;<span class="number">0</span>&amp;&amp;x&gt;<span class="number">0</span>)&#123;</div><div class="line">                    touchAngle += <span class="number">360</span>;</div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (y&gt;<span class="number">0</span>&amp;&amp;x&lt;<span class="number">0</span>)&#123;</div><div class="line">                    touchAngle += <span class="number">180</span>;</div><div class="line">                &#125;</div><div class="line">                touchAngle +=Math.toDegrees(Math.atan(y/x));</div><div class="line">                touchAngle = touchAngle-mStartAngle;</div><div class="line">                <span class="keyword">if</span> (touchAngle&lt;<span class="number">0</span>)&#123;</div><div class="line">                    touchAngle = touchAngle+<span class="number">360</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">float</span> touchRadius = (<span class="keyword">float</span>) Math.sqrt(y*y+x*x);</div><div class="line">                <span class="keyword">if</span> (rTra&lt; touchRadius &amp;&amp; touchRadius&lt; r)&#123;</div><div class="line">                    angleId = -Arrays.binarySearch(pieAngles,(touchAngle))-<span class="number">1</span>;</div><div class="line">                    invalidate();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                angleId = -<span class="number">1</span>;</div><div class="line">                invalidate();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>运行之前需要判断PieChart是否开启了点击效果，同时需要判断数据不为空。<br></li>
<li>在用户点击下的时候，获取当前的坐标，计算出这个点与原点的距离以及角度。通过距离可以判断出是否点击在了扇形区域上，而通过角度可以判断出点击了哪一个区域。将判断出的区域Id传递给angleId值，就像我们之前在onDraw中说的那样，重新绘制，根据angleId浮出指定的扇形区域。<br></li>
<li>用户手指离开屏幕时，重置angleId为默认值，并使用invalidate()函数，重新绘制onDraw中变化的部分。<br><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/onTouchEvent.png" alt="onTouchEvent" title="onTouchEvent" width="300"><br></li>
</ul>
<h2 id="八、小结"><a href="#八、小结" class="headerlink" title="八、小结"></a>八、小结</h2><p>经过之前4篇的知识准备，终于迎来了本章的PieChart的具体实现。在本文中重温了之前的绘制流程的各个函数，VlaueAnimator函数，以及Canvas、Path的使用方法，并使用这些方法完成了一个自定义饼图的绘制。在之后的文章中还会进行几个图表的实战，比如下面这个曲线图。<br></p>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/cubic.gif" alt="曲线图" title="曲线图" width="300"><br><br>如果在阅读过程中，有任何疑问与问题，欢迎与我联系。<br><br><strong>博客:www.idtkm.com</strong><br><br><strong>GitHub:<a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><br><strong>微博:<a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><br><strong>邮箱:IdtkMa@gmail.com</strong><br><br><br><br><a href="https://github.com/Idtk/PieChart" target="_blank" rel="external">PieChart源码</a>请点击</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ompb0h8qq.bkt.clouddn.com/all/PieChart.gif&quot; alt=&quot;PieChat&quot; title=&quot;PieChat&quot; width=&quot;300&quot; /&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;(&lt;strong&gt;PS: 经过之前&lt;a href=&quot;http://www.idtkm.com/category/customview/&quot;&gt;4篇博客&lt;/a&gt;的基础知识学习，终于可以开始编写PieChart了 ~(≧▽≦)/~啦啦啦&lt;/strong&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="CustomView" scheme="http://www.idtkm.com/tags/CustomView/"/>
    
  </entry>
  
  <entry>
    <title>Path图形与逻辑运算</title>
    <link href="http://www.idtkm.com/2016/06/01/4%E3%80%81PathFigureAndLogical/"/>
    <id>http://www.idtkm.com/2016/06/01/4、PathFigureAndLogical/</id>
    <published>2016-05-31T16:00:00.000Z</published>
    <updated>2017-10-15T16:02:17.878Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Idtk/Blog" target="_blank" rel="external">自定义View系列目录</a></p>
<h2 id="涉及知识"><a href="#涉及知识" class="headerlink" title="涉及知识"></a>涉及知识<br></h2><p><strong>Path</strong><br></p>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:center">API</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>添加路径</td>
<td style="text-align:center">addArc, addCircle, addOval, addPath, addRect, addRoundRect, arcTo</td>
<td>依次为添加圆弧、圆、椭圆、路径、矩形、圆角矩形、圆弧</td>
</tr>
<tr>
<td>移动起点</td>
<td style="text-align:center">moveTo</td>
<td>移动起点位置，仅对之后路径产生影响</td>
</tr>
<tr>
<td>移动终点</td>
<td style="text-align:center">setLastPoint</td>
<td>移动上一次的终点位置，对前后的路径都会产生影响</td>
</tr>
<tr>
<td>直线</td>
<td style="text-align:center">lineTo</td>
<td>增加一条道指定点的直线</td>
</tr>
<tr>
<td>贝塞尔</td>
<td style="text-align:center">quadTo, cubicTo</td>
<td>二阶、三阶贝塞尔曲线</td>
</tr>
<tr>
<td>闭合路径</td>
<td style="text-align:center">close</td>
<td>路径终点连接到起点</td>
</tr>
<tr>
<td>逻辑运算</td>
<td style="text-align:center">op</td>
<td>A\B(DIFFERENCE), A∩B(INTERSECT), B\A(REVERSE_DIFFERENCE), A∪B(UNION), A⊕B(XOR)</td>
</tr>
<tr>
<td>替换路径</td>
<td style="text-align:center">set</td>
<td>用新的路径替换当前路径</td>
</tr>
<tr>
<td>重置</td>
<td style="text-align:center">reset, rewind</td>
<td>清除path使它为空，清除path但保留内部的数据结构</td>
</tr>
<tr>
<td>计算边界</td>
<td style="text-align:center">computeBounds</td>
<td>计算路径的矩形边界</td>
</tr>
<tr>
<td>闭合方向</td>
<td style="text-align:center">Direction</td>
<td>顺时针方向闭合Path(CW),逆时针方向闭合Path(CCW)</td>
</tr>
</tbody>
</table>
<p><br></p>
<p><strong>本来这章应该是PieChart的实战，可是我在编写的时候发现了一个设置背景图片的bug。作为一个强迫症(ಥ _ ಥ)，我只好引入了Path来解决这个bug，所以就有了这一篇内容。</strong></p>
<a id="more"></a>
<h2 id="一、什么是Path"><a href="#一、什么是Path" class="headerlink" title="一、什么是Path"></a>一、什么是Path</h2><p>官方描述:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Path class 封装了由直线、二次、三次贝塞尔曲线构成的多重曲线几何路径。它可以用canvas.drawPath(path,paint)方法绘图，填充和线都可以（根据paint的样式），或者它可以用于在绘图路径上裁剪或者绘出文本。<br><br></p>
<p>我的理解:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Path由任意多条直线、二次贝塞尔或三次贝塞尔曲线组成,可以选择填充或者描边模式，可以使用它裁剪画布或者绘制文字。</p>
<h2 id="二、添加路径"><a href="#二、添加路径" class="headerlink" title="二、添加路径"></a>二、添加路径</h2><h3 id="1、lineTo-moveTo"><a href="#1、lineTo-moveTo" class="headerlink" title="1、lineTo,moveTo"></a>1、lineTo,moveTo</h3><p>在之前的文章中，使用canvas的函数绘制过<a href="http://www.idtkm.com/customview/customview2/">坐标系</a>，这次使用path来绘制。<br></p>
<h4 id="a、创建画笔"><a href="#a、创建画笔" class="headerlink" title="a、创建画笔"></a>a、创建画笔</h4><p>创建画笔并初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建画笔</span></div><div class="line"><span class="keyword">private</span> Paint mPaint = <span class="keyword">new</span> Paint();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPaint</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//初始化画笔</span></div><div class="line">    mPaint.setStyle(Paint.Style.FILL);<span class="comment">//设置画笔类型</span></div><div class="line">    mPaint.setAntiAlias(<span class="keyword">true</span>);<span class="comment">//抗锯齿</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="b、绘制坐标轴"><a href="#b、绘制坐标轴" class="headerlink" title="b、绘制坐标轴"></a>b、绘制坐标轴</h4><p>使用onSizeChanged方法，获取根据父布局等因素确认的View宽高<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//宽高</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mWidth;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mHeight;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</div><div class="line">    mWidth = w;</div><div class="line">    mHeight = h;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>把原点从左上角移动到画布中心,绘制原点与四个端点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Path mPath = <span class="keyword">new</span> Path();</div><div class="line"></div><div class="line">canvas.translate(mWidth/<span class="number">2</span>,mHeight/<span class="number">2</span>);<span class="comment">// 将画布坐标原点移动到中心位置</span></div><div class="line"><span class="comment">//绘制坐标原点</span></div><div class="line">mPaint.setColor(Color.BLACK);<span class="comment">//设置画笔颜色</span></div><div class="line">mPaint.setStrokeWidth(<span class="number">10</span>);<span class="comment">//为了看得清楚,设置了较大的画笔宽度</span></div><div class="line">canvas.drawPoint(<span class="number">0</span>,<span class="number">0</span>,mPaint);</div><div class="line"><span class="comment">//绘制坐标轴4个断点</span></div><div class="line">canvas.drawPoints(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</div><div class="line">        mWidth/<span class="number">2</span>*<span class="number">0.8f</span>,<span class="number">0</span></div><div class="line">        ,<span class="number">0</span>,mHeight/<span class="number">2</span>*<span class="number">0.8f</span></div><div class="line">        ,-mWidth/<span class="number">2</span>*<span class="number">0.8f</span>,<span class="number">0</span></div><div class="line">        ,<span class="number">0</span>,-mHeight/<span class="number">2</span>*<span class="number">0.8f</span>&#125;,mPaint);</div></pre></td></tr></table></figure></p>
<p>增加坐标轴与箭头的Path，在完成后使用<strong>canvas.drawPath</strong>一次进行绘制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">mPaint.setStrokeWidth(<span class="number">1</span>);<span class="comment">//恢复画笔默认宽度</span></div><div class="line"><span class="comment">//x轴</span></div><div class="line">mPath.moveTo(-mWidth/<span class="number">2</span>*<span class="number">0.8f</span>,<span class="number">0</span>);<span class="comment">//移动path起点到(-mWidth/2*0.8f,0)</span></div><div class="line">mPath.lineTo(mWidth/<span class="number">2</span>*<span class="number">0.8f</span>,<span class="number">0</span>);<span class="comment">//直线终点为(mWidth/2*0.8f,0)</span></div><div class="line"><span class="comment">//y轴</span></div><div class="line">mPath.moveTo(<span class="number">0</span>,-mHeight/<span class="number">2</span>*<span class="number">0.8f</span>);<span class="comment">//移动path起点到(0,-mHeight/2*0.8f)</span></div><div class="line">mPath.lineTo(<span class="number">0</span>,mHeight/<span class="number">2</span>*<span class="number">0.8f</span>);<span class="comment">//直线终点为(0,mHeight/2*0.8f)</span></div><div class="line"><span class="comment">//x箭头</span></div><div class="line">mPath.moveTo(mWidth/<span class="number">2</span>*<span class="number">0.8f</span>*<span class="number">0.95f</span>,-mWidth/<span class="number">2</span>*<span class="number">0.8f</span>*<span class="number">0.05f</span>);</div><div class="line">mPath.lineTo(mWidth/<span class="number">2</span>*<span class="number">0.8f</span>,<span class="number">0</span>);</div><div class="line">mPath.lineTo(mWidth/<span class="number">2</span>*<span class="number">0.8f</span>*<span class="number">0.95f</span>,mWidth/<span class="number">2</span>*<span class="number">0.8f</span>*<span class="number">0.05f</span>);</div><div class="line"><span class="comment">//y箭头</span></div><div class="line">mPath.moveTo(mWidth/<span class="number">2</span>*<span class="number">0.8f</span>*<span class="number">0.05f</span>,mHeight/<span class="number">2</span>*<span class="number">0.8f</span>-mWidth/<span class="number">2</span>*<span class="number">0.8f</span>*<span class="number">0.05f</span>);</div><div class="line">mPath.lineTo(<span class="number">0</span>,mHeight/<span class="number">2</span>*<span class="number">0.8f</span>);</div><div class="line">mPath.lineTo(-mWidth/<span class="number">2</span>*<span class="number">0.8f</span>*<span class="number">0.05f</span>,mHeight/<span class="number">2</span>*<span class="number">0.8f</span>-mWidth/<span class="number">2</span>*<span class="number">0.8f</span>*<span class="number">0.05f</span>);</div><div class="line"><span class="comment">//绘制Path</span></div><div class="line">canvas.drawPath(mPath,mPaint);</div></pre></td></tr></table></figure></p>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/%E5%9D%90%E6%A0%87%E7%B3%BB2.png" alt="坐标系" title="坐标系" width="300"><br><br><br>可以看出moveTo方法，可以移动下一次增加path的起点，而lineTo中的参数，即为直线的终点。</p>
<h3 id="2、addArc与arcTo"><a href="#2、addArc与arcTo" class="headerlink" title="2、addArc与arcTo"></a>2、addArc与arcTo</h3><table>
<thead>
<tr>
<th>方法</th>
<th>区别</th>
</tr>
</thead>
<tbody>
<tr>
<td>addArc</td>
<td>画一段圆弧</td>
</tr>
<tr>
<td>arcTo</td>
<td>画一段圆弧，当上一次的终点与圆弧起点未连接时，可以设置是否连接这两点</td>
</tr>
</tbody>
</table>
<p>addArc<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">r = Math.min(mWidth,mHeight)*<span class="number">0.6f</span>/<span class="number">2</span>;</div><div class="line">mRectF.left = <span class="number">0</span>;</div><div class="line">mRectF.top = -r;</div><div class="line">mRectF.right = r;</div><div class="line">mRectF.bottom = <span class="number">0</span>;</div><div class="line">mPath.addArc(mRectF,-<span class="number">60</span>,<span class="number">180</span>);</div><div class="line"><span class="comment">//绘制Path</span></div><div class="line">canvas.drawPath(mPath,mPaint);</div></pre></td></tr></table></figure></p>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/addarc.png" alt="addArc" title="addArc" width="300"><br><br><br>再来看看arcTo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//arcTo</span></div><div class="line">mPath.moveTo(<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">mPath.arcTo(mRectF,-<span class="number">60</span>,<span class="number">180</span>);</div><div class="line"><span class="comment">//绘制Path</span></div><div class="line">canvas.drawPath(mPath,mPaint);</div></pre></td></tr></table></figure></p>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/arcto.png" alt="arcTo" title="arcTo" width="300"><br><br><br>可以看到arcTo多了<strong>一条从原点到圆弧起点的直线</strong>，而如果设置为mPath.arcTo(mRectF,-60,180,false);效果将和addArc相同。<br><br></p>
<h2 id="三、圆角图片以及更多形状图片"><a href="#三、圆角图片以及更多形状图片" class="headerlink" title="三、圆角图片以及更多形状图片"></a>三、圆角图片以及更多形状图片</h2><p>继承<strong>ImageView</strong>,重写父类的<strong>onSizeChanged</strong>方法，获取View尺寸，之后根据View大小对图片进行压缩。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</div><div class="line">    mViewWidth = w;</div><div class="line">    mViewHeight = h;</div><div class="line">    size();<span class="comment">//切割尺寸计算</span></div><div class="line">    scaleBitmap();<span class="comment">//压缩图片尺寸函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<strong>onDraw</strong>方法中进行样式绘制，在其中使用<strong>clipPath</strong>的方法来实现圆角图片。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    canvas.translate(mViewWidth/<span class="number">2</span>,mViewHeight/<span class="number">2</span>);<span class="comment">//将画布坐标原点移动到中心位置</span></div><div class="line">    canvas.clipPath(pathFigure(), Region.Op.INTERSECT);<span class="comment">//切割</span></div><div class="line">    mPath.reset();</div><div class="line">    canvas.drawBitmap(b,rect,rect,mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<strong>scaleBitmap</strong>方法中对图片的尺寸进行压缩<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scaleBitmap</span><span class="params">()</span></span>&#123;</div><div class="line">    Drawable drawable = getDrawable();<span class="comment">//获取图片</span></div><div class="line">    <span class="keyword">if</span> (drawable == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (getWidth() == <span class="number">0</span> || getHeight() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!(drawable <span class="keyword">instanceof</span> BitmapDrawable)) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    b = ((BitmapDrawable) drawable).getBitmap();<span class="comment">//获取bitmap</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == b) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">float</span> scaleWidth = (<span class="keyword">float</span>) length/b.getWidth();</div><div class="line">    <span class="keyword">float</span> scaleHeight = (<span class="keyword">float</span>) length/b.getHeight();</div><div class="line">    matrix.postScale(scaleWidth,scaleHeight);<span class="comment">//缩放矩阵</span></div><div class="line">    b=Bitmap.createBitmap(b,<span class="number">0</span>,<span class="number">0</span>,b.getWidth(),b.getHeight(),matrix,<span class="keyword">true</span>);<span class="comment">//压缩图片</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<strong>size</strong>方法中设置canvas的切割尺寸<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">size</span><span class="params">()</span></span>&#123;</div><div class="line">    length = Math.min(mViewWidth,mViewHeight)/<span class="number">2</span>;</div><div class="line">    rect = <span class="keyword">new</span> Rect(-(<span class="keyword">int</span>) length, -(<span class="keyword">int</span>) length, (<span class="keyword">int</span>) length, (<span class="keyword">int</span>) length);<span class="comment">//绘制图片矩阵</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>现在就是发挥想象力的时候啦♪(^∇^*)，来编写pathFigure()方法吧</strong><br></p>
<h4 id="a、先编写一个简单的圆形图片样式"><a href="#a、先编写一个简单的圆形图片样式" class="headerlink" title="a、先编写一个简单的圆形图片样式"></a>a、先编写一个简单的圆形图片样式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Path <span class="title">pathFigure</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">switch</span> (modeFlag)&#123;</div><div class="line">        <span class="keyword">case</span> CIRCLE:</div><div class="line">            mPath.addCircle(<span class="number">0</span>,<span class="number">0</span>,length, Path.Direction.CW);<span class="comment">//增加圆的path，顺时针闭合圆</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> mPath;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/%E5%9C%86%E5%BD%A2.png" alt="圆形" title="圆形" width="300"></p>
<h4 id="b、增加一个圆角图片样式"><a href="#b、增加一个圆角图片样式" class="headerlink" title="b、增加一个圆角图片样式"></a>b、增加一个圆角图片样式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> RectF rectF = <span class="keyword">new</span> RectF();</div><div class="line"></div><div class="line"><span class="keyword">case</span> ROUNDRECT:</div><div class="line">            rectF.left = -length;</div><div class="line">            rectF.top = -length;</div><div class="line">            rectF.right = length;</div><div class="line">            rectF.bottom = length;</div><div class="line">            <span class="comment">//圆角矩形，radius为圆角的半径，顺时针闭合圆角矩形</span></div><div class="line">            mPath.addRoundRect(rectF,radius,radius, Path.Direction.CW);</div><div class="line">            <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/%E5%9C%86%E8%A7%92.png" alt="圆角" title="圆角" width="300"></p>
<h4 id="c、再增加一个扇形样式"><a href="#c、再增加一个扇形样式" class="headerlink" title="c、再增加一个扇形样式"></a>c、再增加一个扇形样式<br></h4><p>(<strong>PS:为了可以获得更多的图片面积，需要把圆心下移一个length的距离，半径扩大到之前的两倍</strong>)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> SECTOR:</div><div class="line">    rectF.left = -length*<span class="number">2</span>;</div><div class="line">    rectF.top = -length;</div><div class="line">    rectF.right = length*<span class="number">2</span>;</div><div class="line">    rectF.bottom = length*<span class="number">3</span>;</div><div class="line">    mPath.moveTo(<span class="number">0</span>,length);</div><div class="line">    mPath.arcTo(rectF,angle,-angle*<span class="number">2</span>-<span class="number">180</span>);<span class="comment">//绘制圆弧</span></div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/%E5%9C%86%E8%A7%922.png" alt="扇形" title="扇形" width="300"></p>
<h2 id="四、逻辑运算"><a href="#四、逻辑运算" class="headerlink" title="四、逻辑运算"></a>四、逻辑运算</h2><p>两条Path可通过多种逻辑运算进行结合，形成新的Path。<br><br><br><br>API如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">op(Path path, Path.Op op)</div><div class="line">op(Path path1, Path path2, Path.Op op)</div></pre></td></tr></table></figure></p>
<p>逻辑运算具有五种类型:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>示意图</th>
</tr>
</thead>
<tbody>
<tr>
<td>DIFFERENCE</td>
<td>B在A中的相对补集，即A减去A与B的交集</td>
<td><img src="http://ompb0h8qq.bkt.clouddn.com/old/%E8%A1%A5%E9%9B%861.png" alt="DIFFERENCE" width="100"></td>
</tr>
<tr>
<td>REVERSE_DIFFERENCE</td>
<td>A在B中的相对补集合，即B减去B与A的交集</td>
<td><img src="http://ompb0h8qq.bkt.clouddn.com/old/%E8%A1%A5%E9%9B%862.png" alt="REVERSE_DIFFERENCE" width="100"></td>
</tr>
<tr>
<td>INTERSECT</td>
<td>A与B的交集</td>
<td><img src="http://ompb0h8qq.bkt.clouddn.com/old/%E4%BA%A4%E9%9B%86.png" alt="INTERSECT" width="100"></td>
</tr>
<tr>
<td>UNION</td>
<td>A与B的合集</td>
<td><img src="http://ompb0h8qq.bkt.clouddn.com/old/%E5%90%88%E9%9B%86.png" alt="UNION" width="100"></td>
</tr>
<tr>
<td>XOR</td>
<td>A与B的合集减去A与B的交集</td>
<td><img src="http://ompb0h8qq.bkt.clouddn.com/old/%E5%BC%82%E6%88%96.png" alt="XOR" width="100"></td>
</tr>
</tbody>
</table>
<p>使用Path.op方法再给圆角图片类，增加一种环形样式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> RING:</div><div class="line">    rectF.left = -length*<span class="number">2</span>;</div><div class="line">    rectF.top = -length;</div><div class="line">    rectF.right = length*<span class="number">2</span>;</div><div class="line">    rectF.bottom = length*<span class="number">3</span>;</div><div class="line">    mPath1.moveTo(<span class="number">0</span>,length);</div><div class="line">    mPath1.arcTo(rectF,angle,-angle*<span class="number">2</span>-<span class="number">180</span>);<span class="comment">//较大的圆弧</span></div><div class="line"></div><div class="line">    rectF.left = -length/<span class="number">2</span>;</div><div class="line">    rectF.top = length/<span class="number">2</span>;</div><div class="line">    rectF.right = length/<span class="number">2</span>;</div><div class="line">    rectF.bottom = length*<span class="number">3</span>/<span class="number">2</span>;</div><div class="line">    mPath2.moveTo(<span class="number">0</span>,length);</div><div class="line">    mPath2.arcTo(rectF,angle,-angle*<span class="number">2</span>-<span class="number">180</span>);<span class="comment">//较小的圆弧</span></div><div class="line"></div><div class="line">    mPath.op(mPath1,mPath2, Path.Op.XOR);<span class="comment">//异或获取环形</span></div></pre></td></tr></table></figure></p>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/%E5%9C%86%E8%A7%923.png" alt="圆环" title="圆环" width="300"></p>
<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>本文介绍了Path的基本使用方法与逻辑运算，同时通过圆角图片的例子，进行了实战。使用Path方法，还可以增加更多有趣的图形，比如star，多边形，格子图等等。如果在阅读过程中，有任何疑问与问题，欢迎与我联系。<br><br><strong>博客:www.idtkm.com</strong><br><br><strong>GitHub:<a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><br><strong>微博:<a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><br><strong>邮箱:IdtkMa@gmail.com</strong><br><br><br><br><strong>PS: 示例中使用的方法，相对消耗内存，更合适的是设置反向填充来完成圆角图片的生成，FigureImageView为反向填充的方法，OldFigureImageView为示例中的方法 <a href="https://github.com/Idtk/FigureImageView" target="_blank" rel="external">源码</a></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Idtk/Blog&quot;&gt;自定义View系列目录&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;涉及知识&quot;&gt;&lt;a href=&quot;#涉及知识&quot; class=&quot;headerlink&quot; title=&quot;涉及知识&quot;&gt;&lt;/a&gt;涉及知识&lt;br&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Path&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;API&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;添加路径&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;addArc, addCircle, addOval, addPath, addRect, addRoundRect, arcTo&lt;/td&gt;
&lt;td&gt;依次为添加圆弧、圆、椭圆、路径、矩形、圆角矩形、圆弧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;移动起点&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;moveTo&lt;/td&gt;
&lt;td&gt;移动起点位置，仅对之后路径产生影响&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;移动终点&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;setLastPoint&lt;/td&gt;
&lt;td&gt;移动上一次的终点位置，对前后的路径都会产生影响&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;直线&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;lineTo&lt;/td&gt;
&lt;td&gt;增加一条道指定点的直线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;贝塞尔&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;quadTo, cubicTo&lt;/td&gt;
&lt;td&gt;二阶、三阶贝塞尔曲线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;闭合路径&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;close&lt;/td&gt;
&lt;td&gt;路径终点连接到起点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;逻辑运算&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;op&lt;/td&gt;
&lt;td&gt;A\B(DIFFERENCE), A∩B(INTERSECT), B\A(REVERSE_DIFFERENCE), A∪B(UNION), A⊕B(XOR)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;替换路径&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;set&lt;/td&gt;
&lt;td&gt;用新的路径替换当前路径&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;重置&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;reset, rewind&lt;/td&gt;
&lt;td&gt;清除path使它为空，清除path但保留内部的数据结构&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;计算边界&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;computeBounds&lt;/td&gt;
&lt;td&gt;计算路径的矩形边界&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;闭合方向&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Direction&lt;/td&gt;
&lt;td&gt;顺时针方向闭合Path(CW),逆时针方向闭合Path(CCW)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本来这章应该是PieChart的实战，可是我在编写的时候发现了一个设置背景图片的bug。作为一个强迫症(ಥ _ ಥ)，我只好引入了Path来解决这个bug，所以就有了这一篇内容。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="CustomView" scheme="http://www.idtkm.com/tags/CustomView/"/>
    
  </entry>
  
  <entry>
    <title>View多行文本居中</title>
    <link href="http://www.idtkm.com/2016/05/21/3%E3%80%81Multi-lineTextCenter/"/>
    <id>http://www.idtkm.com/2016/05/21/3、Multi-lineTextCenter/</id>
    <published>2016-05-20T16:00:00.000Z</published>
    <updated>2017-10-15T16:02:24.491Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Idtk/Blog" target="_blank" rel="external">自定义View系列目录</a></p>
<h2 id="涉及知识"><a href="#涉及知识" class="headerlink" title="涉及知识"></a>涉及知识<br></h2><p><strong>绘制过程</strong><br></p>
<table>
<thead>
<tr>
<th>类别</th>
<th style="text-align:center">API</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>布局</td>
<td style="text-align:center">onMeasure</td>
<td>测量View与Child View的大小</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">onLayout</td>
<td>确定Child View的位置</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">onSizeChanged</td>
<td>确定View的大小</td>
</tr>
<tr>
<td>绘制</td>
<td style="text-align:center">onDraw</td>
<td>实际绘制View的内容</td>
</tr>
<tr>
<td>事件处理</td>
<td style="text-align:center">onTouchEvent</td>
<td>处理屏幕触摸事件</td>
</tr>
<tr>
<td>重绘</td>
<td style="text-align:center">invalidate</td>
<td>调用onDraw方法，重绘View中变化的部分</td>
</tr>
</tbody>
</table>
<p><br></p>
<a id="more"></a>
<p><strong>Canvas涉及方法</strong><br></p>
<table>
<thead>
<tr>
<th>类别</th>
<th style="text-align:center">API</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>绘制图形</td>
<td style="text-align:center">drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc</td>
<td>依次为绘制点、直线、矩形、圆角矩形、椭圆、圆、扇形</td>
</tr>
<tr>
<td>绘制文本</td>
<td style="text-align:center">drawText, drawPosText, drawTextOnPath</td>
<td>依次为绘制文字、指定每个字符位置绘制文字、根据路径绘制文字</td>
</tr>
<tr>
<td>画布变换</td>
<td style="text-align:center">translate, scale, rotate, skew</td>
<td>依次为平移、缩放、旋转、倾斜（错切）</td>
</tr>
<tr>
<td>画布裁剪</td>
<td style="text-align:center">clipPath, clipRect, clipRegion</td>
<td>依次为按路径、按矩形、按区域对画布进行裁剪</td>
</tr>
<tr>
<td>画布状态</td>
<td style="text-align:center">sava,restore</td>
<td>保存当前画布矩阵，恢复之前保存的画布</td>
</tr>
</tbody>
</table>
<p><br><br><strong>Paint涉及方法</strong><br></p>
<table>
<thead>
<tr>
<th>类别</th>
<th style="text-align:center">API</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>颜色</td>
<td style="text-align:center">setColor, setARGB, setAlpha</td>
<td>依次为设置画笔颜色、透明度</td>
</tr>
<tr>
<td>类型</td>
<td style="text-align:center">setStyle</td>
<td>填充(FILL),描边(STROKE),填充加描边(FILL_AND_STROKE)</td>
</tr>
<tr>
<td>抗锯齿</td>
<td style="text-align:center">setAntiAlias</td>
<td>画笔是否抗锯齿</td>
</tr>
<tr>
<td>字体大小</td>
<td style="text-align:center">setTextSize</td>
<td>设置字体大小</td>
</tr>
<tr>
<td>字体测量</td>
<td style="text-align:center">getFontMetrics()，getFontMetricsInt()</td>
<td>返回字体的各种测量值，返回值依次为float、int</td>
</tr>
<tr>
<td>文字宽度测量</td>
<td style="text-align:center">measureText</td>
<td>返回文字的宽度</td>
</tr>
<tr>
<td>文字对齐方式</td>
<td style="text-align:center">setTextAlign</td>
<td>左对齐(LEFT),居中对齐(CENTER),右对齐(RIGHT)</td>
</tr>
<tr>
<td>宽度</td>
<td style="text-align:center">setStrokeWidth</td>
<td>设置画笔宽度</td>
</tr>
<tr>
<td>笔锋</td>
<td style="text-align:center">setStrokeCap</td>
<td>默认(BUTT),半圆形(ROUND),方形(SQUARE)</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>（<strong>PS: 因API较多，只列出了涉及的方法，想了解更多，请查看<a href="http://developer.android.com/reference/packages.html" target="_blank" rel="external">官方文档</a></strong>)<br></p>
<h2 id="一、绘制文本"><a href="#一、绘制文本" class="headerlink" title="一、绘制文本"></a>一、绘制文本</h2><p>在Canvas中绘制文本，使用在<a href="http://www.idtkm.com/customview/customview2/">上一篇</a>绘制的坐标系</p>
<h3 id="1、drawText"><a href="#1、drawText" class="headerlink" title="1、drawText"></a>1、drawText</h3><p>drawText的几种方法如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span> <span class="params">(String text, <span class="keyword">float</span> x, <span class="keyword">float</span> y, Paint paint)</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span> <span class="params">(String text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">float</span> x, <span class="keyword">float</span> y, Paint paint)</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span> <span class="params">(CharSequence text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">float</span> x, <span class="keyword">float</span> y, Paint paint)</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span> <span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> index, <span class="keyword">int</span> count, <span class="keyword">float</span> x, <span class="keyword">float</span> y, Paint paint)</span></div></pre></td></tr></table></figure></p>
<p>x、y值表示绘制文本左下角的坐标<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Paint mPaint = <span class="keyword">new</span> Paint();</div><div class="line">mPaint.setAntiAlias(<span class="keyword">true</span>);<span class="comment">//抗锯齿</span></div><div class="line">mPaint.setColor(Color.BLUE);<span class="comment">//设置画笔颜色</span></div><div class="line">mPaint.setTextSize(<span class="number">50</span>);</div><div class="line">String string = <span class="string">"Idtk"</span>;</div><div class="line">canvas.drawText(string,<span class="number">0</span>,<span class="number">0</span>,mPaint);</div></pre></td></tr></table></figure></p>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/drawText1.png" alt="drawText1" title="drawText1" width="300"><br><br><br>或者只绘制其中的一部分字符<br><br>start表示从第几个字符开始，end表示到第几个字符之前结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">canvas.drawText(string,<span class="number">1</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,mPaint);<span class="comment">//截取第一到第四个字符</span></div></pre></td></tr></table></figure>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/drawText2.png" alt="drawText2" title="drawText2" width="300"><br><br><br>可以使用CharSequence绘制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CharSequence charSequence = <span class="string">"charSequence"</span>;</div><div class="line">canvas.drawText(charSequence,<span class="number">5</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">0</span>,mPaint);</div></pre></td></tr></table></figure>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/drawText3.png" alt="drawText3" title="drawText3" width="300"></p>
<p>或者使用字符数组，index表示从第几个字符开始，count表示截取的数组长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>[] chars = <span class="string">"chars"</span>.toCharArray();</div><div class="line">canvas.drawText(chars,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,mPaint);</div></pre></td></tr></table></figure>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/drawText4.png" alt="drawText4" title="drawText4" width="300"></p>
<h3 id="2、drawPosText"><a href="#2、drawPosText" class="headerlink" title="2、drawPosText"></a>2、drawPosText</h3><p>给文本中的每个字符都设定一个坐标，但是已经不推荐使用。</p>
<h3 id="3、drawTextOnPath"><a href="#3、drawTextOnPath" class="headerlink" title="3、drawTextOnPath"></a>3、drawTextOnPath</h3><p>根据path绘制文本，不过path是一个比较重要且有趣的东西，在之后绘制折线图或者曲线图之前的涉及知识中会进行分析。drawTextOnPath的几种方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTextOnPath</span> <span class="params">(String text, Path path, <span class="keyword">float</span> hOffset, <span class="keyword">float</span> vOffset, Paint paint)</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTextOnPath</span> <span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> index, <span class="keyword">int</span> count, Path path, <span class="keyword">float</span> hOffset, <span class="keyword">float</span> vOffset, Paint paint)</span></div></pre></td></tr></table></figure></p>
<p>这里简单写一个，path为一条从原点到(0,200)的直线，水平偏移量、垂直偏移量都设置为100，注意偏移量设置时不要过大，一面影响字符串的正常显示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Path path = <span class="keyword">new</span> Path();</div><div class="line">path.lineTo(<span class="number">0</span>,<span class="number">200</span>);</div><div class="line">canvas.drawTextOnPath(string,path,<span class="number">100</span>,<span class="number">100</span>,mPaint);</div></pre></td></tr></table></figure></p>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/path.png" alt="drawTextOnPath" title="drawTextOnPath" width="300"></p>
<p>另一种方法，和上面drawText中使用字符数组的方法，同理。</p>
<h2 id="二、文本居中"><a href="#二、文本居中" class="headerlink" title="二、文本居中"></a>二、文本居中</h2><h3 id="1、单行文本居中"><a href="#1、单行文本居中" class="headerlink" title="1、单行文本居中"></a>1、单行文本居中</h3><h4 id="a、getFontMetrics-，getFontMetricsInt"><a href="#a、getFontMetrics-，getFontMetricsInt" class="headerlink" title="a、getFontMetrics()，getFontMetricsInt()"></a>a、getFontMetrics()，getFontMetricsInt()</h4><p>getFontMetrics()，getFontMetricsInt()用于返回字符串的测量，而两个方法的区别就是返回值得类型。返回值一共有五个属性:</p>
<ul>
<li>Top : baseline到文本顶部的最大的距离</li>
<li>Ascent : baseline到文本顶部的推荐距离</li>
<li>Descent : baseline到文本底部的推荐距离</li>
<li>Bottom : baseline到文本底部的最大距离</li>
<li>Leading : 两行文本之间推荐的额外距离，一般为0</li>
</ul>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/String%20Center.png" alt="center" title="center"></p>
<p><br><br>在Android的坐标系之中，向下为Y轴正方向，向上位Y轴负方向，所以baseline之上的Top与Ascent都是负数，而baselin之下的Descent、Bottom都是正数。如果要让字符串在垂直方向上居中，则需要在纵坐标上增加Asecent绝对值与descent的差。<br><br><br>leading值是一行文本的底部与下一行文本的顶部之间的距离，图中就是line1的橙色线条与line2的紫色线条之间测距离，一般情况下是0。根据<a href="http://stackoverflow.com/questions/27631736" target="_blank" rel="external">stackoverflow</a>中的说法，是一行的bottom与下一行的top已经为字符串提供了足够的空间，所以leading的值在一般情况下都为0。需要注意的是，在获取FontMetrics之前请完成Paint的设置，这样才能准确的获取测量值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mPaint.setTextSize(<span class="number">50</span>);</div><div class="line">String string = <span class="string">"Idtk"</span>;</div><div class="line">Paint.FontMetrics fontMetrics= mPaint.getFontMetrics();</div><div class="line"><span class="keyword">float</span> textHeight = (-fontMetrics.ascent-fontMetrics.descent)/<span class="number">2</span>;</div><div class="line">canvas.drawText(string,<span class="number">0</span>,textHeight,mPaint);</div></pre></td></tr></table></figure>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/center1.png" alt="center" title="center" width="300"></p>
<h4 id="b、setTextAlign"><a href="#b、setTextAlign" class="headerlink" title="b、setTextAlign"></a>b、setTextAlign</h4><p>setTextAlign可以设置画笔绘制文本的对齐方式，选择center即可完成文本的水平居中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mPaint.setTextAlign(Paint.Align.CENTER);</div></pre></td></tr></table></figure></p>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/center2.png" alt="center" title="center" width="300"></p>
<h4 id="c、measureText"><a href="#c、measureText" class="headerlink" title="c、measureText"></a>c、measureText</h4><p>measureText可以测量文本的宽度，即横向长度，这样也可以来完成居中设置，但在这之前，需要恢复文本对齐方式至默认设置(居左)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">float</span> textWidth = mPaint.measureText(string);</div><div class="line">canvas.drawText(string,-textWidth/<span class="number">2</span>,textHeight,mPaint);</div></pre></td></tr></table></figure></p>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/center3.png" alt="center" title="center" width="300"><br><br><br>我们可以看出结果与之前相同。</p>
<h3 id="2、多行文本居中"><a href="#2、多行文本居中" class="headerlink" title="2、多行文本居中"></a>2、多行文本居中</h3><p>这是整片博客来说最有趣的地方，我们如何让一个多行字符串居中呢？<br><br><br>假设有设定好的字符串数组，画笔，画布，坐标点<br><br></p>
<ul>
<li>1、drawText每次只能绘制一行，所以我们有个for循环</li>
<li>2、更具上图，假设字符串数组大于1，每个字符串的高度应该为-top+bottom，总高度就为length*(-top+bottom);</li>
<li>3、偏移量就等于length*(-top+bottom)/2-bottom;</li>
<li>4、如果顺序向上(即Y负方向)排列的话，那么第i个字符串的高度就是-(length-i-1)*(-top+bottom);</li>
<li>5、每个字符串高度的减去偏移量，就应该是每个字符串的baseline的Y坐标<br><br><br>详细代码如下:<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">textCenter</span><span class="params">(String[] strings, Paint paint, Canvas canvas, Point point,Paint.Align align)</span></span>&#123;</div><div class="line">    mPaint.setTextAlign(align);</div><div class="line">    Paint.FontMetrics fontMetrics= mPaint.getFontMetrics();</div><div class="line">    <span class="keyword">float</span> top = fontMetrics.top;</div><div class="line">    <span class="keyword">float</span> bottom = fontMetrics.bottom;</div><div class="line">    <span class="keyword">int</span> length = strings.length;</div><div class="line">    <span class="keyword">float</span> total = (length-<span class="number">1</span>)*(-top+bottom)+(-fontMetrics.ascent+fontMetrics.descent);</div><div class="line">    <span class="keyword">float</span> offset = total/<span class="number">2</span>-bottom;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</div><div class="line">        <span class="keyword">float</span> yAxis = -(length-i-<span class="number">1</span>)*(-top+bottom)+offset;</div><div class="line">        canvas.drawText(strings[i],point.x,point.y+yAxis,mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>偏移量取值的变化，是因为在字符串的首尾两个字符串，需要把top改成ascent，bottom改成descent。通过设置画笔来完成横向的居中，居左，居右。<br><br><br>使用代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mPaint.setTextSize(<span class="number">50</span>);</div><div class="line">mPaint.setColor(Color.BLUE);</div><div class="line">String[] strings = <span class="keyword">new</span> String[]&#123;<span class="string">"Idtk"</span>,<span class="string">"是"</span>,<span class="string">"一"</span>,<span class="string">"个"</span>,<span class="string">"小"</span>,<span class="string">"学"</span>,<span class="string">"生"</span></div><div class="line">Point point = <span class="keyword">new</span> Point(<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">textCenter(strings,mPaint,canvas,point,Paint.Align.CENTER);</div></pre></td></tr></table></figure></p>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/Multi-line.png" alt="Multi-line" title="Multi-line" width="300"></p>
<h3 id="3、多列文本居右"><a href="#3、多列文本居右" class="headerlink" title="3、多列文本居右"></a>3、多列文本居右</h3><p>这个是模仿古文的书写方式<br></p>
<ul>
<li>1、一个字符串数组，分割正多个字符数组</li>
<li>2、每个字符数组中，获取最宽的字符宽度，为字符数组的字符宽度</li>
<li>3、计算数组x坐标，再调用之前的文本居中代码<br><br><br>我们先重载一个textcenter方法:<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">textCenter</span><span class="params">(<span class="keyword">char</span>[] chars, Paint paint, Canvas canvas, Point point,Paint.Align align)</span></span>&#123;</div><div class="line">    mPaint.setTextAlign(align);</div><div class="line">    Paint.FontMetrics fontMetrics= mPaint.getFontMetrics();</div><div class="line">    <span class="keyword">float</span> top = fontMetrics.top;</div><div class="line">    <span class="keyword">float</span> bottom = fontMetrics.bottom;</div><div class="line">    <span class="keyword">int</span> length = chars.length;</div><div class="line">    <span class="keyword">float</span> total = (length-<span class="number">1</span>)*(-top+bottom)+(-fontMetrics.ascent+fontMetrics.descent);</div><div class="line">    <span class="keyword">float</span> offset = total/<span class="number">2</span>-bottom;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</div><div class="line">        <span class="keyword">float</span> yAxis = -(length-i-<span class="number">1</span>)*(-top+bottom)+offset;</div><div class="line">        canvas.drawText(chars[i]+<span class="string">""</span>,point.x,point.y+yAxis,mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>接下来编写多列居左的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rowTextRigth</span><span class="params">(String[] strings, Paint paint, Canvas canvas, Point point)</span></span>&#123;</div><div class="line">    mPaint.setTextAlign(Paint.Align.RIGHT);</div><div class="line">    <span class="keyword">int</span> length = strings.length;</div><div class="line">    <span class="keyword">float</span> len,newLen;</div><div class="line">    <span class="keyword">float</span> total = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;length; j++)&#123;</div><div class="line">        <span class="keyword">char</span>[] chars=strings[j].toCharArray();</div><div class="line">        len = mPaint.measureText(chars[<span class="number">0</span>]+<span class="string">""</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;chars.length; i++)&#123;</div><div class="line">            newLen = mPaint.measureText(chars[i]+<span class="string">""</span>);</div><div class="line">            len = Math.max(newLen,len);</div><div class="line">        &#125;</div><div class="line">        point.x = point.x - (<span class="keyword">int</span>) total;</div><div class="line">        textCenter(chars,mPaint,canvas,point,Paint.Align.RIGHT);</div><div class="line">        point.x = point.x + (<span class="keyword">int</span>) total;</div><div class="line">        total = total+len;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用方法示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String[] strings2 = <span class="keyword">new</span> String[]&#123;<span class="string">"床前明月光，"</span>,<span class="string">"疑是地上霜。"</span>,<span class="string">"举头望明月，"</span>,<span class="string">"低头思故乡。"</span>&#125;;</div><div class="line">rowTextRigth(strings2,mPaint,canvas,point);</div></pre></td></tr></table></figure></p>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/row.png" alt="Multi-line" title="Multi-line" width="300"></p>
<h3 id="4、文本自动换行居中"><a href="#4、文本自动换行居中" class="headerlink" title="4、文本自动换行居中"></a>4、文本自动换行居中</h3><p>系统中有一个StaticLayout方法，可以在设置宽度，当前行文本超过此宽度后，进行自动换行，提供ALIGN_CENTER(居中)、ALIGN_NORMAL(标准)、ALIGN_OPPOSITE(与标准相反)三种对齐方式。<br><br>可以简单的封装成一个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">textCenter</span><span class="params">(String string, TextPaint textPaint, Canvas canvas, Point point, <span class="keyword">int</span> width,</span></span></div><div class="line">                        Layout.Alignment align, <span class="keyword">float</span> spacingmult, <span class="keyword">float</span> spacingadd, <span class="keyword">boolean</span> includepad)&#123;</div><div class="line">    StaticLayout staticLayout = <span class="keyword">new</span> StaticLayout(string,textPaint,width, align,spacingmult,spacingadd,includepad);</div><div class="line">    canvas.save();</div><div class="line">    canvas.translate(-staticLayout.getWidth()/<span class="number">2</span>+point.x,-staticLayout.getHeight()/<span class="number">2</span>+point.y);</div><div class="line">    staticLayout.draw(canvas);</div><div class="line">    canvas.restore();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用方法,这里设置宽度为150:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String mString = <span class="string">"Idtk是一个小学生"</span>;</div><div class="line">TextPaint tp = <span class="keyword">new</span> TextPaint();</div><div class="line">tp.setColor(Color.BLUE);</div><div class="line">tp.setStyle(Paint.Style.FILL);</div><div class="line">tp.setTextSize(<span class="number">50</span>);</div><div class="line">Point point = <span class="keyword">new</span> Point(<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">textCenter(mString,tp,canvas,point,<span class="number">150</span>,Layout.Alignment.ALIGN_CENTER,<span class="number">1.5f</span>,<span class="number">0</span>,<span class="keyword">false</span>);</div></pre></td></tr></table></figure></p>
<p><img src="http://ompb0h8qq.bkt.clouddn.com/old/Multi-line2.png" alt="Multi-line" title="Multi-line" width="300"></p>
<h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>本文介绍了如何在canvas中绘制文字，以及单行、多行文字居中，多列文本居右。在下一篇文章将会迎来一个阶段性的目标，进行<a href="https://github.com/Idtk/CustomView/blob/master/gif/PieChart.gif" target="_blank" rel="external">PieChart</a>的绘制。如果在阅读过程中，有任何疑问与问题，欢迎与我联系。<br><br><strong>博客:www.idtkm.com</strong><br><br><strong>GitHub:<a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><br><strong>微博:<a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><br><strong>邮箱:IdtkMa@gmail.com</strong><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Idtk/Blog&quot;&gt;自定义View系列目录&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;涉及知识&quot;&gt;&lt;a href=&quot;#涉及知识&quot; class=&quot;headerlink&quot; title=&quot;涉及知识&quot;&gt;&lt;/a&gt;涉及知识&lt;br&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;绘制过程&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;API&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;布局&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;onMeasure&lt;/td&gt;
&lt;td&gt;测量View与Child View的大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;onLayout&lt;/td&gt;
&lt;td&gt;确定Child View的位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;onSizeChanged&lt;/td&gt;
&lt;td&gt;确定View的大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;绘制&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;onDraw&lt;/td&gt;
&lt;td&gt;实际绘制View的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;事件处理&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;onTouchEvent&lt;/td&gt;
&lt;td&gt;处理屏幕触摸事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;重绘&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;invalidate&lt;/td&gt;
&lt;td&gt;调用onDraw方法，重绘View中变化的部分&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="CustomView" scheme="http://www.idtkm.com/tags/CustomView/"/>
    
  </entry>
  
  <entry>
    <title>Android坐标系与View绘制流程</title>
    <link href="http://www.idtkm.com/2016/05/08/1%E3%80%81CoordinateAndProcess/"/>
    <id>http://www.idtkm.com/2016/05/08/1、CoordinateAndProcess/</id>
    <published>2016-05-07T16:00:00.000Z</published>
    <updated>2017-10-15T16:02:36.459Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Idtk/Blog" target="_blank" rel="external">自定义View系列目录</a></p>
<h2 id="涉及知识"><a href="#涉及知识" class="headerlink" title="涉及知识"></a>涉及知识<br></h2><p><strong>绘制过程</strong><br></p>
<table>
<thead>
<tr>
<th>类别</th>
<th style="text-align:center">API</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>布局</td>
<td style="text-align:center">onMeasure</td>
<td>测量View与Child View的大小</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">onLayout</td>
<td>确定Child View的位置</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">onSizeChanged</td>
<td>确定View的大小</td>
</tr>
<tr>
<td>绘制</td>
<td style="text-align:center">onDraw</td>
<td>实际绘制View的内容</td>
</tr>
<tr>
<td>事件处理</td>
<td style="text-align:center">onTouchEvent</td>
<td>处理屏幕触摸事件</td>
</tr>
<tr>
<td>重绘</td>
<td style="text-align:center">invalidate</td>
<td>调用onDraw方法，重绘View中变化的部分</td>
</tr>
</tbody>
</table>
<p><br></p>
<a id="more"></a>
<p><strong>Canvas涉及方法</strong><br></p>
<table>
<thead>
<tr>
<th>类别</th>
<th style="text-align:center">API</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>绘制图形</td>
<td style="text-align:center">drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc</td>
<td>依次为绘制点、直线、矩形、圆角矩形、椭圆、圆、扇形</td>
</tr>
<tr>
<td>绘制文本</td>
<td style="text-align:center">drawText, drawPosText, drawTextOnPath</td>
<td>依次为绘制文字、指定每个字符位置绘制文字、根据路径绘制文字</td>
</tr>
<tr>
<td>画布变换</td>
<td style="text-align:center">translate, scale, rotate, skew</td>
<td>依次为平移、缩放、旋转、倾斜（错切）</td>
</tr>
<tr>
<td>画布裁剪</td>
<td style="text-align:center">clipPath, clipRect, clipRegion</td>
<td>依次为按路径、按矩形、按区域对画布进行裁剪</td>
</tr>
</tbody>
</table>
<p><br><br><strong>Paint涉及方法</strong><br></p>
<table>
<thead>
<tr>
<th>类别</th>
<th style="text-align:center">API</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>颜色</td>
<td style="text-align:center">setColor, setARGB, setAlpha</td>
<td>依次为设置画笔颜色、透明度</td>
</tr>
<tr>
<td>类型</td>
<td style="text-align:center">setStyle</td>
<td>填充(FILL),描边(STROKE),填充加描边(FILL_AND_STROKE)</td>
</tr>
<tr>
<td>抗锯齿</td>
<td style="text-align:center">setAntiAlias</td>
<td>画笔是否抗锯齿</td>
</tr>
<tr>
<td>字体大小</td>
<td style="text-align:center">setTextSize</td>
<td>设置字体大小</td>
</tr>
<tr>
<td>字体测量</td>
<td style="text-align:center">getFontMetrics()，getFontMetricsInt()</td>
<td>返回字体的测量，返回值依次为float、int</td>
</tr>
<tr>
<td>文字宽度</td>
<td style="text-align:center">measureText</td>
<td>返回文字的宽度</td>
</tr>
<tr>
<td>文字对齐方式</td>
<td style="text-align:center">setTextAlign</td>
<td>左对齐(LEFT),居中对齐(CENTER),右对齐(RIGHT)</td>
</tr>
<tr>
<td>宽度</td>
<td style="text-align:center">setStrokeWidth</td>
<td>设置画笔宽度</td>
</tr>
<tr>
<td>笔锋</td>
<td style="text-align:center">setStrokeCap</td>
<td>默认(BUTT),半圆形(ROUND),方形(SQUARE)</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>（<strong>Ps:因API较多，只列出了涉及的方法，想了解更多，请查看<a href="http://developer.android.com/reference/packages.html" target="_blank" rel="external">官方文档</a></strong>)<br></p>
<h2 id="一、坐标系"><a href="#一、坐标系" class="headerlink" title="一、坐标系"></a>一、坐标系</h2><h3 id="1、屏幕坐标系"><a href="#1、屏幕坐标系" class="headerlink" title="1、屏幕坐标系"></a>1、屏幕坐标系</h3><p>&nbsp;&nbsp;屏幕坐标系以手机屏幕的左上角为坐标原点，过的原点水平直线为X轴，向右为正方向；过原点的垂线为Y轴，向下为正方向。<br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/%E5%B1%8F%E5%B9%95.png" alt="屏幕坐标系" title="屏幕坐标系" width="300"><br><br></p>
<h3 id="2、View坐标系"><a href="#2、View坐标系" class="headerlink" title="2、View坐标系"></a>2、View坐标系</h3><p>&nbsp;&nbsp;View坐标系以父视图的左上角为坐标原点，过的原点水平直线为X轴，向右为正方向；过原点的垂线为Y轴，向下为正方向。<br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/%E8%A7%86%E5%9B%BE.png" alt="View坐标系" title="View坐标系" width="300"></p>
<p>View内部拥有四个函数,用于获取View的位置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">getTop();     <span class="comment">//View的顶边到其Parent View的顶边的距离，即View的顶边与View坐标系的X轴之间的距离</span></div><div class="line">getLeft();    <span class="comment">//View的左边到其Parent View的左边的距离，即View的左边与View坐标系的Y轴之间的距离</span></div><div class="line">getBottom();  <span class="comment">//View的底边到其Parent View的顶边的距离，即View的底边与View坐标系的X轴之间的距离</span></div><div class="line">getRight();   <span class="comment">//View的右边到其Parent View的左边的距离，即View的右边与View坐标系的Y轴之间的距离</span></div></pre></td></tr></table></figure></p>
<p>图示如下:<br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/getTop.png" alt="View坐标系" title="View坐标系" width="300"></p>
<h2 id="二、绘制过程"><a href="#二、绘制过程" class="headerlink" title="二、绘制过程"></a>二、绘制过程<br></h2><h3 id="1、构造函数"><a href="#1、构造函数" class="headerlink" title="1、构造函数"></a>1、构造函数</h3><p>&nbsp;&nbsp;构造函数用于读取一些参数、属性对View进行初始化操作<br><br>&nbsp;&nbsp;View的构造函数有四种重载方法，分别如下:<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseChart</span><span class="params">(Context context)</span> </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseChart</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseChart</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseChart</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>context:</strong>上下文，新建时传入,如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BaseChart baseChart = <span class="keyword">new</span> BaseChart(<span class="keyword">this</span>);</div></pre></td></tr></table></figure></p>
<p><strong>AttributeSet:</strong>是节点的属性集合,如:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">com.customview.BaseChart</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">app:attr1</span>=<span class="string">"attr1 from xml"</span></div><div class="line">    <span class="attr">app:attr2</span>=<span class="string">"attr2 from xml"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>即com.customview.PieChart节点中的属性集合<br><br><br><br><strong>defStyleAttr:</strong>默认风格，是指它在当前Application或Activity所用的Theme中的默认Style,如:<br><br>在attrs.xml中添加<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"base_chart_style"</span> <span class="attr">format</span>=<span class="string">"reference"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>引用的是styles.xml文件中<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"base_chart_style"</span>&gt;</span><span class="xml"></span></div><div class="line">	<span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"attr2"</span>&gt;</span>@string/attr2<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"attr3"</span>&gt;</span>@string/attr3<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在当前默认主题中添加这个style<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span><span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="xml"></span></div><div class="line">	...</div><div class="line">	<span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"base_chart_style"</span>&gt;</span>@stylebase_chart_style<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">	...</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><br><br><strong>defStyleRes:</strong>默认风格，<em>只有当defStyleAttr无效时，才会使用这个值</em>,如：<br><br>在style.xml中添加<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"base_chart_res"</span>&gt;</span><span class="xml"></span></div><div class="line">	<span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"attr4"</span>&gt;</span>attr4 from base_chart_res<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"attr5"</span>&gt;</span>attr5 from base_chart_res<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h1 id=""><a href="#" class="headerlink" title=""></a><br></h1><h3 id="一个实例——BaseChart"><a href="#一个实例——BaseChart" class="headerlink" title="一个实例——BaseChart"></a>一个实例——BaseChart<br></h3><p>新建BaseChart类机成自view<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseChart</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String TAG = <span class="string">"BaseChart"</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseChart</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(context,<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseChart</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(context, attrs,R.attr.base_chart_style);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseChart</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(context, attrs, defStyleAttr,R.style.base_chart_res);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseChart</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</div><div class="line">        TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.base_chart, defStyleAttr,defStyleRes);</div><div class="line">        <span class="keyword">int</span> n = array.getIndexCount();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</div><div class="line">            <span class="keyword">int</span> attr = array.getIndex(i);</div><div class="line">            <span class="keyword">switch</span> (attr)&#123;</div><div class="line">                <span class="keyword">case</span> R.styleable.base_chart_attr1:</div><div class="line">                    Log.d(TAG,<span class="string">"attr1 =&gt;"</span> + array.getString(attr));</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> R.styleable.base_chart_attr2:</div><div class="line">                    Log.d(TAG,<span class="string">"attr2 =&gt;"</span> + array.getString(attr));</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> R.styleable.base_chart_attr3:</div><div class="line">                    Log.d(TAG,<span class="string">"attr3 =&gt;"</span> + array.getString(attr));</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> R.styleable.base_chart_attr4:</div><div class="line">                    Log.d(TAG,<span class="string">"attr4 =&gt;"</span> + array.getString(attr));</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> R.styleable.base_chart_attr5:</div><div class="line">                    Log.d(TAG,<span class="string">"attr5 =&gt;"</span> + array.getString(attr));</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>obtainStyledAttributes(AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes)新增加的attrs属性说明如下:<br><br><strong>attrs:</strong>默认属性，告诉系统需要获取那些属性的值，有多种Value类型，这里使用string类型，如：<br><br>在attrs.xml中添加<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"base_chart"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"attr1"</span> <span class="attr">format</span>=<span class="string">"string"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"attr2"</span> <span class="attr">format</span>=<span class="string">"string"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"attr3"</span> <span class="attr">format</span>=<span class="string">"string"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"attr4"</span> <span class="attr">format</span>=<span class="string">"string"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"attr5"</span> <span class="attr">format</span>=<span class="string">"string"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>使用上面提到的变量属性和布局文件<br></p>
<h4 id="a、defStyleAttr与defStyleRes参数先设置为0"><a href="#a、defStyleAttr与defStyleRes参数先设置为0" class="headerlink" title="a、defStyleAttr与defStyleRes参数先设置为0"></a>a、defStyleAttr与defStyleRes参数先设置为0<br></h4><p>运行后显示如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BaseChart: attr1 =&gt;attr1 from xml</div><div class="line">BaseChart: attr2 =&gt;attr2 from xml</div><div class="line">BaseChart: attr3 =&gt;null</div><div class="line">BaseChart: attr4 =&gt;null</div><div class="line">BaseChart: attr5 =&gt;null</div></pre></td></tr></table></figure></p>
<p>attr1与attr2输出均来自布局文件的设置<br></p>
<p>======</p>
<h4 id="b、修改BaseView-java设置，引入defStyleAttr"><a href="#b、修改BaseView-java设置，引入defStyleAttr" class="headerlink" title="b、修改BaseView.java设置，引入defStyleAttr:"></a>b、修改BaseView.java设置，引入defStyleAttr:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.base_chart, defStyleAttr,<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>相当于在布局文件中设置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app:theme="@style/base_chart_style"</div></pre></td></tr></table></figure></p>
<p>运行后显示如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BaseChart: attr1 =&gt;attr1 from xml</div><div class="line">BaseChart: attr2 =&gt;attr2 from xml</div><div class="line">BaseChart: attr3 =&gt;attr3 from BaseChartStyle</div><div class="line">BaseChart: attr4 =&gt;null</div><div class="line">BaseChart: attr5 =&gt;null</div></pre></td></tr></table></figure></p>
<p>attr1:仅在布局文件中设置，所以输出为 <em>attr1 from xml</em><br><br>attr2:在布局文件与默认主题的base_chart_style都进行了设置，布局文件中的设置优先级更高，所以输出为 <em>attr2 from xml</em><br><br>attr3:仅在默认主题base_chart_style中进行了设置，所以输出为 <em>attr3 from BaseChartStyle</em><br></p>
<p>======</p>
<h4 id="c、在布局文件中增加自定义的style"><a href="#c、在布局文件中增加自定义的style" class="headerlink" title="c、在布局文件中增加自定义的style"></a>c、在布局文件中增加自定义的style</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">com.customview.BaseChart</span></span></div><div class="line">	<span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">app:attr1</span>=<span class="string">"attr1 from xml"</span></div><div class="line">    <span class="attr">app:attr2</span>=<span class="string">"attr2 from xml"</span></div><div class="line">    <span class="attr">style</span>=<span class="string">"@style/xml_style"</span>/&gt;</div></pre></td></tr></table></figure>
<p>运行后结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BaseChart: attr1 =&gt;attr1 from xml</div><div class="line">BaseChart: attr2 =&gt;attr2 from xml</div><div class="line">BaseChart: attr3 =&gt;attr3 from xml_style</div><div class="line">BaseChart: attr4 =&gt;attr4 from xml_style</div><div class="line">BaseChart: attr5 =&gt;null</div></pre></td></tr></table></figure></p>
<p>attr1:仅在布局文件中设置，所以输出为 <em>attr1 from xml</em><br><br>attr2:在布局文件与默认主题的base_chart_style都进行了设置，布局文件中的设置优先级更高，所以输出为 <em>attr2 from xml</em><br><br>attr3:在默认主题base_chart_style与自定义主题的xml_style都进行了设置，自定义主题优先级更高，所以输出为 <em>attr3 from xml_style</em><br><br>attr4:仅在自定义主题xml_style中进行了设置，所以输出为 <em>attr4 from xml_style</em><br></p>
<p>======</p>
<h4 id="d、修改BaseView-java设置，引入defStyleRes，修改defStyleAttr为0，否则引入的R-style-base-chart-res不会生效"><a href="#d、修改BaseView-java设置，引入defStyleRes，修改defStyleAttr为0，否则引入的R-style-base-chart-res不会生效" class="headerlink" title="d、修改BaseView.java设置，引入defStyleRes，修改defStyleAttr为0，否则引入的R.style.base_chart_res不会生效:"></a>d、修改BaseView.java设置，引入defStyleRes，修改defStyleAttr为0，否则引入的R.style.base_chart_res不会生效:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.base_chart, <span class="number">0</span> ,R.style.base_chart_res);</div></pre></td></tr></table></figure>
<p>运行后输入结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BaseChart: attr1 =&gt;attr1 from xml</div><div class="line">BaseChart: attr2 =&gt;attr2 from xml</div><div class="line">BaseChart: attr3 =&gt;attr3 from xml_style</div><div class="line">BaseChart: attr4 =&gt;attr4 from xml_style</div><div class="line">BaseChart: attr5 =&gt;attr5 =&gt;attr5 from base_chart_res</div></pre></td></tr></table></figure></p>
<p>attr1:仅在布局文件中设置，所以输出为 <em>attr1 from xml</em><br><br>attr2:仅在布局文件中进行了设置，所以输出为 <em>attr2 from xml</em><br><br>attr3:仅在自定义主题xml_style中进行了设置，所以输出为 <em>attr3 from xml_style</em><br><br>attr4:在自定义主题xml_style和defStyleRes中都进行了设置，自定义主题优先级更高，所以输出为 <em>attr4 from xml_style</em><br><br>attr5:仅在defStyleRes中进行了设置,所以输出为 <em>attr5 from base_chart_res</em><br></p>
<p>======</p>
<h3 id="2、onMeasure"><a href="#2、onMeasure" class="headerlink" title="2、onMeasure"></a>2、onMeasure</h3><p>View会在此函数中完成自己的Measure以及递归的遍历完成Child View的Measure，某些情况下需要多次Measure才能确定View的大小。<br><br>可以从onMeasure中取出宽高及其他属性:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">	<span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    <span class="comment">//Width</span></div><div class="line">    <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);<span class="comment">//宽度值</span></div><div class="line">    <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);<span class="comment">//宽度测量模式</span></div><div class="line">    <span class="comment">//Height</span></div><div class="line">    <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);<span class="comment">//高度值</span></div><div class="line">    <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);<span class="comment">//高度测量模式</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由此可见<strong>widthMeasureSpec, heightMeasureSpec</strong>并不仅仅是宽高的值，还对应了宽高的测量模式。<br><br>MeasureSpec是View内部的一个静态类，下面给出它的部分源码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MeasureSpec</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</div><div class="line">			<span class="keyword">return</span> size + mode;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</div><div class="line">				&#125;</div><div class="line">        &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">    	<span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出<strong>MeasureSpec代表一个32的int值，高2位代表测量模式SpecMode，低30位代表测量值SpecSize</strong>。拥有3种测量模式，分别为<strong>UNSPECIFIED、EXACTLY、AT_MOST</strong>。<br></p>
<table>
<thead>
<tr>
<th>测量类型</th>
<th style="text-align:center">对应数值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>UNSPECIFIED</td>
<td style="text-align:center">0</td>
<td>父容器不对 view 有任何限制，要多大给多大</td>
</tr>
<tr>
<td>EXACTLY</td>
<td style="text-align:center">1</td>
<td>父容器已经检测出 view 所需要的大小,比如固定大小xxdp</td>
</tr>
<tr>
<td>AT_MOST</td>
<td style="text-align:center">2</td>
<td>父容器指定了一个大小， view 的大小不能大于这个值</td>
</tr>
</tbody>
</table>
<p>======</p>
<h3 id="3、onLayout"><a href="#3、onLayout" class="headerlink" title="3、onLayout"></a>3、onLayout</h3><p>用于确定View以及其子View的布局位置，在ViewGroup中，当位置被确定后，它在onLayout中会遍历所有的child并调用其layout，然后layout内部会再调用child的onLayout确定child View的布局位置。<br><br>layout方法如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">	...</div><div class="line">    <span class="keyword">int</span> oldL = mLeft;</div><div class="line">    <span class="keyword">int</span> oldT = mTop;</div><div class="line">    <span class="keyword">int</span> oldB = mBottom;</div><div class="line">    <span class="keyword">int</span> oldR = mRight;</div><div class="line">	...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>mLeft, mTop, mBottom, mRight</strong>四个参数分别通过<strong>getLeft(),getTop(),getRight(),getBottom()</strong>四个函数获得。这一组old值会在位置改变时，调用onLayoutChange时使用到。<br></p>
<p>======</p>
<h3 id="4、onSizeChanged"><a href="#4、onSizeChanged" class="headerlink" title="4、onSizeChanged"></a>4、onSizeChanged</h3><p>如其名，在View大小改变时调用此函数，用于确定View的大小。至于View大小为什么会改变，因为View的大小不仅由本身确定，同时还受父View的影响。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</div><div class="line">	<span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的<strong>w、h</strong>就是确定后的宽高值，如果查看View中的onLayoutChange也会看到类似的情况，拥有l, t, r, b, oldL, oldT, oldR, oldB，新旧两组参数。</p>
<p>======</p>
<h3 id="5、onDraw"><a href="#5、onDraw" class="headerlink" title="5、onDraw"></a>5、onDraw</h3><p>onDraw是View的绘制部分，给了我们一张空白的画布，使用Canvas进行绘制。也是后面几篇文章所要分享的内容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">	<span class="keyword">super</span>.onDraw(canvas);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>======</p>
<h3 id="6、其他方法以及监听回调"><a href="#6、其他方法以及监听回调" class="headerlink" title="6、其他方法以及监听回调"></a>6、其他方法以及监听回调</h3><p>如onTouchEvent、invalidate、setOnTouchListener等方法。<br><br><strong>onTouchEvent</strong>用于处理传递到的View手势事件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当返回<strong>true</strong>时，说明该View消耗了触摸事件，后续的触摸事件也由它来进行处理。返回<strong>false</strong>时，说明该View对触摸事件不感兴趣，事件继续传递下去。<br><br>触屏事件类型被封装在MotionEvent中，MotionEvent提供了很多类型的事件，主要关心如下几种类型:<br></p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACTION_DOWN</td>
<td>手指按下</td>
</tr>
<tr>
<td>ACTION_MOVE</td>
<td>手指移动</td>
</tr>
<tr>
<td>ACTION_UP</td>
<td>手指抬起</td>
</tr>
</tbody>
</table>
<p><br><br><strong>事件效果如下:</strong><br><br><img src="http://upload-images.jianshu.io/upload_images/623378-34fd10214730ea5f.gif?imageMogr2/auto-orient/strip" alt="屏幕触摸事件" title="屏幕触摸事件" width="300"><br><br>在MotionEvent中有两组可以获得触摸位置的函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">event.getX();      <span class="comment">//触摸点相对于View坐标系的X坐标</span></div><div class="line">event.getY();	   <span class="comment">//触摸点相对于View坐标系的Y坐标</span></div><div class="line">event.getRawX();   <span class="comment">//触摸点相对于屏幕坐标系的X坐标</span></div><div class="line">event.getRawY();   <span class="comment">//触摸点相对于屏幕坐标系的Y坐标</span></div></pre></td></tr></table></figure></p>
<p>图示如下:<br><br><img src="http://ompb0h8qq.bkt.clouddn.com/old/getRawX.png" alt="View坐标系" title="View坐标系" width="300"><br></p>
<p><strong>onWindowFocusChanged</strong>运行于onMeasure与onLayout之后，可以获取到正确的width、height、top、left等属性值。<br></p>
<h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>&nbsp;&nbsp;简单分析了自定义View的入门准备知识，包括屏幕坐标系、View坐标、View的绘制过程中的主要函数、以及屏幕触摸事件。后面的内容将会围绕onDraw函数展开，在完成涉及知识点的分析之后，将会实战去编写PieView的代码。如果在阅读过程中，有任何疑问与问题，欢迎与我联系。<br><br><strong>博客:www.idtkm.com</strong><br><br><strong>GitHub:<a href="https://github.com/Idtk" target="_blank" rel="external">https://github.com/Idtk</a></strong><br><br><strong>微博:<a href="http://weibo.com/Idtk" target="_blank" rel="external">http://weibo.com/Idtk</a></strong><br><br><strong>邮箱:IdtkMa@gmail.com</strong><br></p>
<p><strong>PieChart效果图如下：</strong><br><br><img src="http://ompb0h8qq.bkt.clouddn.com/all/PieChart.gif" alt="PieChart" title="PieChart"><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Idtk/Blog&quot;&gt;自定义View系列目录&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;涉及知识&quot;&gt;&lt;a href=&quot;#涉及知识&quot; class=&quot;headerlink&quot; title=&quot;涉及知识&quot;&gt;&lt;/a&gt;涉及知识&lt;br&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;绘制过程&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;API&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;布局&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;onMeasure&lt;/td&gt;
&lt;td&gt;测量View与Child View的大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;onLayout&lt;/td&gt;
&lt;td&gt;确定Child View的位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;onSizeChanged&lt;/td&gt;
&lt;td&gt;确定View的大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;绘制&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;onDraw&lt;/td&gt;
&lt;td&gt;实际绘制View的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;事件处理&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;onTouchEvent&lt;/td&gt;
&lt;td&gt;处理屏幕触摸事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;重绘&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;invalidate&lt;/td&gt;
&lt;td&gt;调用onDraw方法，重绘View中变化的部分&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.idtkm.com/categories/Android/"/>
    
    
      <category term="CustomView" scheme="http://www.idtkm.com/tags/CustomView/"/>
    
  </entry>
  
</feed>
